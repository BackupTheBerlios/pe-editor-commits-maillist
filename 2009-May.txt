From bonefish at mail.berlios.de  Sat May  2 00:11:14 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 00:11:14 +0200
Subject: [pe-commits] r560 - trunk/build
Message-ID: <200905012211.n41MBEkC024727@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 00:11:13 +0200 (Sat, 02 May 2009)
New Revision: 560
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=560&view=rev

Modified:
   trunk/build/MainBuildRules
Log:
Use the correct stdc++ lib on gcc 4.


Modified: trunk/build/MainBuildRules
===================================================================
--- trunk/build/MainBuildRules	2009-04-26 16:51:47 UTC (rev 559)
+++ trunk/build/MainBuildRules	2009-05-01 22:11:13 UTC (rev 560)
@@ -426,7 +426,13 @@
 
 # Variable referring to the STL.
 if $(OSPLAT) = X86 {
-	STDC++LIB = stdc++.r4 ;
+	local hasLibStdC++.R4 = [ Glob /boot/develop/lib/x86 : libstdc++.r4.so ] ;
+	if $(hasLibStdC++.R4) {
+		STDC++LIB = stdc++.r4 ;
+	} else {
+		# supposedly a gcc 4 Haiku
+		STDC++LIB = stdc++ ;
+	}
 } else {
 	STDC++LIB = mslcpp_4_0 ;
 }



From bonefish at mail.berlios.de  Sat May  2 00:11:51 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 00:11:51 +0200
Subject: [pe-commits] r561 - trunk/rez/Sources
Message-ID: <200905012211.n41MBpu9024789@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 00:11:51 +0200 (Sat, 02 May 2009)
New Revision: 561
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=561&view=rev

Modified:
   trunk/rez/Sources/RElem.cpp
   trunk/rez/Sources/REval.h
   trunk/rez/Sources/RState.cpp
   trunk/rez/Sources/RState.h
   trunk/rez/Sources/rez_parser.y
   trunk/rez/Sources/rez_scanner.l
Log:
gcc 4 fixes.


Modified: trunk/rez/Sources/RElem.cpp
===================================================================
--- trunk/rez/Sources/RElem.cpp	2009-05-01 22:11:13 UTC (rev 560)
+++ trunk/rez/Sources/RElem.cpp	2009-05-01 22:11:51 UTC (rev 561)
@@ -37,8 +37,12 @@
 #include "RElem.h"
 #include "rez.h"
 #include "RState.h"
-#include <cstdio>
 
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
 RElem::RElem(REval *v, int size, int offset, RState *state)
 {
 	fNext = NULL;

Modified: trunk/rez/Sources/REval.h
===================================================================
--- trunk/rez/Sources/REval.h	2009-05-01 22:11:13 UTC (rev 560)
+++ trunk/rez/Sources/REval.h	2009-05-01 22:11:51 UTC (rev 561)
@@ -57,7 +57,7 @@
 	refCopyBits
 };
 
-typedef struct REval {
+struct REval {
 	REval *fLeft, *fRight;
 	REvalType fType;
 	bool fOnStack;

Modified: trunk/rez/Sources/RState.cpp
===================================================================
--- trunk/rez/Sources/RState.cpp	2009-05-01 22:11:13 UTC (rev 560)
+++ trunk/rez/Sources/RState.cpp	2009-05-01 22:11:51 UTC (rev 561)
@@ -37,6 +37,7 @@
 #include "RState.h"
 #include "REval.h"
 #include "SymbolTable.h"
+#include <string.h>
 #include <typeinfo>
 #include <support/Debug.h>
 #include <ByteOrder.h>

Modified: trunk/rez/Sources/RState.h
===================================================================
--- trunk/rez/Sources/RState.h	2009-05-01 22:11:13 UTC (rev 560)
+++ trunk/rez/Sources/RState.h	2009-05-01 22:11:51 UTC (rev 561)
@@ -37,7 +37,7 @@
 #ifndef RSTATE_H
 #define RSTATE_H
 
-#include <map.h>
+#include <map>
 #include "RElem.h"
 #include "SymbolTable.h"
 
@@ -49,7 +49,7 @@
 class RState;
 struct RElem;
 
-typedef map<int, int> intmap;
+typedef std::map<int, int> intmap;
 
 extern intmap gValueMap;
 

Modified: trunk/rez/Sources/rez_parser.y
===================================================================
--- trunk/rez/Sources/rez_parser.y	2009-05-01 22:11:13 UTC (rev 560)
+++ trunk/rez/Sources/rez_parser.y	2009-05-01 22:11:51 UTC (rev 561)
@@ -40,7 +40,9 @@
 #include "RState.h"
 #include "REval.h"
 
-#include <cstdio>
+#include <stdio.h>
+#include <string.h>
+
 #include <List.h>
 #include <ByteOrder.h>
 

Modified: trunk/rez/Sources/rez_scanner.l
===================================================================
--- trunk/rez/Sources/rez_scanner.l	2009-05-01 22:11:13 UTC (rev 560)
+++ trunk/rez/Sources/rez_scanner.l	2009-05-01 22:11:51 UTC (rev 561)
@@ -59,7 +59,7 @@
 YY_BUFFER_STATE macro_stack[MAX_MACRO_DEPTH];
 int macro_stack_ptr = 0;
 
-typedef map<int, char*> macromap ;
+typedef std::map<int, char*> macromap ;
 macromap gMacroTable = *new macromap;
 
 void AddMacro(char *s);



From bonefish at mail.berlios.de  Sat May  2 00:50:16 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 00:50:16 +0200
Subject: [pe-commits] r562 - trunk/Sources
Message-ID: <200905012250.n41MoGxe010051@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 00:50:05 +0200 (Sat, 02 May 2009)
New Revision: 562
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=562&view=rev

Modified:
   trunk/Sources/CCharObject.cpp
   trunk/Sources/CDiff.h
   trunk/Sources/CDiffWindow.cpp
   trunk/Sources/CDoc.h
   trunk/Sources/CDocIO.cpp
   trunk/Sources/CDocIO.h
   trunk/Sources/CFilterChoiceDialog.cpp
   trunk/Sources/CFindDialog.cpp
   trunk/Sources/CFindDialog.h
   trunk/Sources/CFontStyle.cpp
   trunk/Sources/CFontStyle.h
   trunk/Sources/CFtpDialog.cpp
   trunk/Sources/CFtpDialog.h
   trunk/Sources/CFtpListItem.cpp
   trunk/Sources/CGlossary.h
   trunk/Sources/CHtmlBar.h
   trunk/Sources/CKeyMapper.h
   trunk/Sources/CLanguageInterface.cpp
   trunk/Sources/CLanguageInterface.h
   trunk/Sources/CLineObject.cpp
   trunk/Sources/CPrefsDialog.h
   trunk/Sources/CProjectFile.h
   trunk/Sources/CRegex.h
   trunk/Sources/CStdErrParser.cpp
   trunk/Sources/CStdErrParser.h
   trunk/Sources/HButtonBar.h
   trunk/Sources/HColorPicker2.cpp
   trunk/Sources/HColorUtils.cpp
   trunk/Sources/HDialog.cpp
   trunk/Sources/HDialogViews.h
   trunk/Sources/HLazyObject.cpp
   trunk/Sources/HPreferences.h
   trunk/Sources/MTextAddOnImpl.cpp
   trunk/Sources/PAddOn.cpp
   trunk/Sources/PCmd.cpp
   trunk/Sources/PCmd.h
   trunk/Sources/PDoc.cpp
   trunk/Sources/PDoc.h
   trunk/Sources/PFindFunctionDialog.cpp
   trunk/Sources/PMessageWindow.cpp
   trunk/Sources/PText.cpp
   trunk/Sources/PText.h
   trunk/Sources/PTextBuffer.cpp
   trunk/Sources/utf-support.cpp
Log:
gcc 4 fixes.


Modified: trunk/Sources/CCharObject.cpp
===================================================================
--- trunk/Sources/CCharObject.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CCharObject.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -56,7 +56,7 @@
 
 void CCharObject::MessageReceived(BMessage *msg)
 {
-	auto_ptr<CCharObject> destroy(this);
+	std::auto_ptr<CCharObject> destroy(this);
 
 	switch (msg->what)
 	{

Modified: trunk/Sources/CDiff.h
===================================================================
--- trunk/Sources/CDiff.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CDiff.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -36,6 +36,12 @@
 #ifndef CDIFF_H
 #define CDIFF_H
 
+#include <vector>
+
+
+using std::vector;
+
+
 class CDiff
 {
 public:

Modified: trunk/Sources/CDiffWindow.cpp
===================================================================
--- trunk/Sources/CDiffWindow.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CDiffWindow.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -123,7 +123,8 @@
 	be_plain_font->GetHeight(&fh);
 	
 	r = b;
-	r.bottom = r.top + max(kToolBarHeight, (fh.ascent + fh.descent - 1) * 2 + 1);
+	r.bottom = r.top + std::max(kToolBarHeight,
+		(fh.ascent + fh.descent - 1) * 2 + 1);
 
 	fToolBar = new CDiffToolBar(r, "DiffToolBar");
 	AddChild(fToolBar);
@@ -740,7 +741,7 @@
 		GetDocs(docA, docB, false);
 
 		if (toFile == 2)
-			swap(docA, docB);
+			std::swap(docA, docB);
 		
 		char *s;
 		{

Modified: trunk/Sources/CDoc.h
===================================================================
--- trunk/Sources/CDoc.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CDoc.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -45,8 +45,11 @@
 class CDoc;
 class URLData;
 
-typedef list<CDoc*> doclist;
+using std::string;
+using std::vector;
 
+typedef std::list<CDoc*> doclist;
+
 // types of linebreaks
 enum {
 	kle_UNKNOWN = -1,

Modified: trunk/Sources/CDocIO.cpp
===================================================================
--- trunk/Sources/CDocIO.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CDocIO.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -676,7 +676,7 @@
 				}
 			}
 
-			fLastSaved = max(fLastSaved, time(NULL));
+			fLastSaved = std::max(fLastSaved, time(NULL));
 				// if more than one update request was issued
 				// in the mean time, only the first one is
 				// considered

Modified: trunk/Sources/CDocIO.h
===================================================================
--- trunk/Sources/CDocIO.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CDocIO.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -87,7 +87,7 @@
 			node_ref fNodeRef;
 			BLooper* fTarget;
 
-	typedef map<node_ref, int32> WatchedFolderMap;
+	typedef std::map<node_ref, int32> WatchedFolderMap;
 	WatchedFolderMap sfWatchedFolderMap;
 	static	BLocker sfDocListLock;
 };

Modified: trunk/Sources/CFilterChoiceDialog.cpp
===================================================================
--- trunk/Sources/CFilterChoiceDialog.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFilterChoiceDialog.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -403,7 +403,7 @@
 	BMessage *message = new BMessage(MSG_COMMIT_REQUEST);
 	FailNil(message);
 	BRect rect(bounds);
-	fFilterStringControl = new(nothrow) BTextControl(rect, "filter text",
+	fFilterStringControl = new(std::nothrow) BTextControl(rect, "filter text",
 		"Filter", "", message,
 		B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP, B_WILL_DRAW);
 	FailNil(fFilterStringControl);
@@ -420,14 +420,14 @@
 	rect.top = fFilterStringControl->Frame().bottom + 1 + 5;
 	rect.right -= B_V_SCROLL_BAR_WIDTH;
 	rect.bottom -= B_H_SCROLL_BAR_HEIGHT;
-	fChoicesList = new(nothrow) BListView(rect, "choices list",
+	fChoicesList = new(std::nothrow) BListView(rect, "choices list",
 		B_SINGLE_SELECTION_LIST, B_FOLLOW_ALL, B_WILL_DRAW | B_FRAME_EVENTS);
 	FailNil(fChoicesList);
 	message = new BMessage(MSG_COMMIT_REQUEST);
 	fChoicesList->SetInvocationMessage(message);
 	fChoicesList->SetTarget(this);
 	// scroll view
-	BScrollView *scrollView = new(nothrow) BScrollView("scroll view",
+	BScrollView *scrollView = new(std::nothrow) BScrollView("scroll view",
 		fChoicesList, B_FOLLOW_ALL, 0, true, true, B_FANCY_BORDER); 
 	fMainView->AddChild(scrollView);
 	scrollView->SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));
@@ -438,7 +438,7 @@
 	// get the choice groups
 	fItemCount = 0;
 	fGroupCount = fModel->CountChoiceGroups();
-	fGroupInfos = new(nothrow) ChoiceGroupInfo[fGroupCount];
+	fGroupInfos = new(std::nothrow) ChoiceGroupInfo[fGroupCount];
 	FailNil(fGroupInfos);
 	for (int i = 0; i < fGroupCount; i++) 
 	{
@@ -450,7 +450,7 @@
 			// + 1 for group separator item
 	}
 	// get the item infos
-	fItemInfos = new(nothrow) ChoiceItemInfo[fItemCount];
+	fItemInfos = new(std::nothrow) ChoiceItemInfo[fItemCount];
 	FailNil(fItemInfos);
 	for (int groupIndex = 0; groupIndex < fGroupCount; groupIndex++) 
 	{
@@ -458,7 +458,7 @@
 		// add a group separator item
 		ChoiceItemInfo& separatorItemInfo = fItemInfos[groupInfo.index - 1];
 		separatorItemInfo.choiceItem = NULL;
-		separatorItemInfo.listItem = new(nothrow) SeparatorListItem(
+		separatorItemInfo.listItem = new(std::nothrow) SeparatorListItem(
 			groupIndex, -1, &separatorItemInfo);
 		separatorItemInfo.isSeparator = true;
 		// add the group's real items
@@ -469,7 +469,7 @@
 			itemInfo.choiceItem = choiceItem;
 			if (choiceItem->IsSeparator()) 
 			{
-				itemInfo.listItem = new(nothrow) SeparatorListItem(
+				itemInfo.listItem = new(std::nothrow) SeparatorListItem(
 					groupIndex, i, &itemInfo);
 				itemInfo.isSeparator = true;
 			} 
@@ -477,7 +477,7 @@
 			{
 				bool italic = choiceItem->IsItalic();
 				BFont *font = (italic ? &fItalicFont : &fPlainFont);
-				itemInfo.listItem = new(nothrow) ChoiceListItem(
+				itemInfo.listItem = new(std::nothrow) ChoiceListItem(
 					groupIndex, i, &itemInfo, font);
 				itemInfo.isSeparator = false;
 			}
@@ -543,12 +543,12 @@
 				if (y < 0) 
 				{
 					value -= delta;
-					value = max(minVal, value);
+					value = std::max(minVal, value);
 				}
 				else 
 				{
 					value += delta;
-					value = min(maxVal, value);
+					value = std::min(maxVal, value);
 				}
 				vScroller->SetValue(value);
 			}
@@ -671,7 +671,7 @@
 			= (fh.ascent + fh.descent + fh.leading) * kMaximalVisibleListItems;
 		// we can get the height from the frame of the last item
 		BRect itemFrame(fChoicesList->ItemFrame(count -1));
-		float desiredListHeight = min(itemFrame.bottom, maxListHeight);
+		float desiredListHeight = std::min(itemFrame.bottom, maxListHeight);
 		if (listBounds.Height() > maxListHeight)
 			frame.bottom += maxListHeight - listBounds.Height();
 		else if (listBounds.Height() < desiredListHeight)

Modified: trunk/Sources/CFindDialog.cpp
===================================================================
--- trunk/Sources/CFindDialog.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFindDialog.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -405,9 +405,9 @@
 	BRect r = fMainView->Bounds();
 
 	// Position Buttons
-	w = max(fButFind->Width(), fButRepl->Width());
-	w = max(w, fButRepF->Width());
-	w = max(w, fButRepA->Width());
+	w = std::max(fButFind->Width(), fButRepl->Width());
+	w = std::max(w, fButRepF->Width());
+	w = std::max(w, fButRepA->Width());
 
 	fButFind->MoveTo(fMainView->Right()-w-dx, dy);
 	fButFind->SetWidth(w);
@@ -434,17 +434,17 @@
 	fScrRepl->ResizeTo(w, lineHeight*2+6);
 
 	// Multi File Search
-	w = max(fChkText->Width(), fChkRecu->Width());
-	wd = max(fMfdNamp->Divider(), fMfdSdir->Divider());
+	w = std::max(fChkText->Width(), fChkRecu->Width());
+	wd = std::max(fMfdNamp->Divider(), fMfdSdir->Divider());
 	fMfdSdir->SetDivider(wd);
 	fMfdNamp->SetDivider(wd);
 
 	fChkText->MoveTo(dx, r.bottom-fChkText->Height()-dy);
 	fChkRecu->MoveAbove(fChkText, 2);
 
-	wm = max(fMfdNamp->StringWidth(fMitNampAny->Label()), fMfdNamp->StringWidth(fMitNampEnd->Label()));
-	wm = max(wm, fMfdNamp->StringWidth(fMitNampBeg->Label()));
-	wm = max(wm, fMfdNamp->StringWidth(fMitNampCon->Label()));
+	wm = std::max(fMfdNamp->StringWidth(fMitNampAny->Label()), fMfdNamp->StringWidth(fMitNampEnd->Label()));
+	wm = std::max(wm, fMfdNamp->StringWidth(fMitNampBeg->Label()));
+	wm = std::max(wm, fMfdNamp->StringWidth(fMitNampCon->Label()));
 	wm += fMfdNamp->StringWidth("WW");
 
 	fMfdNamp->MoveTo(2*dx+w, fChkText->Top()-2);
@@ -453,8 +453,8 @@
 	fMfdSdir->MoveTo(2*dx+w, fChkRecu->Top()-2);
 	fMfdSdir->MenuBar()->SetMaxContentWidth(r.right-fMfdSdir->Left()-fMfdSdir->Divider()-2*dx-30);
 
-	wm = max(fMfdMeth->StringWidth(fMitMethDir->Label()), fMfdMeth->StringWidth(fMitMethWin->Label()));
-	wm = max(wm, fMfdMeth->StringWidth(fMitMethInc->Label()));
+	wm = std::max(fMfdMeth->StringWidth(fMitMethDir->Label()), fMfdMeth->StringWidth(fMitMethWin->Label()));
+	wm = std::max(wm, fMfdMeth->StringWidth(fMitMethInc->Label()));
 	wm += fMfdMeth->StringWidth("WW");
 
 	fChkMult->MoveAbove(fChkRecu, dy);
@@ -466,15 +466,15 @@
 	fChkWrap->MoveAbove(fChkMult, dy);
 	fChkCase->MoveAbove(fChkWrap);
 
-	fChkWord->MoveTo(max(fChkCase->Right(), fChkWrap->Right())+dx, fChkWrap->Top());
+	fChkWord->MoveTo(std::max(fChkCase->Right(), fChkWrap->Right())+dx, fChkWrap->Top());
 	fChkBack->MoveAbove(fChkWord);
 
-	fChkBtch->MoveTo(max(fChkBack->Right(), fChkWord->Right())+dx, fChkWrap->Top());
+	fChkBtch->MoveTo(std::max(fChkBack->Right(), fChkWord->Right())+dx, fChkWrap->Top());
 	fChkGrep->MoveAbove(fChkBtch);
 
 	// set minimum height to fit one line in textviews...
 	h = fScrRepl->Bottom()+r.bottom-fChkCase->Top()+2;
-	w = 2*dx+max(fChkGrep->Right(), fChkBtch->Right())+fButRepA->Width();
+	w = 2*dx+std::max(fChkGrep->Right(), fChkBtch->Right())+fButRepA->Width();
 	ResizeToLimits(w, 99999, h-2*lineHeight, 99999);
 	// ...but default to two lines in textviews:
 	ResizeTo(w, h);
@@ -1647,7 +1647,7 @@
 				
 			free(l);
 			
-			offset = max(e, offset+1);
+			offset = std::max(e, offset+1);
 			r = regex->Match(buf, size, offset);
 			offset = regex->MatchStart();
 			e = offset + regex->MatchLen();

Modified: trunk/Sources/CFindDialog.h
===================================================================
--- trunk/Sources/CFindDialog.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFindDialog.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -46,6 +46,8 @@
 class PMessageItem;
 class PDoc;
 
+using std::stack;
+
 const unsigned long
 	msg_QueryCanReplace = 'CRpl',
 	msg_ReplyCanReplace = 'RpRp';

Modified: trunk/Sources/CFontStyle.cpp
===================================================================
--- trunk/Sources/CFontStyle.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFontStyle.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -175,7 +175,7 @@
 
 void CFontStyle::ReHash()
 {
-	int nc = max(1, fEscapementsCount * 2);
+	int nc = std::max(1, fEscapementsCount * 2);
 	EscapementEntry *n = (EscapementEntry *)calloc(nc, sizeof(EscapementEntry));
 	FailNil(n);
 	

Modified: trunk/Sources/CFontStyle.h
===================================================================
--- trunk/Sources/CFontStyle.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFontStyle.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -43,7 +43,7 @@
 #include "Benaphore.h"
 typedef float f_unit_t;
 
-//using namespace std;
+using std::vector;
 
 struct EscapementEntry {
 	int unicode;

Modified: trunk/Sources/CFtpDialog.cpp
===================================================================
--- trunk/Sources/CFtpDialog.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFtpDialog.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -225,12 +225,12 @@
 	fUsePassive->MoveTo(dx, fPassword->Bottom()+dy);
 	fConnectButton->MoveTo(2*dx, fUsePassive->Bottom()+dy);
 	//
-	float bw = max(max(dx*10, fCancelButton->Width()), fOkButton->Width());
-	bw = max(bw, fServerName->Right());
-	bw = max(bw, fUserName->Right());
-	bw = max(bw, fPassword->Right());
-	bw = max(bw, fUsePassive->Right());
-	bw = max(bw, fConnectButton->Right()+2*dx);
+	float bw = std::max(std::max(dx*10, fCancelButton->Width()), fOkButton->Width());
+	bw = std::max(bw, fServerName->Right());
+	bw = std::max(bw, fUserName->Right());
+	bw = std::max(bw, fPassword->Right());
+	bw = std::max(bw, fUsePassive->Right());
+	bw = std::max(bw, fConnectButton->Right()+2*dx);
 	//
 	fServerName->SetWidth(bw);
 	fUserName->SetWidth(bw);
@@ -263,9 +263,9 @@
 	//
 	float minW = 200;
 	float minH = 100;
-	minW = max(minW, 
+	minW = std::max(minW, 
 		       bw + 3*dx + fShowDotted->Width() + fDirectoryField->Width());
-	minH = max(minH, fLoginBox->Bottom()+2*fOkButton->Height()+3*dy);
+	minH = std::max(minH, fLoginBox->Bottom()+2*fOkButton->Height()+3*dy);
 	ResizeToLimits(minW, 99999, minH, 99999);
 } // CFtpDialog::Layout
 

Modified: trunk/Sources/CFtpDialog.h
===================================================================
--- trunk/Sources/CFtpDialog.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFtpDialog.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -40,6 +40,10 @@
 #include "HDialog.h"
 #include "HDialogViews.h"
 
+
+using std::map;
+
+
 class CFtpDialog : public HDialog
 {
   public:

Modified: trunk/Sources/CFtpListItem.cpp
===================================================================
--- trunk/Sources/CFtpListItem.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CFtpListItem.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -147,5 +147,5 @@
 {
 	font_height fh;
 	be_plain_font->GetHeight(&fh);
-	SetHeight(max((float)18.0, 4 + fh.descent + fh.ascent));
+	SetHeight(std::max((float)18.0, 4 + fh.descent + fh.ascent));
 } // CFtpListItem::Update

Modified: trunk/Sources/CGlossary.h
===================================================================
--- trunk/Sources/CGlossary.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CGlossary.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -36,13 +36,15 @@
 #ifndef CGLOSSARY_H
 #define CGLOSSARY_H
 
+#include <string>
 
-//using namespace std;
 
+using std::string;
+
 const unsigned long
 	kModifierMask = B_SHIFT_KEY | B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY;
 
-typedef map<int, string> glossymap;
+typedef std::map<int, string> glossymap;
 
 class CGlossary {
 public:

Modified: trunk/Sources/CHtmlBar.h
===================================================================
--- trunk/Sources/CHtmlBar.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CHtmlBar.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -41,6 +41,8 @@
 class CHtmlButtonPane;
 class CHtmlButton;
 
+using std::vector;
+
 class CHtmlBar : public BWindow {
 public:
 

Modified: trunk/Sources/CKeyMapper.h
===================================================================
--- trunk/Sources/CKeyMapper.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CKeyMapper.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -37,7 +37,7 @@
 #define CKEYMAPPER_H
 
 
-//using namespace std;
+using std::set;
 
 class PText;
 
@@ -52,7 +52,7 @@
 	inline bool operator==(const KeyShortcut& ks) const;
 };
 
-typedef map<KeyShortcut,int> keymap;
+typedef std::map<KeyShortcut,int> keymap;
 
 class CKeyMapper
 {

Modified: trunk/Sources/CLanguageInterface.cpp
===================================================================
--- trunk/Sources/CLanguageInterface.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CLanguageInterface.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -48,6 +48,10 @@
 #include "Prefs.h"
 #include <algorithm>
 
+
+using std::map;
+
+
 unsigned char *CLanguageInterface::sfWordBreakTable = NULL;
 
 class ext {
@@ -400,14 +404,14 @@
 {
 	try
 	{
-		int start = min(text.Anchor(), text.Caret());
-		int end = max(text.Anchor(), text.Caret());
+		int start = std::min(text.Anchor(), text.Caret());
+		int end = std::max(text.Anchor(), text.Caret());
 
 		if (! Balance(text, start, end))
 			THROW((0));
 
-		if (start == min(text.Anchor(), text.Caret()) &&
-			end == max(text.Anchor(), text.Caret()))
+		if (start == std::min(text.Anchor(), text.Caret()) &&
+			end == std::max(text.Anchor(), text.Caret()))
 		{
 			start--; end++;
 			if (! Balance(text, start, end))
@@ -469,9 +473,9 @@
 			int size;
 
 			if (line >= text.LineCount() - 1)
-				size = min(text.Size() - offset, 1024);
+				size = std::min(text.Size() - offset, 1024);
 			else
-				size = min(text.LineStart(line + 1) - offset, 1024);
+				size = std::min(text.LineStart(line + 1) - offset, 1024);
 
 			CAlloca txt(size + 1);
 			text.TextBuffer().Copy(txt, offset, size);
@@ -780,7 +784,7 @@
 						end = start + strcspn(start, "\n");
 					}
 				} else {
-					fKeywordMap.insert(pair<BString, int>(word, currType));
+					fKeywordMap.insert(std::pair<BString, int>(word, currType));
 				}
 				start = end + strspn(end, white);
 				end = start + strcspn(start, white);

Modified: trunk/Sources/CLanguageInterface.h
===================================================================
--- trunk/Sources/CLanguageInterface.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CLanguageInterface.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -106,7 +106,7 @@
 protected:
 		static const int kKeywordBufSize = 128;
 		char fKeywordBuf[kKeywordBufSize+1];
-		typedef multimap<BString, int> KeywordMap;
+		typedef std::multimap<BString, int> KeywordMap;
 		mutable bool fHaveParsedKeywords;
 		mutable KeywordMap fKeywordMap;
 //		void GenerateKeywordMap(const char *ext);

Modified: trunk/Sources/CLineObject.cpp
===================================================================
--- trunk/Sources/CLineObject.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CLineObject.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -83,7 +83,7 @@
 
 void CLineObject::MessageReceived(BMessage *msg)
 {
-	auto_ptr<CLineObject> destroy(this);
+	std::auto_ptr<CLineObject> destroy(this);
 
 	switch (msg->what)
 	{

Modified: trunk/Sources/CPrefsDialog.h
===================================================================
--- trunk/Sources/CPrefsDialog.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CPrefsDialog.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -45,6 +45,8 @@
 class CGrepBox;
 class COutlineListView;
 
+using std::vector;
+
 class CPrefsDialog : public HDialog
 {
 public:

Modified: trunk/Sources/CProjectFile.h
===================================================================
--- trunk/Sources/CProjectFile.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CProjectFile.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -19,6 +19,8 @@
 class BPositionIO;
 class CProjectSerializer;
 
+using std::list;
+
 /*
  * CProjectItem
  *		represents a source-file in a project (displayed in a PProjectWindow).

Modified: trunk/Sources/CRegex.h
===================================================================
--- trunk/Sources/CRegex.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CRegex.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -10,6 +10,8 @@
 
 #include <pcre.h>
 
+using std::vector;
+
 extern const status_t krx_NoMatch;
 extern const status_t krx_NotBOL;
 extern const status_t krx_NotEOL;

Modified: trunk/Sources/CStdErrParser.cpp
===================================================================
--- trunk/Sources/CStdErrParser.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CStdErrParser.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -166,11 +166,12 @@
 			{
 				int l = (int)fErrBuffer.find('\n');
 				
-				CMessageItem *i = new CMessageItem(fErrBuffer.c_str(), min(m, l), CMessageItem::msgInfo);
+				CMessageItem *i = new CMessageItem(fErrBuffer.c_str(),
+					std::min(m, l), CMessageItem::msgInfo);
 				fErrList->AddItem(i);
 				i->SetHeight(h);
 				
-				fErrBuffer.erase(0, min(l + 1, m));
+				fErrBuffer.erase(0, std::min(l + 1, m));
 				m -= l + 1;
 				
 				found = true;

Modified: trunk/Sources/CStdErrParser.h
===================================================================
--- trunk/Sources/CStdErrParser.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/CStdErrParser.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -41,6 +41,9 @@
 
 #include "CRegex.h"
 
+using std::string;
+using std::vector;
+
 class CStdErrParser
 {
   public:

Modified: trunk/Sources/HButtonBar.h
===================================================================
--- trunk/Sources/HButtonBar.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HButtonBar.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -41,6 +41,8 @@
 class HHelpWindow;
 class HButtonBar;
 
+using std::vector;
+
 struct IMPEXP_LIBHEKKEL BtnTemplate {
 	long resID;
 	long cmd;

Modified: trunk/Sources/HColorPicker2.cpp
===================================================================
--- trunk/Sources/HColorPicker2.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HColorPicker2.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -178,7 +178,7 @@
 	r.InsetBy(1, 1);
 
 	BRect knob;
-	float m = min(r.Width(), r.Height());
+	float m = std::min(r.Width(), r.Height());
 	knob.Set(r.left, r.top, m + r.left, m + r.top);
 
 	if (fHorizontal)
@@ -279,9 +279,15 @@
 			if (oldPt != where)
 			{
 				if (fHorizontal)
-					fValue = min(1.0, max(0.0, (where.x - s) / (double)a));
+				{
+					fValue = std::min(1.0,
+						std::max(0.0, (where.x - s) / (double)a));
+				}
 				else
-					fValue = 1 - min(1.0, max(0.0, (where.y - s) / (double)a));
+				{
+					fValue = 1 - std::min(1.0,
+						std::max(0.0, (where.y - s) / (double)a));
+				}
 
 				msg.ReplaceFloat("value", fValue);
 
@@ -332,22 +338,22 @@
 	{
 		case B_UP_ARROW:
 			if (!fHorizontal)
-				nv = min(1.0, (fValue * a + 1) / (double)a);
+				nv = std::min(1.0, (fValue * a + 1) / (double)a);
 			break;
 
 		case B_LEFT_ARROW:
 			if (fHorizontal)
-				nv = max(0.0, (fValue * a - 1) / (double)a);
+				nv = std::max(0.0, (fValue * a - 1) / (double)a);
 			break;
 
 		case B_DOWN_ARROW:
 			if (!fHorizontal)
-				nv = max(0.0, (fValue * a - 1) / (double)a);
+				nv = std::max(0.0, (fValue * a - 1) / (double)a);
 			break;
 
 		case B_RIGHT_ARROW:
 			if (fHorizontal)
-				nv = min(1.0, (fValue * a + 1) / (double)a);
+				nv = std::min(1.0, (fValue * a + 1) / (double)a);
 			break;
 
 		default:
@@ -449,8 +455,8 @@
 
 	do
 	{
-		int nx = max(2, min((int)where.x, mx));
-		int ny = max(2, min((int)where.y, my));
+		int nx = std::max(2, std::min((int)where.x, mx));
+		int ny = std::max(2, std::min((int)where.y, my));
 
 		if (nx != fX || ny != fY)
 		{

Modified: trunk/Sources/HColorUtils.cpp
===================================================================
--- trunk/Sources/HColorUtils.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HColorUtils.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -134,10 +134,10 @@
 {
 	rgb_color rgb;
 
-	rgb.red = (int)(max(0.0, min(255.0, r * 255.0)));
-	rgb.green = (int)(max(0.0, min(255.0, g * 255.0)));
-	rgb.blue = (int)(max(0.0, min(255.0, b * 255.0)));
-	rgb.alpha = (int)(max(0.0, min(255.0, a * 255.0)));
+	rgb.red = (int)(std::max(0.0, std::min(255.0, r * 255.0)));
+	rgb.green = (int)(std::max(0.0, std::min(255.0, g * 255.0)));
+	rgb.blue = (int)(std::max(0.0, std::min(255.0, b * 255.0)));
+	rgb.alpha = (int)(std::max(0.0, std::min(255.0, a * 255.0)));
 
 	return rgb;
 } /* f2rgb */
@@ -146,8 +146,8 @@
 {
 	float cmin, cmax, delta;
 	
-	cmax = max(r, max(g, b));
-	cmin = min(r, min(g, b));
+	cmax = std::max(r, std::max(g, b));
+	cmin = std::min(r, std::min(g, b));
 	delta = cmax - cmin;
 	
 	v = cmax;

Modified: trunk/Sources/HDialog.cpp
===================================================================
--- trunk/Sources/HDialog.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HDialog.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -50,7 +50,7 @@
 	msg_AddDialog		= 'ADlg',
 	msg_RemoveDialog	= 'RDlg';
 
-typedef map<int, FieldCreator> field_map;
+typedef std::map<int, FieldCreator> field_map;
 
 static field_map *sFieldMap = NULL;
 
@@ -114,8 +114,8 @@
 {
 	SetSizeLimits(minW, maxW, minH, maxH);
 	BRect frame = Frame();
-	float w = min(maxW, max(minW, frame.Width()));
-	float h = min(maxH, max(minH, frame.Height()));
+	float w = std::min(maxW, std::max(minW, frame.Width()));
+	float h = std::min(maxH, std::max(minH, frame.Height()));
 	ResizeTo(w, h);
 }
 
@@ -551,7 +551,7 @@
 	if (typeid(*v) == typeid(BMenuField))
 	{
 		BMenu *menu = static_cast<BMenuField*>(v)->Menu();
-		return max(menu->IndexOf(menu->FindMarked()) + 1, 1L);
+		return std::max(menu->IndexOf(menu->FindMarked()) + 1, 1L);
 	}
 	else if (typeid(*v) == typeid(BTextControl))
 		return atoi(GetText(id));

Modified: trunk/Sources/HDialogViews.h
===================================================================
--- trunk/Sources/HDialogViews.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HDialogViews.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -45,7 +45,9 @@
 #define H_FOLLOW_LEFT_RIGHT_TOP		(B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP)
 #define H_FOLLOW_LEFT_RIGHT_BOTTOM	(B_FOLLOW_LEFT_RIGHT|B_FOLLOW_BOTTOM)
 
+using std::vector;
 
+
 class IMPEXP_LIBHEKKEL HDlogView : public BView {
 public:
 		HDlogView(BRect frame, const char *name);

Modified: trunk/Sources/HLazyObject.cpp
===================================================================
--- trunk/Sources/HLazyObject.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HLazyObject.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -49,7 +49,7 @@
 BHandler *HLazyObject::ResolveSpecifier(BMessage *msg, int32 index,
 						BMessage *specifier, int32 form, const char *property)
 {
-	auto_ptr<HLazyObject> lets_commit_suicide(this);
+	std::auto_ptr<HLazyObject> lets_commit_suicide(this);
 	BHandler *result = NULL;
 
 //	if (index > 0)

Modified: trunk/Sources/HPreferences.h
===================================================================
--- trunk/Sources/HPreferences.h	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/HPreferences.h	2009-05-01 22:50:05 UTC (rev 562)
@@ -43,8 +43,10 @@
 
 #include <string>
 
-typedef map<string, char*> PrefMap;
+using std::string;
 
+typedef std::map<string, char*> PrefMap;
+
 class IMPEXP_LIBHEKKEL HPreferences {
 public:
 	HPreferences(const char *preffilename);

Modified: trunk/Sources/MTextAddOnImpl.cpp
===================================================================
--- trunk/Sources/MTextAddOnImpl.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/MTextAddOnImpl.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -87,8 +87,8 @@
 {
 	if (fText.LockLooper()) {
 		int32 a = fText.Anchor(), c = fText.Caret();
-		*start = min(a, c);
-		*end = max(a, c);
+		*start = std::min(a, c);
+		*end = std::max(a, c);
 		fText.UnlockLooper();
 	}
 } /* MTextAddOnImpl::GetSelection */

Modified: trunk/Sources/PAddOn.cpp
===================================================================
--- trunk/Sources/PAddOn.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/PAddOn.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -186,8 +186,8 @@
 void PEditText::GetSelection(int32* _start, int32* _end) const
 {
 	int32 start = fText.Anchor(), end = fText.Caret();
-	*_start = min(start, end);
-	*_end = max(start, end);
+	*_start = std::min(start, end);
+	*_end = std::max(start, end);
 }
 
 

Modified: trunk/Sources/PCmd.cpp
===================================================================
--- trunk/Sources/PCmd.cpp	2009-05-01 22:11:51 UTC (rev 561)
+++ trunk/Sources/PCmd.cpp	2009-05-01 22:50:05 UTC (rev 562)
@@ -88,7 +88,7 @@
 void PCutCmd::Do()
 {
 	fText->Select(fAnchor, fCaret, true, false);
-	fWhere = min(fAnchor, fCaret);
+	fWhere = std::min(fAnchor, fCaret);
 	fText->GetSelectedText(fSavedTxt);
 	fText->Cut(fAppend);
 	Update();
@@ -127,7 +127,7 @@
 void PClearCmd::Do()
 {
 	fText->Select(fAnchor, fCaret, true, false);
-	fWhere = min(fAnchor, fCaret);
+	fWhere = std::min(fAnchor, fCaret);
 	fText->GetSelectedText(fSavedTxt);
 	fText->Clear();
 	Update();
@@ -165,7 +165,7 @@
 void PPasteCmd::Do()
 {
 	fText->SetBlockSelect(false);
-	fWhere = min(fText->Anchor(), fText->Caret());
+	fWhere = std::min(fText->Anchor(), fText->Caret());
 	fText->GetSelectedText(fSavedTxt);
 
 	fText->Paste();
@@ -225,11 +225,11 @@
 
 void PTypingCmd::Do()
 {
-	fDeletedIndx = min(fText->Caret(), fText->Anchor());
+	fDeletedIndx = std::min(fText->Caret(), fText->Anchor());
 	fDeletedLen = abs(fText->Caret() - fText->Anchor());
 		
 	if (fDeletedIndx + fDeletedLen >= fText->TextBuffer().Size())
-		fDeletedLen = max(fText->TextBuffer().Size() - fDeletedIndx, 0);
+		fDeletedLen = std::max(fText->TextBuffer().Size() - fDeletedIndx, 0);
 		
 	fDeleted = (char *)malloc(fDeletedLen);
 		
@@ -247,8 +247,8 @@
 	{
 		int lf, lt;
 		
-		lf = fText->Offset2Line(min(fText->Anchor(), fText->Caret()));
-		lt = fText->Offset2Line(max(fText->Anchor(), fText->Caret()));
+		lf = fText->Offset2Line(std::min(fText->Anchor(), fText->Caret()));
+		lt = fText->Offset2Line(std::max(fText->Anchor(), fText->Caret()));
 		fText->TouchLines(lf, lt);
 	}
 
@@ -482,8 +482,8 @@
 	}
 
 	fText->Select(fAnchor, fCaret, true, false);
-	swap(anchor, fAnchor);
-	swap(caret, fCaret);
+	std::swap(anchor, fAnchor);
+	std::swap(caret, fCaret);
 	
 	Update();
 } /* PExtCmd::Undo */
@@ -508,8 +508,8 @@
 	}
 	
 	fText->Select(fAnchor, fCaret, true, false);
-	swap(anchor, fAnchor);
-	swap(caret, fCaret);
+	std::swap(anchor, fAnchor);
+	std::swap(caret, fCaret);
 	
 	Update();
 } /* PExtCmd::Redo */
@@ -734,7 +734,7 @@
 	fOldTextSize = abs(fText->Anchor() - fText->Caret());
 	if (fOldTextSize)
 	{
-		fAnchor = fCaret = min(fText->Anchor(), fText->Caret());
+		fAnchor = fCaret = std::min(fText->Anchor(), fText->Caret());
 		fOldText = (char *)malloc(fOldTextSize);
 		FailNil(fOldText);
 		fText->TextBuffer().Copy(fOldText, fAnchor, fOldTextSize);
@@ -920,8 +920,8 @@
 PShiftCmd::PShiftCmd(const char *name, PText *txt)
 	: PCmd(name, txt)
 {
-	fFrom = min(fText->Caret(), fText->Anchor());
-	fTo = max(fText->Caret(), fText->Anchor());
+	fFrom = std::min(fText->Caret(), fText->Anchor());
+	fTo = std::max(fText->Caret(), fText->Anchor());
 	int fromLine = fText->Offset2Line(fFrom);
 	int toLine = fText->Offset2Line(fTo);
 	// our first line may be a soft wrapped one: find the preceding hard wrap
@@ -971,7 +971,7 @@
 	}
 	// Get the first character of each hard line. If it's not a tab or a space,
 	// we mark it 0.
-	fFirstChars = new(nothrow) char[fLineCount];
+	fFirstChars = new(std::nothrow) char[fLineCount];
 	FailNil(fFirstChars);
 	fNoOp = true;
 	int hardIndex = 0;
@@ -1114,8 +1114,8 @@
 PTwiddleCmd::PTwiddleCmd(PText *txt)
 	: PCmd("Twiddle", txt)
 {
-	fFrom = min(fText->Caret(), fText->Anchor());
-	fTo = max(fText->Caret(), fText->Anchor());
+	fFrom = std::min(fText->Caret(), fText->Anchor());
+	fTo = std::max(fText->Caret(), fText->Anchor());
 	
 	if (fFrom == fTo)
 	{
@@ -1187,8 +1187,8 @@
 {
 	fComment = comment;
 	
-	fFrom = min(fText->Caret(), fText->Anchor());
-	fTo = max(fText->Caret(), fText->Anchor());
+	fFrom = std::min(fText->Caret(), fText->Anchor());
+	fTo = std::max(fText->Caret(), fText->Anchor());
 	
 	if (strlen(before) > 7 || strlen(after) > 7) THROW(("comment strings too long"));
 	
@@ -1224,8 +1224,8 @@
 	}
 	
 	fText->Select(fText->LineStart(lf), fText->LineStart(fText->Offset2Line(fTo)), true, false);
-	fFrom = min(fText->Caret(), fText->Anchor());
-	fTo = max(fText->Caret(), fText->Anchor());
+	fFrom = std::min(fText->Caret(), fText->Anchor());
+	fTo = std::max(fText->Caret(), fText->Anchor());
 
 	if (fText->LineCount() != c)	
 		Redraw();
@@ -1257,8 +1257,8 @@
 	}
 	
 	fText->Select(fText->LineStart(lf), fText->LineStart(fText->Offset2Line(fTo)), true, false);
-	fFrom = min(fText->Caret(), fText->Anchor());
-	fTo = max(fText->Caret(), fText->Anchor());
+	fFrom = std::min(fText->Caret(), fText->Anchor());
+	fTo = std::max(fText->Caret(), fText->Anchor());
 	
 	if (fText->LineCount() != c)	
 		Redraw();
@@ -1341,7 +1341,7 @@
 
 void PWrapCmd::Undo()
 {
-	int a = min(fAnchor, fCaret);
+	int a = std::min(fAnchor, fCaret);
 	fText->Delete(a, a + fNewLen);
 	if (fSavedText)
 	{
@@ -1388,7 +1388,7 @@
 
 void PUnwrapCmd::Undo()
 {

[... truncated: 368 lines follow ...]


From bonefish at mail.berlios.de  Sat May  2 01:00:22 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 01:00:22 +0200
Subject: [pe-commits] r563 - trunk/Extensions
Message-ID: <200905012300.n41N0M1u020456@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 01:00:20 +0200 (Sat, 02 May 2009)
New Revision: 563
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=563&view=rev

Modified:
   trunk/Extensions/BeBookFetch.cpp
   trunk/Extensions/HeaderHeader.cpp
Log:
gcc 4 fixes.


Modified: trunk/Extensions/BeBookFetch.cpp
===================================================================
--- trunk/Extensions/BeBookFetch.cpp	2009-05-01 22:50:05 UTC (rev 562)
+++ trunk/Extensions/BeBookFetch.cpp	2009-05-01 23:00:20 UTC (rev 563)
@@ -16,6 +16,9 @@
 
 #define kTrackerSig		"application/x-vnd.Be-TRAK"
 
+using std::vector;
+
+
 //------------------------------------------------------------------------------
 
 uint32

Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2009-05-01 22:50:05 UTC (rev 562)
+++ trunk/Extensions/HeaderHeader.cpp	2009-05-01 23:00:20 UTC (rev 563)
@@ -14,44 +14,44 @@
 
 static const char *sTrackerSig = "application/x-vnd.Be-TRAK";
 
-static const char *sAboutText = "HeaderHeader Extension for Pe
+static const char *sAboutText = "HeaderHeader Extension for Pe\n"
+"\n"
+"This extension prepends a chooseable licence header the current file, \n"
+"using the appropriate comment characters for the language used, \n"
+"and informations from a selected People file as author.\n"
+"\n"
+"First select your own People file from \"Set Author"B_UTF8_ELLIPSIS"\", \n"
+"then just select the header you want to use.\n"
+"You can also add your own templates in the settings folder. \n"
+"Use the \"Open Template Folder"B_UTF8_ELLIPSIS"\" menu, \n"
+"create text files there which contain the licence or informations you want. \n"
+"\n"
+"Keywords from the list below will be replaced by the corresponding value:\n"
+"%COMMS%		Start of comment block string\n"
+"%COMMC%		Comment block continuation string\n"
+"%COMML%		Comment block continuation string (blank if possible)\n"
+"%COMME%		End of comment block string\n"
+"%FILENAME%		Filename\n"
+"%FILENAMENOEXT%	Filename without extension\n"
+"%YEAR%		Current year\n"
+"%DATE%		Current date (YYYY-mm-dd)\n"
+"%TIME%		Current time (HH:MM:SS)\n"
+"(from the people file)\n"
+"%AUTHOR%		Your name\n"
+"%AUTHORMAIL%	Your email\n"
+"%COMPANY%		Company name\n"
+"%AUTHORURL%		Your url\n"
+;
 
-This extension prepends a chooseable licence header the current file, 
-using the appropriate comment characters for the language used, 
-and informations from a selected People file as author.
+static const char *sHaikuHeaderTemplate = "%COMMS%\n"
+"%COMMC% Copyright %YEAR%, Haiku, Inc.\n"
+"%COMMC% Distributed under the terms of the MIT License.\n"
+"%COMMC%\n"
+"%COMMC% Authors:\n"
+"%COMMC%		%AUTHOR% <%AUTHORMAIL%>\n"
+"%COMME%\n"
+;
 
-First select your own People file from \"Set Author"B_UTF8_ELLIPSIS"\", 
-then just select the header you want to use.
-You can also add your own templates in the settings folder. 
-Use the \"Open Template Folder"B_UTF8_ELLIPSIS"\" menu, 
-create text files there which contain the licence or informations you want. 
-
-Keywords from the list below will be replaced by the corresponding value:
-%COMMS%		Start of comment block string
-%COMMC%		Comment block continuation string
-%COMML%		Comment block continuation string (blank if possible)
-%COMME%		End of comment block string
-%FILENAME%		Filename
-%FILENAMENOEXT%	Filename without extension
-%YEAR%		Current year
-%DATE%		Current date (YYYY-mm-dd)
-%TIME%		Current time (HH:MM:SS)
-(from the people file)
-%AUTHOR%		Your name
-%AUTHORMAIL%	Your email
-%COMPANY%		Company name
-%AUTHORURL%		Your url
-";
-
-static const char *sHaikuHeaderTemplate = "%COMMS%
-%COMMC% Copyright %YEAR%, Haiku, Inc.
-%COMMC% Distributed under the terms of the MIT License.
-%COMMC%
-%COMMC% Authors:
-%COMMC%		%AUTHOR% <%AUTHORMAIL%>
-%COMME%
-";
-
 /*
 static const char *sHaikuAddMeHeaderMatch = \
 " * Authors:
@@ -61,11 +61,11 @@
 ";
 */
 
-static const char *sHaikuMeHeaderTemplate = "%COMMS%
-%COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.
-%COMMC% Distributed under the terms of the MIT License.
-%COMME%
-";
+static const char *sHaikuMeHeaderTemplate = "%COMMS%\n"
+"%COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.\n"
+"%COMMC% Distributed under the terms of the MIT License.\n"
+"%COMME%\n"
+;
 
 /*
 static const char *sHaikuMeAddMeHeaderTemplate = \
@@ -73,91 +73,91 @@
 ";
 */
 
-static const char *sHaikuMeRightsHeaderTemplate = "%COMMS%
-%COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>. All rights reserved.
-%COMMC% Distributed under the terms of the MIT License.
-%COMME%
-";
+static const char *sHaikuMeRightsHeaderTemplate = "%COMMS%\n"
+"%COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>. All rights reserved.\n"
+"%COMMC% Distributed under the terms of the MIT License.\n"
+"%COMME%\n"
+;
 
-static const char *sIdMeMITCreatedHeaderTemplate = \
-"%COMMS%	$Id: %FILENAME% $
-%COMML%
-%COMML%	Copyright %YEAR% %AUTHOR%
-%COMML%
-%COMML%	Distributed under the MIT License
-%COMML%
-%COMML%	Created: %DATE%
-%COMME%
-";
+static const char *sIdMeMITCreatedHeaderTemplate =
+"%COMMS%	$Id: %FILENAME% $\n"
+"%COMML%\n"
+"%COMML%	Copyright %YEAR% %AUTHOR%\n"
+"%COMML%\n"
+"%COMML%	Distributed under the MIT License\n"
+"%COMML%\n"
+"%COMML%	Created: %DATE%\n"
+"%COMME%\n"
+;
 
-static const char *sIdMeFullMITCreatedHeaderTemplate = \
-"%COMMS%	$Id: %FILENAME% $
-%COMML%	
-%COMML%	Copyright %YEAR%
-%COMML%	        %AUTHOR%  All rights reserved.
-%COMML%	
-%COMML%	Redistribution and use in source and binary forms, with or without
-%COMML%	modification, are permitted provided that the following conditions are met:
-%COMML%	1. Redistributions of source code must retain the above copyright notice,
-%COMML%	   this list of conditions and the following disclaimer.
-%COMML%	2. Redistributions in binary form must reproduce the above copyright notice,
-%COMML%	   this list of conditions and the following disclaimer in the documentation
-%COMML%	   and/or other materials provided with the distribution.
-%COMML%	3. All advertising materials mentioning features or use of this software
-%COMML%	   must display the following acknowledgement:
-%COMML%	   
-%COMML%	    This product includes software developed by %AUTHOR%.
-%COMML%	
-%COMML%	4. The name of %AUTHOR% may not be used to endorse or
-%COMML%	   promote products derived from this software without specific prior
-%COMML%	   written permission.
-%COMML%	
-%COMML%	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
-%COMML%	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-%COMML%	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
-%COMML%	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-%COMML%	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-%COMML%	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-%COMML%	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-%COMML%	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-%COMML%	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-%COMML%	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
-%COMML%
-%COMML%	Created: %DATE% %TIME%
-%COMME%
-";
+static const char *sIdMeFullMITCreatedHeaderTemplate =
+"%COMMS%	$Id: %FILENAME% $\n"
+"%COMML%	\n"
+"%COMML%	Copyright %YEAR%\n"
+"%COMML%	        %AUTHOR%  All rights reserved.\n"
+"%COMML%	\n"
+"%COMML%	Redistribution and use in source and binary forms, with or without\n"
+"%COMML%	modification, are permitted provided that the following conditions are met:\n"
+"%COMML%	1. Redistributions of source code must retain the above copyright notice,\n"
+"%COMML%	   this list of conditions and the following disclaimer.\n"
+"%COMML%	2. Redistributions in binary form must reproduce the above copyright notice,\n"
+"%COMML%	   this list of conditions and the following disclaimer in the documentation\n"
+"%COMML%	   and/or other materials provided with the distribution.\n"
+"%COMML%	3. All advertising materials mentioning features or use of this software\n"
+"%COMML%	   must display the following acknowledgement:\n"
+"%COMML%	   \n"
+"%COMML%	    This product includes software developed by %AUTHOR%.\n"
+"%COMML%	\n"
+"%COMML%	4. The name of %AUTHOR% may not be used to endorse or\n"
+"%COMML%	   promote products derived from this software without specific prior\n"
+"%COMML%	   written permission.\n"
+"%COMML%	\n"
+"%COMML%	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n"
+"%COMML%	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n"
+"%COMML%	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n"
+"%COMML%	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n"
+"%COMML%	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n"
+"%COMML%	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n"
+"%COMML%	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n"
+"%COMML%	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n"
+"%COMML%	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n"
+"%COMML%	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	\n"
+"%COMML%\n"
+"%COMML%	Created: %DATE% %TIME%\n"
+"%COMME%\n"
+;
 
-static const char *sIdMeFullMITRevisedCreatedHeaderTemplate = \
-"%COMMS%	$Id: %FILENAME% $
-%COMML%	
-%COMML%	Copyright %YEAR%
-%COMML%	        %AUTHOR%  All rights reserved.
-%COMML%	
-%COMML%	Redistribution and use in source and binary forms, with or without
-%COMML%	modification, are permitted provided that the following conditions are met:
-%COMML%	1. Redistributions of source code must retain the above copyright notice,
-%COMML%	   this list of conditions and the following disclaimer.
-%COMML%	2. Redistributions in binary form must reproduce the above copyright notice,
-%COMML%	   this list of conditions and the following disclaimer in the documentation
-%COMML%	   and/or other materials provided with the distribution.
-%COMML%	4. The name of %AUTHOR% may not be used to endorse or
-%COMML%	   promote products derived from this software without specific prior
-%COMML%	   written permission.
-%COMML%	
-%COMML%	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
-%COMML%	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-%COMML%	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
-%COMML%	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-%COMML%	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-%COMML%	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-%COMML%	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-%COMML%	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-%COMML%	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-%COMML%	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
-%COMML%
-%COMML%	Created: %DATE% %TIME%
-%COMME%
-";
+static const char *sIdMeFullMITRevisedCreatedHeaderTemplate =
+"%COMMS%	$Id: %FILENAME% $\n"
+"%COMML%	\n"
+"%COMML%	Copyright %YEAR%\n"
+"%COMML%	        %AUTHOR%  All rights reserved.\n"
+"%COMML%	\n"
+"%COMML%	Redistribution and use in source and binary forms, with or without\n"
+"%COMML%	modification, are permitted provided that the following conditions are met:\n"
+"%COMML%	1. Redistributions of source code must retain the above copyright notice,\n"
+"%COMML%	   this list of conditions and the following disclaimer.\n"
+"%COMML%	2. Redistributions in binary form must reproduce the above copyright notice,\n"
+"%COMML%	   this list of conditions and the following disclaimer in the documentation\n"
+"%COMML%	   and/or other materials provided with the distribution.\n"
+"%COMML%	4. The name of %AUTHOR% may not be used to endorse or\n"
+"%COMML%	   promote products derived from this software without specific prior\n"
+"%COMML%	   written permission.\n"
+"%COMML%	\n"
+"%COMML%	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n"
+"%COMML%	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n"
+"%COMML%	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n"
+"%COMML%	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n"
+"%COMML%	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n"
+"%COMML%	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n"
+"%COMML%	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n"
+"%COMML%	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n"
+"%COMML%	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n"
+"%COMML%	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	\n"
+"%COMML%\n"
+"%COMML%	Created: %DATE% %TIME%\n"
+"%COMME%\n"
+;
 
 
 //------------------------------------------------------------------------------



From bonefish at mail.berlios.de  Sat May  2 01:07:26 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 01:07:26 +0200
Subject: [pe-commits] r564 - trunk/Languages/Sources
Message-ID: <200905012307.n41N7QPZ027220@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 01:07:24 +0200 (Sat, 02 May 2009)
New Revision: 564
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=564&view=rev

Modified:
   trunk/Languages/Sources/Antlr_Popup.cpp
   trunk/Languages/Sources/Cpp_Popup.cpp
   trunk/Languages/Sources/D_Popup.cpp
   trunk/Languages/Sources/HtmlCssJsPhp_Language.cpp
   trunk/Languages/Sources/HtmlCssJsPhp_Popup.cpp
   trunk/Languages/Sources/HtmlJs_Popup.cpp
   trunk/Languages/Sources/Html_Popup.cpp
   trunk/Languages/Sources/Java_Popup.l
   trunk/Languages/Sources/Lout_Popup.l
   trunk/Languages/Sources/Mathematica_Popup.l
   trunk/Languages/Sources/Oberon_Popup.l
   trunk/Languages/Sources/Perl_Popup.l
   trunk/Languages/Sources/Python_Popup.l
   trunk/Languages/Sources/Rez_Popup.l
Log:
gcc 4 fixes.


Modified: trunk/Languages/Sources/Antlr_Popup.cpp
===================================================================
--- trunk/Languages/Sources/Antlr_Popup.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Antlr_Popup.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -307,7 +307,7 @@
 		*name = 0;
 		// add it
 		char match[256];
-		long l = min((long)255, text - start);
+		long l = std::min((long)255, text - start);
 		
 		strncpy(match, start, l);
 		match[l] = 0;
@@ -339,7 +339,7 @@
 		*name = 0;
 		// add it
 		char match[256];
-		long l = min((long)255, text - start);
+		long l = std::min((long)255, text - start);
 		
 		strncpy(match, start, l);
 		match[l] = 0;
@@ -385,7 +385,7 @@
 			if (*text == '{' && proxy.Types())
 			{
 				char match[256];
-				long l = min((long)255, text - start);
+				long l = std::min((long)255, text - start);
 				
 				strncpy(match, start, l);
 				match[l] = 0;
@@ -531,7 +531,7 @@
 	if (*text == '(')
 	{
 		char match[256];
-		long l = min((long)255, text - start);
+		long l = std::min((long)255, text - start);
 		
 		strncpy(match, start, l);
 		match[l] = 0;

Modified: trunk/Languages/Sources/Cpp_Popup.cpp
===================================================================
--- trunk/Languages/Sources/Cpp_Popup.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Cpp_Popup.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -294,7 +294,7 @@
 		if (*text == '{' && proxy.Types())
 		{
 			char match[256];
-			long l = min((long)255, text - start);
+			long l = std::min((long)255, text - start);
 			
 			strncpy(match, start, l);
 			match[l] = 0;
@@ -573,7 +573,7 @@
 			if (*text == '{')
 			{
 				char match[256];
-				long l = min((long)255, text - start);
+				long l = std::min((long)255, text - start);
 				
 				strncpy(match, start, l);
 				match[l] = 0;
@@ -699,7 +699,7 @@
 	if (*text == '(')
 	{
 		char match[256];
-		long l = min((long)255, text - start);
+		long l = std::min((long)255, text - start);
 		
 		strncpy(match, start, l);
 		match[l] = 0;

Modified: trunk/Languages/Sources/D_Popup.cpp
===================================================================
--- trunk/Languages/Sources/D_Popup.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/D_Popup.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -304,7 +304,7 @@
 
 		if (*text == '{' && proxy.Types()) {
 			char match[256];
-			long l = min((long)255, text - start);
+			long l = std::min((long)255, text - start);
 			
 			strncpy(match, start, l);
 			match[l] = 0;
@@ -555,7 +555,7 @@
 
 			if (*text == '{') {
 				char match[256];
-				long l = min((long) 255, text - start);
+				long l = std::min((long) 255, text - start);
 
 				strncpy(match, start, l);
 				match[l] = 0;
@@ -597,7 +597,7 @@
 
 	if (*text == '(') {
 		char match[256];
-		long l = min((long) 255, text - start);
+		long l = std::min((long) 255, text - start);
 
 		strncpy(match, start, l);
 		match[l] = 0;

Modified: trunk/Languages/Sources/HtmlCssJsPhp_Language.cpp
===================================================================
--- trunk/Languages/Sources/HtmlCssJsPhp_Language.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/HtmlCssJsPhp_Language.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -1567,7 +1567,7 @@
 		const char *et(txt + end);
 		const char *st(txt + langStart);
 
-		stack<int> bls, sbls, pls;
+		std::stack<int> bls, sbls, pls;
 
 		while (*txt && txt < et)
 		{
@@ -1584,7 +1584,7 @@
 		}
 
 		char ec = 0, oc = 0;
-		stack<int> *s = 0;
+		std::stack<int> *s = 0;
 
 		int db, dsb, dp;
 

Modified: trunk/Languages/Sources/HtmlCssJsPhp_Popup.cpp
===================================================================
--- trunk/Languages/Sources/HtmlCssJsPhp_Popup.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/HtmlCssJsPhp_Popup.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -39,6 +39,7 @@
 */
 #include <map>
 #include <string>
+#include <vector>
 #include "CLanguageAddOn.h"
 
 const long kMaxNameSize = 256;
@@ -63,7 +64,7 @@
 	PopupMenu (BString &lab, BString &txt, const char * pos, bool ita=false)
 		: label(lab), text(txt), position(pos), italic(ita) {}
 };
-typedef vector<PopupMenu> PopupList;
+typedef std::vector<PopupMenu> PopupList;
 
 void add_to_popup(const char* name, PopupList &pul, CLanguageProxy& proxy);
 bool isident(char ch);
@@ -456,7 +457,7 @@
 
 const char *PhpScript(const char *txt, PopupList &lstPhpFunctions, PopupList &lstPhpClasses, bool sorted)
 {
-	map <int,int,int> headings;
+	std::map <int,int,int> headings;
 	BString class_name;
 	while (*txt)
 	{

Modified: trunk/Languages/Sources/HtmlJs_Popup.cpp
===================================================================
--- trunk/Languages/Sources/HtmlJs_Popup.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/HtmlJs_Popup.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -111,7 +111,7 @@
 			if (*txt == 0)
 				break;
 			
-			int l = min((long)PATH_MAX - 1, txt - file - 1);
+			int l = std::min((long)PATH_MAX - 1, txt - file - 1);
 			strncpy(name, file, l);
 			name[l] = 0;
 			
@@ -138,7 +138,7 @@
 				break;
 			
 			char *p = name + kMaxNameSize;
-			int l = min(kMaxNameSize - 1, txt - anchor - 1);
+			int l = std::min(kMaxNameSize - 1, txt - anchor - 1);
 			strncpy(name, anchor, l);
 			name[l] = 0;
 			
@@ -170,7 +170,7 @@
 	txt = skip(txt + 1, '<');
 	
 	char name[kMaxNameSize];
-	int l = min(txt - hName - 1, kMaxNameSize - 1);
+	int l = std::min(txt - hName - 1, kMaxNameSize - 1);
 	int offset = hName - ao.Text();
 	
 	strncpy(name, hName, l);
@@ -246,7 +246,7 @@
 					
 					int offset = txt - ao.Text();
 					
-					string name, label;
+					std::string name, label;
 					
 					while (isalnum(*txt))
 						name += *txt++;

Modified: trunk/Languages/Sources/Html_Popup.cpp
===================================================================
--- trunk/Languages/Sources/Html_Popup.cpp	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Html_Popup.cpp	2009-05-01 23:07:24 UTC (rev 564)
@@ -111,7 +111,7 @@
 			if (*txt == 0)
 				break;
 			
-			int l = min((long)PATH_MAX - 1, txt - file - 1);
+			int l = std::min((long)PATH_MAX - 1, txt - file - 1);
 			strncpy(name, file, l);
 			name[l] = 0;
 			
@@ -138,7 +138,7 @@
 				break;
 			
 			char *p = name + kMaxNameSize;
-			int l = min(kMaxNameSize - 1, txt - anchor - 1);
+			int l = std::min(kMaxNameSize - 1, txt - anchor - 1);
 			strncpy(name, anchor, l);
 			name[l] = 0;
 			
@@ -170,7 +170,7 @@
 	txt = skip(txt + 1, '<');
 	
 	char name[kMaxNameSize];
-	int l = min(txt - hName - 1, kMaxNameSize - 1);
+	int l = std::min(txt - hName - 1, kMaxNameSize - 1);
 	int offset = hName - ao.Text();
 	
 	strncpy(name, hName, l);
@@ -246,7 +246,7 @@
 					
 					int offset = txt - ao.Text();
 					
-					string name, label;
+					std::string name, label;
 					
 					while (isalnum(*txt))
 						name += *txt++;

Modified: trunk/Languages/Sources/Java_Popup.l
===================================================================
--- trunk/Languages/Sources/Java_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Java_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -132,7 +132,7 @@
 			space++;
 		}
 		
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 		gIndx += 2;
 
 		while (max--)
@@ -152,7 +152,7 @@
 		}
 		while (gIndx < gBufSize && c != '\n');
 		
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 
 		while (max--)
 			*tok++ = ' ';

Modified: trunk/Languages/Sources/Lout_Popup.l
===================================================================
--- trunk/Languages/Sources/Lout_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Lout_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -136,7 +136,7 @@
 		}
 		while (gIndx < gBufSize && c != '\n');
 
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 
 		while (max--)
 			*tok++ = ' ';

Modified: trunk/Languages/Sources/Mathematica_Popup.l
===================================================================
--- trunk/Languages/Sources/Mathematica_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Mathematica_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -74,7 +74,7 @@
 "IMPORT"													BEGIN(import);
 \"																string_caller = INITIAL; BEGIN(string); inString = true;
 .
-<block>"END"{ws}{ident}								BEGIN(INITIAL); nesting = max(--nesting, 0);
+<block>"END"{ws}{ident}								BEGIN(INITIAL); nesting = std::max(--nesting, 0);
 <block>\"													string_caller = block; BEGIN(string);
 <block>{ident}
 <block>.
@@ -122,7 +122,7 @@
 			space++;
 		}
 		
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 		gIndx += 2;
 
 		while (max--)

Modified: trunk/Languages/Sources/Oberon_Popup.l
===================================================================
--- trunk/Languages/Sources/Oberon_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Oberon_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -74,7 +74,7 @@
 "IMPORT"													BEGIN(import);
 \"																string_caller = INITIAL; BEGIN(string); inString = true;
 .
-<block>"END"{ws}{ident}								BEGIN(INITIAL); nesting = max(--nesting, 0);
+<block>"END"{ws}{ident}								BEGIN(INITIAL); nesting = std::max(--nesting, 0);
 <block>\"													string_caller = block; BEGIN(string);
 <block>{ident}
 <block>.
@@ -122,7 +122,7 @@
 			space++;
 		}
 		
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 		gIndx += 2;
 
 		while (max--)

Modified: trunk/Languages/Sources/Perl_Popup.l
===================================================================
--- trunk/Languages/Sources/Perl_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Perl_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -121,7 +121,7 @@
 		}
 		while (gIndx < gBufSize && c != '\n');
 
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 
 		while (max--)
 			*tok++ = ' ';

Modified: trunk/Languages/Sources/Python_Popup.l
===================================================================
--- trunk/Languages/Sources/Python_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Python_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -121,7 +121,7 @@
 		}
 		while (gIndx < gBufSize && c != '\n');
 
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 
 		while (max--)
 			*tok++ = ' ';

Modified: trunk/Languages/Sources/Rez_Popup.l
===================================================================
--- trunk/Languages/Sources/Rez_Popup.l	2009-05-01 23:00:20 UTC (rev 563)
+++ trunk/Languages/Sources/Rez_Popup.l	2009-05-01 23:07:24 UTC (rev 564)
@@ -126,7 +126,7 @@
 			space++;
 		}
 		
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 		gIndx += 2;
 
 		while (max--)
@@ -146,7 +146,7 @@
 		}
 		while (gIndx < gBufSize && c != '\n');
 		
-		result = max = min(max, space);
+		result = max = std::min(max, space);
 
 		while (max--)
 			*tok++ = ' ';



From bonefish at mail.berlios.de  Sat May  2 01:22:02 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 01:22:02 +0200
Subject: [pe-commits] r565 - trunk/lpe
Message-ID: <200905012322.n41NM2G8012045@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 01:22:01 +0200 (Sat, 02 May 2009)
New Revision: 565
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=565&view=rev

Modified:
   trunk/lpe/lpe.cpp
Log:
gcc 4 fixes.


Modified: trunk/lpe/lpe.cpp
===================================================================
--- trunk/lpe/lpe.cpp	2009-05-01 23:07:24 UTC (rev 564)
+++ trunk/lpe/lpe.cpp	2009-05-01 23:22:01 UTC (rev 565)
@@ -34,16 +34,18 @@
 */
 
 #include <vector>
-#include <cstdio>
-#include <cstdarg>
 
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
 #include <Message.h>
 #include <Roster.h>
 #include <String.h>
 
 const long msg_CommandLineOpen = 'Cmdl';
 
-static vector<int> threads;
+static std::vector<int> threads;
 
 void DoError(const char *e, ...);
 void Usage();
@@ -178,7 +180,7 @@
 		}
 	}
 	
-	vector<int>::iterator ti;
+	std::vector<int>::iterator ti;
 	
 	for (ti = threads.begin(); ti != threads.end(); ti++)
 	{



From bonefish at mail.berlios.de  Sat May  2 01:25:04 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 01:25:04 +0200
Subject: [pe-commits] r566 - trunk/lpe
Message-ID: <200905012325.n41NP4ub015436@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 01:25:03 +0200 (Sat, 02 May 2009)
New Revision: 566
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=566&view=rev

Modified:
   trunk/lpe/lpe.cpp
Log:
Fixed the case that Pe isn't running yet. If one opened another window and
closed the first one, lpe wouldn't recognize that:
* The name of the open dialog thread slightly differed.
* Also skip the find window.


Modified: trunk/lpe/lpe.cpp
===================================================================
--- trunk/lpe/lpe.cpp	2009-05-01 23:22:01 UTC (rev 565)
+++ trunk/lpe/lpe.cpp	2009-05-01 23:25:03 UTC (rev 566)
@@ -100,7 +100,8 @@
 			while ((err = get_next_thread_info(team, &cookie, &tinfo)) == B_OK)
 			{
 				if (!strncmp("w>", tinfo.name, 2) 
-					&& strcmp("w>pe: Open", tinfo.name)
+					&& strcmp("w>Pe: Open", tinfo.name)
+					&& strcmp("w>Find", tinfo.name)
 					&& strcmp("w>/boot/home/config/settings/pe", tinfo.name))
 				{
 					threads.push_back(tinfo.thread);



From bonefish at mail.berlios.de  Sat May  2 13:23:11 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 13:23:11 +0200
Subject: [pe-commits] r567 - trunk/build
Message-ID: <200905021123.n42BNB5V029746@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 13:23:10 +0200 (Sat, 02 May 2009)
New Revision: 567
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=567&view=rev

Modified:
   trunk/build/BuildSettings
Log:
Removed -Wmissing-prototypes from C++FLAGS. It is invalid for C++.


Modified: trunk/build/BuildSettings
===================================================================
--- trunk/build/BuildSettings	2009-05-01 23:25:03 UTC (rev 566)
+++ trunk/build/BuildSettings	2009-05-02 11:23:10 UTC (rev 567)
@@ -90,7 +90,7 @@
 		if $(OSPLAT) = X86 {
 			CCFLAGS += -Wall -Wno-multichar -Wmissing-prototypes ;
 			CCFLAGS += -Wpointer-arith -Wcast-align -Wsign-compare ;
-			C++FLAGS += -Wall -Wno-multichar -Wmissing-prototypes ;
+			C++FLAGS += -Wall -Wno-multichar ;
 			C++FLAGS += -Wno-ctor-dtor-privacy -Woverloaded-virtual ;
 			C++FLAGS += -Wpointer-arith -Wcast-align -Wsign-compare ;
 			C++FLAGS += -Wno-unknown-pragmas ;



From bonefish at mail.berlios.de  Sat May  2 13:30:14 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 13:30:14 +0200
Subject: [pe-commits] r568 - in trunk: . build
Message-ID: <200905021130.n42BUED6006184@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 13:30:12 +0200 (Sat, 02 May 2009)
New Revision: 568
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=568&view=rev

Modified:
   trunk/Jamrules
   trunk/build/MainBuildRules
   trunk/build/OverriddenJamRules
Log:
* Generalized the stdc++ lib detection. In case of Haiku we assume the absence
  of libstdc++.r4.so means we have a gcc 4 platform.
* Use the correct include path flags for gcc 4. That gets rid of the those
  annoying warnings.


Modified: trunk/Jamrules
===================================================================
--- trunk/Jamrules	2009-05-02 11:23:10 UTC (rev 567)
+++ trunk/Jamrules	2009-05-02 11:30:12 UTC (rev 568)
@@ -4,6 +4,19 @@
 GENERATED_DIR		= [ FDirName $(TOP) generated ] ;
 DISTRO_DIR			= [ FDirName $(TOP) generated distro ] ;
 
+# First find out which gcc version the platform uses.
+IS_GCC_4_PLATFORM = ;
+if $(OS) = HAIKU {
+	# Only Haiku might use gcc 4. We use the existence of a libstdc++.r4.so in
+	# /boot/develop/lib/x86 to judge whether this is a BeOS compatible and thus
+	# gcc 2 platform. This is not entirely correct, but should be good enough
+	# for the time being.
+	local hasLibStdC++.R4 = [ Glob /boot/develop/lib/x86 : libstdc++.r4.so ] ;
+	if ! $(hasLibStdC++.R4) {
+		IS_GCC_4_PLATFORM = 1 ;
+	}
+}
+
 include [ FDirName $(BUILD_DIR) HelperRules ] ;
 include [ FDirName $(BUILD_DIR) ConfigRules ] ;
 include [ FDirName $(BUILD_DIR) OverriddenJamRules ] ;

Modified: trunk/build/MainBuildRules
===================================================================
--- trunk/build/MainBuildRules	2009-05-02 11:23:10 UTC (rev 567)
+++ trunk/build/MainBuildRules	2009-05-02 11:30:12 UTC (rev 568)
@@ -209,7 +209,7 @@
 	local rezFile = $(2) ;
 	local flags = $(3) ;
 	
-	REZHDRS on $(output) = [ on $(output) FIncludes $(HDRS) ] ;
+	REZHDRS on $(output) = [ on $(output) return "-I"$(HDRS) ] ;
 	REZFLAGS on $(output) = [ on $(output) return $(REZFLAGS) ] $(flags) ;
 	Depends $(output) : rez $(rezFile) ;
 	Rez1 $(output) : rez $(rezFile) ;
@@ -413,26 +413,29 @@
 	}
 }
 
-
 # FSysIncludes <dirs> ;
 #
 # Counterpart of FIncludes for system include search paths.
 #
-if $(OSPLAT) = X86 {
+if $(IS_GCC_4_PLATFORM) {
 	rule FSysIncludes { return -I$(<) ; }
 } else {
-	rule FSysIncludes { return "-i "$(<) ; }
+	if $(OSPLAT) = X86 {
+		rule FSysIncludes { return -I$(<) ; }
+	} else {
+		rule FSysIncludes { return "-i "$(<) ; }
+	}
 }
 
 # Variable referring to the STL.
-if $(OSPLAT) = X86 {
-	local hasLibStdC++.R4 = [ Glob /boot/develop/lib/x86 : libstdc++.r4.so ] ;
-	if $(hasLibStdC++.R4) {
+if $(IS_GCC_4_PLATFORM) {
+	# gcc 4 Haiku
+	STDC++LIB = stdc++ ;
+} else {
+	# BeOS or BeOS compatible Haiku
+	if $(OSPLAT) = X86 {
 		STDC++LIB = stdc++.r4 ;
 	} else {
-		# supposedly a gcc 4 Haiku
-		STDC++LIB = stdc++ ;
+		STDC++LIB = mslcpp_4_0 ;
 	}
-} else {
-	STDC++LIB = mslcpp_4_0 ;
 }

Modified: trunk/build/OverriddenJamRules
===================================================================
--- trunk/build/OverriddenJamRules	2009-05-02 11:23:10 UTC (rev 567)
+++ trunk/build/OverriddenJamRules	2009-05-02 11:30:12 UTC (rev 568)
@@ -41,12 +41,24 @@
 # Changes to rules for sake of discrimination between system and non-system
 # headers.
 
-if $(OSPLAT) = X86 {
-	HDRS_INCLUDES_SEPARATOR = -I- ;
+if $(IS_GCC_4_PLATFORM) {
+	HDRS_INCLUDES_SEPARATOR = ;
 } else {
-	HDRS_INCLUDES_SEPARATOR = -i- ;
+	if $(OSPLAT) = X86 {
+		HDRS_INCLUDES_SEPARATOR = -I- ;
+	} else {
+		HDRS_INCLUDES_SEPARATOR = -i- ;
+	}
 }
 
+# FIncludes <dirs> ;
+#
+# Overridden for gcc 4 platforms to use the correct
+#
+if $(IS_GCC_4_PLATFORM) {
+	rule FIncludes { return "-iquote "$(1) ; }
+}
+
 rule Cc
 {
 	Depends $(<) : $(>) ;



From bonefish at mail.berlios.de  Sat May  2 23:08:40 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 2 May 2009 23:08:40 +0200
Subject: [pe-commits] r569 - trunk/Sources
Message-ID: <200905022108.n42L8eMV027383@sheep.berlios.de>

Author: bonefish
Date: 2009-05-02 23:08:40 +0200 (Sat, 02 May 2009)
New Revision: 569
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=569&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
Incremental search: Don't search a match only to the end of the document, but
wrap around. I, at least, found that the previous behavior made incremental
search quite unusable.


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2009-05-02 11:30:12 UTC (rev 568)
+++ trunk/Sources/PText.cpp	2009-05-02 21:08:40 UTC (rev 569)
@@ -4390,7 +4390,7 @@
 	{
 		int offset = fIncCaret;
 
-		if (FindNext(fIncPat, offset, ignCase, false, fIncSearch == 2, false, false, true))
+		if (FindNext(fIncPat, offset, ignCase, true, fIncSearch == 2, false, false, true))
 		{
 			BMessage msg(msg_EnterSearchString);
 			msg.AddString("string", fIncPat);



From bonefish at mail.berlios.de  Sun May  3 17:07:46 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sun, 3 May 2009 17:07:46 +0200
Subject: [pe-commits] r570 - in trunk: Resources Sources
Message-ID: <200905031507.n43F7kvQ013555@sheep.berlios.de>

Author: bonefish
Date: 2009-05-03 17:07:44 +0200 (Sun, 03 May 2009)
New Revision: 570
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=570&view=rev

Modified:
   trunk/Resources/Dialog-Preferences.r
   trunk/Sources/CDoc.cpp
   trunk/Sources/CDoc.h
   trunk/Sources/CDocIO.cpp
   trunk/Sources/CPrefsDialog.cpp
   trunk/Sources/PCmd.cpp
   trunk/Sources/PCmd.h
   trunk/Sources/PDoc.cpp
   trunk/Sources/PDoc.h
   trunk/Sources/PrefControls.h
   trunk/Sources/Prefs.h
Log:
* Introduced hook CDoc::DoSavePreparations() which is invoked by the CDocIOs
  before getting the text for saving it.
* Introduced PCmd class PDiscardTrailingSpaceCmd which removes trailing white
  space (currently only spaces and tabs) from lines.
* Added a prefs option to remove trailing white space when saving a file.
* This is implemented in PDoc::DoSavePreparations() by executing a
  PDiscardTrailingSpaceCmd. The disadvantage of this solution is, that it
  clears the redo stack. I couldn't think of any other solution that wouldn't
  have any disadvantages, though.


Modified: trunk/Resources/Dialog-Preferences.r
===================================================================
--- trunk/Resources/Dialog-Preferences.r	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Resources/Dialog-Preferences.r	2009-05-03 15:07:44 UTC (rev 570)
@@ -165,8 +165,9 @@
 			TabSheet			{ "Files", "Options for files on disk"														},
 				Caption			{{   0,   0, 120,  16 }, "sv",							"When saving a file"				},
 
-				CheckBox		{{ 140,  20, 290,  36 }, pnm_Fil_X_MakeBackup,			"Make backup (filename~)"			},
-				CheckBox		{{ 140,  40, 290,  56 }, pnm_Fil_X_EndWithNewline,		"End with newline"					},
+				CheckBox		{{ 140,   0, 290,  16 }, pnm_Fil_X_MakeBackup,			"Make backup (filename~)"			},
+				CheckBox		{{ 140,  20, 290,  36 }, pnm_Fil_X_EndWithNewline,		"End with newline"					},
+				CheckBox		{{ 140,  40, 290,  56 }, pnm_Fil_X_DiscardTrailingSpace,"Discard trailing space"			},
 
 				Line			{{   0,  63, 290,  64 }},
 

Modified: trunk/Sources/CDoc.cpp
===================================================================
--- trunk/Sources/CDoc.cpp	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/CDoc.cpp	2009-05-03 15:07:44 UTC (rev 570)
@@ -417,6 +417,10 @@
 {
 }
 
+void CDoc::DoSavePreparations()
+{
+}
+
 void CDoc::HighlightErrorPos(int errorPos)
 {
 }

Modified: trunk/Sources/CDoc.h
===================================================================
--- trunk/Sources/CDoc.h	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/CDoc.h	2009-05-03 15:07:44 UTC (rev 570)
@@ -126,6 +126,7 @@
 	// hook methods
 	virtual void NameChanged();
 	virtual void HasBeenSaved();
+	virtual	void DoSavePreparations();
 
 protected:
 

Modified: trunk/Sources/CDocIO.cpp
===================================================================
--- trunk/Sources/CDocIO.cpp	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/CDocIO.cpp	2009-05-03 15:07:44 UTC (rev 570)
@@ -433,6 +433,7 @@
 
 	try
 	{
+		fDoc->DoSavePreparations();
 		BMessage settingsMsg;
 		fDoc->CollectSettings(settingsMsg);
 		BString docText;
@@ -768,6 +769,7 @@
 {
 	try
 	{
+		fDoc->DoSavePreparations();
 		BMessage settingsMsg;
 		fDoc->CollectSettings(settingsMsg);
 		BString docText;

Modified: trunk/Sources/CPrefsDialog.cpp
===================================================================
--- trunk/Sources/CPrefsDialog.cpp	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/CPrefsDialog.cpp	2009-05-03 15:07:44 UTC (rev 570)
@@ -353,6 +353,7 @@
 	CntrlGetChkbx(pnm_Inc_X_BeIncludes,				prf_I_BeIncludes,		 		dummy);
 	CntrlGetChkbx(pnm_Fil_X_MakeBackup,				prf_I_MakeBackup, 				dummy);
 	CntrlGetChkbx(pnm_Fil_X_EndWithNewline,			prf_I_EndWithNewline, 			dummy);
+	CntrlGetChkbx(pnm_Fil_X_DiscardTrailingSpace,	prf_I_DiscardTrailingSpace, 	dummy);
 	CntrlGetChkbx(pnm_Fil_X_VerifyOpenFiles,		prf_I_VerifyOpenFiles, 			dummy);
 	CntrlGetChkbx(pnm_Con_X_ShowBeIdeMenu,			prf_I_ShowBeIdeMenu,			dummy);
 	CntrlGetChkbx(pnm_Con_X_LoadBeIdeExt,			prf_I_LoadBeIdeExt,				dummy);
@@ -547,6 +548,7 @@
 	CntrlSetChkbx(pnm_Inc_X_BeIncludes,				prf_I_BeIncludes,			true);
 	CntrlSetChkbx(pnm_Fil_X_MakeBackup,				prf_I_MakeBackup,			false);
 	CntrlSetChkbx(pnm_Fil_X_EndWithNewline,			prf_I_EndWithNewline,		true);
+	CntrlSetChkbx(pnm_Fil_X_DiscardTrailingSpace,	prf_I_DiscardTrailingSpace, false);
 	CntrlSetChkbx(pnm_Fil_X_VerifyOpenFiles,		prf_I_VerifyOpenFiles,		true);
 	CntrlSetChkbx(pnm_Con_X_ShowBeIdeMenu,			prf_I_ShowBeIdeMenu,		true);
 	CntrlSetChkbx(pnm_Con_X_LoadBeIdeExt,			prf_I_LoadBeIdeExt,			true);

Modified: trunk/Sources/PCmd.cpp
===================================================================
--- trunk/Sources/PCmd.cpp	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/PCmd.cpp	2009-05-03 15:07:44 UTC (rev 570)
@@ -1641,3 +1641,133 @@
 	fText->Doc()->SetEncoding(fSourceEncoding);
 } /* PEncodingCmd::Undo */
 
+
+#pragma mark --- Discard Trailing Space Command ---
+
+PDiscardTrailingSpaceCmd::PDiscardTrailingSpaceCmd(PText *txt)
+	: PCmd("Discard Trailing Space", txt)
+{
+	fAnchor = txt->Anchor();
+	fCaret = txt->Caret();
+
+	std::vector<int> spaceOffsets;
+
+	// analyze the lines
+	int spacesToRemove = 0;
+	const char* text = txt->Text();
+	int textSize = txt->Size();
+	int offset = 0;
+	while (offset < textSize)
+	{
+		const char* foundNL = strchr(text + offset, '\n');
+		offset = foundNL != NULL ? foundNL - text : textSize;
+		int spaceStart = offset;
+		while (spaceStart > 0
+			&& (text[spaceStart - 1] == ' ' || text[spaceStart - 1] == '\t'))
+		{
+			spaceStart--;
+		}
+
+		if (spaceStart < offset)
+		{
+			int spaceCount = offset - spaceStart;
+			spaceOffsets.push_back(spaceStart);
+			spaceOffsets.push_back(spaceCount);
+
+			spacesToRemove += spaceCount;
+		}
+
+		offset++;
+	}
+
+	fLineCount = spaceOffsets.size() / 2;
+	fTotalSpaceCount = spacesToRemove;
+	if (fLineCount == 0)
+	{
+		fSpaceOffsets = NULL;
+		fSpaces = NULL;
+		return;
+	}
+
+	fSpaceOffsets = (int*)malloc(2 * fLineCount * sizeof(int));
+	fSpaces = (char*)malloc(spacesToRemove);
+
+	try
+	{
+		FailNil(fSpaceOffsets);
+		FailNil(fSpaces);
+	}
+	catch (...)
+	{
+		free(fSpaceOffsets);
+		free(fSpaces);
+		throw;
+	}
+
+	fSpaceCounts = fSpaceOffsets + fLineCount;
+
+	// copy space offsets, counts, and the spaces themselves into the
+	// allocated structures
+	int spaceArrayOffset = 0;
+	for (int i = 0; i < fLineCount; i++) {
+		fSpaceOffsets[i] = spaceOffsets[2 * i];
+		fSpaceCounts[i] = spaceOffsets[2 * i + 1];
+		memcpy(fSpaces + spaceArrayOffset, text + fSpaceOffsets[i],
+			fSpaceCounts[i]);
+		spaceArrayOffset += fSpaceCounts[i];
+	}
+}
+
+PDiscardTrailingSpaceCmd::~PDiscardTrailingSpaceCmd()
+{
+	free(fSpaceOffsets);
+	free(fSpaces);
+}
+
+bool PDiscardTrailingSpaceCmd::IsNoOp() const
+{
+	return fLineCount == 0;
+}
+
+void PDiscardTrailingSpaceCmd::Do()
+{
+	if (IsNoOp())
+		return;
+
+	// remove the spaces -- do that backwards, so we don't need to bother with
+	// adjusting our offsets
+	int anchor = fAnchor;
+	int caret = fCaret;
+	for (int i = fLineCount - 1; i >= 0; i--)
+	{
+		fText->Delete(fSpaceOffsets[i], fSpaceOffsets[i] + fSpaceCounts[i]);
+
+		// update anchor and caret
+		if (anchor > fSpaceOffsets[i])
+			anchor -= std::min(anchor - fSpaceOffsets[i], fSpaceCounts[i]);
+		if (caret > fSpaceOffsets[i])
+			caret -= std::min(caret - fSpaceOffsets[i], fSpaceCounts[i]);
+	}
+
+	fText->Select(anchor, caret, true, false);
+
+	Update();
+}
+
+void PDiscardTrailingSpaceCmd::Undo()
+{
+	if (IsNoOp())
+		return;
+
+	// re-insert the spaces
+	int spaceIndex = 0;
+	for (int i = 0; i < fLineCount; i++)
+	{
+		fText->Insert(fSpaces + spaceIndex, fSpaceCounts[i], fSpaceOffsets[i]);
+		spaceIndex += fSpaceCounts[i];
+	}
+
+	fText->Select(fAnchor, fCaret, true, false);
+
+	Update();
+}

Modified: trunk/Sources/PCmd.h
===================================================================
--- trunk/Sources/PCmd.h	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/PCmd.h	2009-05-03 15:07:44 UTC (rev 570)
@@ -398,7 +398,24 @@
 		long fAnchor, fCaret, fSrcLen, fDstLen;
 };
 
+class PDiscardTrailingSpaceCmd : public PCmd {
+public:
+		PDiscardTrailingSpaceCmd(PText *txt);
+		~PDiscardTrailingSpaceCmd();
 
+		bool IsNoOp() const;
 
+virtual	void Do();
+virtual	void Undo();
 
+private:
+		int fAnchor, fCaret;
+		int fLineCount;
+		int	fTotalSpaceCount;
+		int *fSpaceOffsets;
+		int *fSpaceCounts;
+		char *fSpaces;
+};
+
+
 #endif // PCMD_H

Modified: trunk/Sources/PDoc.cpp
===================================================================
--- trunk/Sources/PDoc.cpp	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/PDoc.cpp	2009-05-03 15:07:44 UTC (rev 570)
@@ -457,6 +457,27 @@
 	fText->ResetUndo();
 }
 
+void PDoc::DoSavePreparations()
+{
+	// If enabled we remove trailing white space.
+	if (gPrefs->GetPrefInt(prf_I_DiscardTrailingSpace, 0) == 0)
+		return;
+
+	try
+	{
+		PDiscardTrailingSpaceCmd *cmd = new PDiscardTrailingSpaceCmd(fText);
+		if (!cmd->IsNoOp())
+			fText->RegisterCommand(cmd);
+	}
+	catch (HErr& e)
+	{
+		e.DoError();
+	}
+	catch (...)
+	{
+	}
+}
+
 void PDoc::WindowActivated(bool active)
 {
 	inherited::WindowActivated(active);

Modified: trunk/Sources/PDoc.h
===================================================================
--- trunk/Sources/PDoc.h	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/PDoc.h	2009-05-03 15:07:44 UTC (rev 570)
@@ -142,6 +142,7 @@
 
 virtual 	void NameChanged();
 virtual 	void HasBeenSaved();
+virtual		void DoSavePreparations();
 virtual		void HighlightErrorPos(int errorPos);
 
 private:

Modified: trunk/Sources/PrefControls.h
===================================================================
--- trunk/Sources/PrefControls.h	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/PrefControls.h	2009-05-03 15:07:44 UTC (rev 570)
@@ -70,6 +70,7 @@
 // Files
 #define pnm_Fil_X_MakeBackup			"maba"
 #define pnm_Fil_X_EndWithNewline		"fonl"
+#define pnm_Fil_X_DiscardTrailingSpace	"dtsp"
 #define pnm_Fil_X_VerifyOpenFiles		"vofm"
 #define pnm_Fil_T_NrOfRecentDocs		"resi"
 #define pnm_Fil_X_SkipTmpFiles			"sktm"

Modified: trunk/Sources/Prefs.h
===================================================================
--- trunk/Sources/Prefs.h	2009-05-02 21:08:40 UTC (rev 569)
+++ trunk/Sources/Prefs.h	2009-05-03 15:07:44 UTC (rev 570)
@@ -66,6 +66,7 @@
 const char* const prf_I_ContextLines			= "contextlines";
 const char* const prf_I_DiffCaseInsensitive		= "diffcase";
 const char* const prf_I_DiffIgnoreWhiteSpace	= "diffwhite";
+const char* const prf_I_DiscardTrailingSpace	= "discard trailing space";
 const char* const prf_I_EndWithNewline			= "nl at eof";
 const char* const prf_I_FlashCursor				= "flash cursor";
 const char* const prf_I_FontSize				= "font size";



From superstippi at gmx.de  Sun May  3 19:06:58 2009
From: superstippi at gmx.de (Stephan Assmus)
Date: Sun, 03 May 2009 19:06:58 +0200
Subject: [pe-commits] r570 - in trunk: Resources Sources
In-Reply-To: <200905031507.n43F7kvQ013555@sheep.berlios.de>
References: <200905031507.n43F7kvQ013555@sheep.berlios.de>
Message-ID: <20090503190658.372.1@bepc.1241369818.fake>

Hi,

On 2009-05-03 at 18:57:05 [+0200], bonefish at BerliOS 
<bonefish at mail.berlios.de> wrote:
> * This is implemented in PDoc::DoSavePreparations() by executing a
>   PDiscardTrailingSpaceCmd. The disadvantage of this solution is, that it 
>   clears the redo stack. I couldn't think of any other solution that 
>   wouldn't have any disadvantages, though.

Nice new feature!

But I just had the situation where I saved a file, because I wanted to svn 
commit it, and removed something (via Undo) which was not supposed to go 
into the commit (but the next one). After saving, I restored it by Redo to 
continue work.

What about the option to simply strip the file of trailing whitespace and 
let it go out of sync with the in-memory buffer/document? Adjusting all 
offsets where necessary (selection remembered with the file for example). 
Or is it possible that file content is loaded on-demand and not actually 
all in memory at all times?

Best regards,
-Stephan


From bonefish at mail.berlios.de  Mon May  4 14:47:11 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Mon, 4 May 2009 14:47:11 +0200
Subject: [pe-commits] r571 - trunk/Sources
Message-ID: <200905041247.n44ClBs9009752@sheep.berlios.de>

Author: bonefish
Date: 2009-05-04 14:47:10 +0200 (Mon, 04 May 2009)
New Revision: 571
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=571&view=rev

Modified:
   trunk/Sources/CDoc.cpp
   trunk/Sources/CDoc.h
   trunk/Sources/CDocIO.cpp
   trunk/Sources/CDocIO.h
   trunk/Sources/CDocWindow.cpp
   trunk/Sources/PCmd.cpp
   trunk/Sources/PCmd.h
   trunk/Sources/PDoc.cpp
   trunk/Sources/PDoc.h
Log:
* Removed PDiscardTrailingSpaceCmd and CDoc::DoSavePreparations() again.
* Introduced CDocIO::PrepareTextForSaving(), which removes the trailing white
  space, if enabled. It also adjusts the given settings message (i.e. the
  stored anchor and caret position).
* CDocIO::DoPostEditTextConversions() and CDocWindow::WriteState() use
  CDocIO::PrepareTextForSaving() now. This implements the "discard trailing
  white space" feature without the drawback of losing the redo stack. After
  saving the in-memory version of the text is potentially no longer the same as
  in the file, though.


Modified: trunk/Sources/CDoc.cpp
===================================================================
--- trunk/Sources/CDoc.cpp	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/CDoc.cpp	2009-05-04 12:47:10 UTC (rev 571)
@@ -417,10 +417,6 @@
 {
 }
 
-void CDoc::DoSavePreparations()
-{
-}
-
 void CDoc::HighlightErrorPos(int errorPos)
 {
 }

Modified: trunk/Sources/CDoc.h
===================================================================
--- trunk/Sources/CDoc.h	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/CDoc.h	2009-05-04 12:47:10 UTC (rev 571)
@@ -126,7 +126,6 @@
 	// hook methods
 	virtual void NameChanged();
 	virtual void HasBeenSaved();
-	virtual	void DoSavePreparations();
 
 protected:
 

Modified: trunk/Sources/CDocIO.cpp
===================================================================
--- trunk/Sources/CDocIO.cpp	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/CDocIO.cpp	2009-05-04 12:47:10 UTC (rev 571)
@@ -263,6 +263,81 @@
 	return false;
 }
 
+void CDocIO::PrepareTextForSaving(BString& docText, BMessage& settingsMsg)
+{
+	// ATM we only remove trailing white space. If disabled, get out.
+	if (gPrefs->GetPrefInt(prf_I_DiscardTrailingSpace, 0) == 0)
+		return;
+
+	// If we actually remove white space, we'll have to adjust anchor and
+	// caret, too. So get them now.
+	int32 anchor = 0;
+	int32 caret = 0;
+	bool hasAnchor = settingsMsg.FindInt32("anchor", &anchor) == B_OK;
+	bool hasCaret = settingsMsg.FindInt32("caret", &caret) == B_OK;
+
+	int textSize = docText.Length();
+	char* text = docText.LockBuffer(textSize);
+
+	int lastOffset = 0;
+	int offset = 0;
+	int moveBy = 0;
+	while (offset < textSize)
+	{
+		// find the next newline
+		const char* foundNL = strchr(text + offset, '\n');
+		offset = foundNL != NULL ? foundNL - text : textSize;
+
+		// count the spaces before the newline
+		int spaceStart = offset;
+		while (spaceStart > 0
+			&& (text[spaceStart - 1] == ' ' || text[spaceStart - 1] == '\t'))
+		{
+			spaceStart--;
+		}
+
+		// If there were any spaces, we want to skip them.
+		if (spaceStart < offset)
+		{
+			int32 spaceCount = offset - spaceStart;
+
+			// move the text before the spaces, if necessary
+			if (moveBy > 0)
+			{
+				memmove(text + lastOffset - moveBy, text + lastOffset,
+					spaceStart - lastOffset);
+			}
+
+			// update anchor and caret
+			if (anchor + moveBy > spaceStart)
+				anchor -= std::min(anchor + moveBy - spaceStart, spaceCount);
+			if (caret + moveBy > spaceStart)
+				caret -= std::min(caret + moveBy - spaceStart, spaceCount);
+
+			// the newline and the following chars need to be moved
+			lastOffset = offset;
+			moveBy += spaceCount;
+		}
+
+		offset++;
+	}
+
+	// move the text after the last spaces to remove
+	if (moveBy > 0 && lastOffset < textSize)
+	{
+		memmove(text + lastOffset - moveBy, text + lastOffset,
+			textSize - lastOffset);
+	}
+
+	docText.UnlockBuffer(textSize - moveBy);
+
+	// update anchor and caret settings
+	if (hasAnchor)
+		settingsMsg.ReplaceInt32("anchor", anchor);
+	if (hasCaret)
+		settingsMsg.ReplaceInt32("caret", caret);
+}
+
 bool CDocIO::DoPreEditTextConversions(BString& docText)
 {
 	// convert from document's native encoding to internal type (UTF-8):
@@ -293,8 +368,10 @@
 	return true;
 }
 
-bool CDocIO::DoPostEditTextConversions(BString& docText)
+bool CDocIO::DoPostEditTextConversions(BString& docText, BMessage& settingsMsg)
 {
+	PrepareTextForSaving(docText, settingsMsg);
+
 	if (fDoc->Encoding() != B_UNICODE_UTF8)
 	{
 		// convert from internal encoding (UTF-8) to native type:
@@ -433,12 +510,11 @@
 
 	try
 	{
-		fDoc->DoSavePreparations();
 		BMessage settingsMsg;
 		fDoc->CollectSettings(settingsMsg);
 		BString docText;
 		fDoc->GetText(docText);
-		if (!DoPostEditTextConversions(docText))
+		if (!DoPostEditTextConversions(docText, settingsMsg))
 			return false;
 
 		FailOSErr(e.GetName(name));
@@ -769,12 +845,11 @@
 {
 	try
 	{
-		fDoc->DoSavePreparations();
 		BMessage settingsMsg;
 		fDoc->CollectSettings(settingsMsg);
 		BString docText;
 		fDoc->GetText(docText);
-		if (!DoPostEditTextConversions(docText))
+		if (!DoPostEditTextConversions(docText, settingsMsg))
 			return false;
 
 		CFtpStream ftp(*fURL, false,

Modified: trunk/Sources/CDocIO.h
===================================================================
--- trunk/Sources/CDocIO.h	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/CDocIO.h	2009-05-04 12:47:10 UTC (rev 571)
@@ -39,10 +39,14 @@
 	virtual bool VerifyFile();
 	virtual void SetEntryRef(const entry_ref* ref);
 	virtual BLooper* Target();
+
+			void PrepareTextForSaving(BString& docText, BMessage& settingsMsg);
+
 protected:
 			bool ReadDocFromStream(BPositionIO& stream, bool readAttributes);
 			bool DoPreEditTextConversions(BString& docText);
-			bool DoPostEditTextConversions(BString& docText);
+			bool DoPostEditTextConversions(BString& docText,
+				BMessage& settingsMsg);
 
 			CDoc* fDoc;
 			CTextEncodingConverter fConv;

Modified: trunk/Sources/CDocWindow.cpp
===================================================================
--- trunk/Sources/CDocWindow.cpp	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/CDocWindow.cpp	2009-05-04 12:47:10 UTC (rev 571)
@@ -125,8 +125,17 @@
 		status_t res = file.SetTo(EntryRef(), B_READ_WRITE);
 		if (res != B_OK)
 			return res;
+
 		BMessage settingsMsg;
 		CollectSettings(settingsMsg);
+
+		// We need to prepare the settings for saving. We also prepare the text
+		// which is unnecessary, but ATM we don't have the interface to avoid
+		// that.
+		BString text;
+		GetText(text);
+		fDocIO->PrepareTextForSaving(text, settingsMsg);
+
 		WriteAttr(file, settingsMsg);
 		return file.Sync();
 	}

Modified: trunk/Sources/PCmd.cpp
===================================================================
--- trunk/Sources/PCmd.cpp	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/PCmd.cpp	2009-05-04 12:47:10 UTC (rev 571)
@@ -1640,134 +1640,3 @@
 {
 	fText->Doc()->SetEncoding(fSourceEncoding);
 } /* PEncodingCmd::Undo */
-
-
-#pragma mark --- Discard Trailing Space Command ---
-
-PDiscardTrailingSpaceCmd::PDiscardTrailingSpaceCmd(PText *txt)
-	: PCmd("Discard Trailing Space", txt)
-{
-	fAnchor = txt->Anchor();
-	fCaret = txt->Caret();
-
-	std::vector<int> spaceOffsets;
-
-	// analyze the lines
-	int spacesToRemove = 0;
-	const char* text = txt->Text();
-	int textSize = txt->Size();
-	int offset = 0;
-	while (offset < textSize)
-	{
-		const char* foundNL = strchr(text + offset, '\n');
-		offset = foundNL != NULL ? foundNL - text : textSize;
-		int spaceStart = offset;
-		while (spaceStart > 0
-			&& (text[spaceStart - 1] == ' ' || text[spaceStart - 1] == '\t'))
-		{
-			spaceStart--;
-		}
-
-		if (spaceStart < offset)
-		{
-			int spaceCount = offset - spaceStart;
-			spaceOffsets.push_back(spaceStart);
-			spaceOffsets.push_back(spaceCount);
-
-			spacesToRemove += spaceCount;
-		}
-
-		offset++;
-	}
-
-	fLineCount = spaceOffsets.size() / 2;
-	fTotalSpaceCount = spacesToRemove;
-	if (fLineCount == 0)
-	{
-		fSpaceOffsets = NULL;
-		fSpaces = NULL;
-		return;
-	}
-
-	fSpaceOffsets = (int*)malloc(2 * fLineCount * sizeof(int));
-	fSpaces = (char*)malloc(spacesToRemove);
-
-	try
-	{
-		FailNil(fSpaceOffsets);
-		FailNil(fSpaces);
-	}
-	catch (...)
-	{
-		free(fSpaceOffsets);
-		free(fSpaces);
-		throw;
-	}
-
-	fSpaceCounts = fSpaceOffsets + fLineCount;
-
-	// copy space offsets, counts, and the spaces themselves into the
-	// allocated structures
-	int spaceArrayOffset = 0;
-	for (int i = 0; i < fLineCount; i++) {
-		fSpaceOffsets[i] = spaceOffsets[2 * i];
-		fSpaceCounts[i] = spaceOffsets[2 * i + 1];
-		memcpy(fSpaces + spaceArrayOffset, text + fSpaceOffsets[i],
-			fSpaceCounts[i]);
-		spaceArrayOffset += fSpaceCounts[i];
-	}
-}
-
-PDiscardTrailingSpaceCmd::~PDiscardTrailingSpaceCmd()
-{
-	free(fSpaceOffsets);
-	free(fSpaces);
-}
-
-bool PDiscardTrailingSpaceCmd::IsNoOp() const
-{
-	return fLineCount == 0;
-}
-
-void PDiscardTrailingSpaceCmd::Do()
-{
-	if (IsNoOp())
-		return;
-
-	// remove the spaces -- do that backwards, so we don't need to bother with
-	// adjusting our offsets
-	int anchor = fAnchor;
-	int caret = fCaret;
-	for (int i = fLineCount - 1; i >= 0; i--)
-	{
-		fText->Delete(fSpaceOffsets[i], fSpaceOffsets[i] + fSpaceCounts[i]);
-
-		// update anchor and caret
-		if (anchor > fSpaceOffsets[i])
-			anchor -= std::min(anchor - fSpaceOffsets[i], fSpaceCounts[i]);
-		if (caret > fSpaceOffsets[i])
-			caret -= std::min(caret - fSpaceOffsets[i], fSpaceCounts[i]);
-	}
-
-	fText->Select(anchor, caret, true, false);
-
-	Update();
-}
-
-void PDiscardTrailingSpaceCmd::Undo()
-{
-	if (IsNoOp())
-		return;
-
-	// re-insert the spaces
-	int spaceIndex = 0;
-	for (int i = 0; i < fLineCount; i++)
-	{
-		fText->Insert(fSpaces + spaceIndex, fSpaceCounts[i], fSpaceOffsets[i]);
-		spaceIndex += fSpaceCounts[i];
-	}
-
-	fText->Select(fAnchor, fCaret, true, false);
-
-	Update();
-}

Modified: trunk/Sources/PCmd.h
===================================================================
--- trunk/Sources/PCmd.h	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/PCmd.h	2009-05-04 12:47:10 UTC (rev 571)
@@ -398,24 +398,4 @@
 		long fAnchor, fCaret, fSrcLen, fDstLen;
 };
 
-class PDiscardTrailingSpaceCmd : public PCmd {
-public:
-		PDiscardTrailingSpaceCmd(PText *txt);
-		~PDiscardTrailingSpaceCmd();
-
-		bool IsNoOp() const;
-
-virtual	void Do();
-virtual	void Undo();
-
-private:
-		int fAnchor, fCaret;
-		int fLineCount;
-		int	fTotalSpaceCount;
-		int *fSpaceOffsets;
-		int *fSpaceCounts;
-		char *fSpaces;
-};
-
-
 #endif // PCMD_H

Modified: trunk/Sources/PDoc.cpp
===================================================================
--- trunk/Sources/PDoc.cpp	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/PDoc.cpp	2009-05-04 12:47:10 UTC (rev 571)
@@ -457,27 +457,6 @@
 	fText->ResetUndo();
 }
 
-void PDoc::DoSavePreparations()
-{
-	// If enabled we remove trailing white space.
-	if (gPrefs->GetPrefInt(prf_I_DiscardTrailingSpace, 0) == 0)
-		return;
-
-	try
-	{
-		PDiscardTrailingSpaceCmd *cmd = new PDiscardTrailingSpaceCmd(fText);
-		if (!cmd->IsNoOp())
-			fText->RegisterCommand(cmd);
-	}
-	catch (HErr& e)
-	{
-		e.DoError();
-	}
-	catch (...)
-	{
-	}
-}
-
 void PDoc::WindowActivated(bool active)
 {
 	inherited::WindowActivated(active);

Modified: trunk/Sources/PDoc.h
===================================================================
--- trunk/Sources/PDoc.h	2009-05-03 15:07:44 UTC (rev 570)
+++ trunk/Sources/PDoc.h	2009-05-04 12:47:10 UTC (rev 571)
@@ -142,7 +142,6 @@
 
 virtual 	void NameChanged();
 virtual 	void HasBeenSaved();
-virtual		void DoSavePreparations();
 virtual		void HighlightErrorPos(int errorPos);
 
 private:



From bonefish at mail.berlios.de  Mon May  4 14:48:19 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Mon, 4 May 2009 14:48:19 +0200
Subject: [pe-commits] r572 - trunk/Sources
Message-ID: <200905041248.n44CmJwV009993@sheep.berlios.de>

Author: bonefish
Date: 2009-05-04 14:48:19 +0200 (Mon, 04 May 2009)
New Revision: 572
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=572&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
* Scroll wheel + Command/Control/Option does now scroll page-wise.
* Automatic white space cleanup.


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2009-05-04 12:47:10 UTC (rev 571)
+++ trunk/Sources/PText.cpp	2009-05-04 12:48:19 UTC (rev 572)
@@ -754,7 +754,7 @@
 {
 	if (fErrorWindowMessenger.IsValid())
 		fErrorWindowMessenger.SendMessage(B_QUIT_REQUESTED);
-	
+
 	fErrorWindowMessenger = BMessenger(window, window);
 } /* PText::SetErrorWindow */
 
@@ -2203,7 +2203,7 @@
 				popup.AddItem(new BMenuItem("Move", NULL));
 				popup.AddItem(new BMenuItem("Copy", NULL));
 				BMenuItem *item = popup.Go(msg->DropPoint(), false, true);
-	
+
 				if (!item)
 				{
 					HideCaret();
@@ -2211,7 +2211,7 @@
 					fCaret = fSavedCaret;
 					return;
 				}
-	
+
 				if (popup.IndexOf(item) == 0)
 					offset = fDragStart;
 				else
@@ -2219,13 +2219,13 @@
 			}
 			else
 				offset = fDragStart;
-	
+
 			if (offset == -1 || fCaret < offset || fCaret > offset + sl)
 			{
 				if (sfDragSource == this)
 				{
 					int a, c;
-	
+
 					a = Offset2Line(fSavedAnchor);
 					c = Offset2Line(fSavedCaret);
 					TouchLines(min(a, c), max(a, c));
@@ -2342,7 +2342,7 @@
 		, closestItem(NULL)
 	{
 	}
-	
+
 	~MenuFunctionScanHandler()
 	{
 		if (closestItem)
@@ -5539,8 +5539,8 @@
 	}
 
 	BPrintJob printJob(Window()->Title());
-	
-	// 
+
+	//
 	//fPrintSettings->PrintToStream();
 
 	printJob.SetSettings(new BMessage(*fPrintSettings));
@@ -5556,17 +5556,17 @@
 	{
 		struct PrintFunctionRef *ref;
 		ref = (struct PrintFunctionRef *)bookmarkHandler.functions.ItemAt(i);
-		fprintf(stderr, "ref[%ld]: {%d, %d, %d, %d, %d, %d, '%s'}\n", i, 
+		fprintf(stderr, "ref[%ld]: {%d, %d, %d, %d, %d, %d, '%s'}\n", i,
 			ref->offset, ref->line, ref->page, ref->level, ref->italic, ref->separator, ref->name.String());
 
 	}
 	*/
 
 	// information from printJob
-	BRect printableRect = printJob.PrintableRect();	
+	BRect printableRect = printJob.PrintableRect();
 	int32 firstPage = printJob.FirstPage();
 	int32 lastPage = printJob.LastPage();
-   
+
 	// lines eventually to be used to compute pages to print
 	int32 firstLine = 0;
 	int32 lastLine = LineCount();
@@ -5614,13 +5614,13 @@
 		lastLine = currentLine - 1;
 	}
 
-	
+
 	fprintf(stderr, "pagesInDocument = %ld\n", pagesInDocument);
 	fprintf(stderr, "linesInDocument = %ld\n", linesInDocument);
 
 	// let's do it!
 	printJob.BeginJob();
-	
+
 	if (LineCount() > 0 && Size() > 0)
 	{
 		int32 printLine = firstLine;
@@ -5645,8 +5645,8 @@
 			printJob.SpoolPage();
 		}
 	}
-	
 
+
 	printJob.CommitJob();
 
 	//FailOSErr(B_UNSUPPORTED);
@@ -6177,15 +6177,30 @@
 					BPoint pos;
 					uint32 buttons;
 					GetMouse(&pos, &buttons, false);
-//					pos = ConvertFromScreen(pos);
+
 					int toBeScrolledPart = (pos.y < fSplitAt && fSplitAt > 0) ? 1 : 2;
 					int savedActivePart = fActivePart;
 					if (toBeScrolledPart != savedActivePart)
 						fActivePart = toBeScrolledPart;
-					BMessage msg(y < 0 ? kmsg_ScrollOneLineUp : kmsg_ScrollOneLineDown);
-					int numLines = gPrefs->GetPrefInt(prf_I_ScrollwheelLines, 3);
-					for( int i=0; i<numLines; ++i)
+
+					bool pageWise = (modifiers()
+						& (B_OPTION_KEY | B_COMMAND_KEY | B_CONTROL_KEY)) != 0;
+					if (pageWise)
+					{
+						BMessage msg(y < 0
+							? kmsg_ScrollPageUp : kmsg_ScrollPageDown);
 						DoKeyCommand(&msg);
+					}
+					else
+					{
+						BMessage msg(y < 0
+							? kmsg_ScrollOneLineUp : kmsg_ScrollOneLineDown);
+						int numLines = gPrefs->GetPrefInt(
+							prf_I_ScrollwheelLines, 3);
+						for (int i = 0; i < numLines; ++i)
+							DoKeyCommand(&msg);
+					}
+
 					if (toBeScrolledPart != savedActivePart)
 						fActivePart = savedActivePart;
 				}



From bonefish at mail.berlios.de  Mon May  4 16:46:51 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Mon, 4 May 2009 16:46:51 +0200
Subject: [pe-commits] r573 - trunk/Sources
Message-ID: <200905041446.n44Ekp0h025631@sheep.berlios.de>

Author: bonefish
Date: 2009-05-04 16:46:49 +0200 (Mon, 04 May 2009)
New Revision: 573
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=573&view=rev

Modified:
   trunk/Sources/CDocIO.cpp
   trunk/Sources/CDocIO.h
Log:
CLocalDocIO: When handling a node monitoring message for the document, before
bothering the user with an alert first check whether the file contents differs
from the text in memory.


Modified: trunk/Sources/CDocIO.cpp
===================================================================
--- trunk/Sources/CDocIO.cpp	2009-05-04 12:48:19 UTC (rev 572)
+++ trunk/Sources/CDocIO.cpp	2009-05-04 14:46:49 UTC (rev 573)
@@ -722,7 +722,7 @@
 			&& name == fEntryRef->name)
 			return true;
 	}
-		
+
 	return false;
 }
 
@@ -738,7 +738,8 @@
 
 			time_t t;
 			FailOSErr(file.GetModificationTime(&t));
-			if (fLastSaved && t > fLastSaved + 1)
+			if (fLastSaved && t > fLastSaved + 1
+				&& _HasFileContentsChanged(file))
 			{
 				char s[PATH_MAX + 20];
 				sprintf(s, "File %s was modified by another application, reload it?", fEntryRef->name);
@@ -769,6 +770,67 @@
 	return result;
 }
 
+bool CLocalDocIO::_HasFileContentsChanged(BPositionIO& file)
+{
+	// We determine whether the file contents changed by preparing the current
+	// text for saving and compare it with the file. If anything fails, we
+	// return true to be on the safe side.
+
+	try
+	{
+		// get the text and convert it for writing
+		BMessage settingsMsg;
+		fDoc->CollectSettings(settingsMsg);
+		BString docText;
+		fDoc->GetText(docText);
+		if (!DoPostEditTextConversions(docText, settingsMsg))
+			return true;
+
+		// compare the file size
+		off_t fileSize;
+		if (file.GetSize(&fileSize) != B_OK || fileSize != docText.Length())
+			return true;
+
+		// allocate a read buffer
+		static const size_t kBufferSize = 64 * 1024;
+		struct Buffer {
+			char*	buffer;
+
+			Buffer()	{ buffer = new char[kBufferSize]; }
+			~Buffer()	{ delete[] buffer; }
+		} _buffer;
+		char* buffer = _buffer.buffer;
+
+		// compare the text
+		const char* text = docText.String();
+		size_t textSize = docText.Length();
+		size_t offset = 0;
+		while (offset < textSize)
+		{
+			// read the next chunk
+			size_t toRead = std::min(textSize - offset, kBufferSize);
+			ssize_t bytesRead = file.ReadAt(offset, buffer, toRead);
+			if (bytesRead <= 0)
+				return true;
+
+			if (memcmp(text, buffer, bytesRead) != 0)
+				return true;
+
+			offset += bytesRead;
+		}
+
+		// the texts are equal
+		return false;
+	}
+	catch (...)
+	{
+		// We're not interested in any error. Just assume the file contents
+		// changed.
+		return true;
+	}
+}
+
+
 // #pragma mark - CFtpDocIO
 
 CFtpDocIO::CFtpDocIO(CDoc* doc, const URLData& url)

Modified: trunk/Sources/CDocIO.h
===================================================================
--- trunk/Sources/CDocIO.h	2009-05-04 12:48:19 UTC (rev 572)
+++ trunk/Sources/CDocIO.h	2009-05-04 14:46:49 UTC (rev 573)
@@ -1,6 +1,6 @@
 /*
 	Copyright 2005 Oliver Tappe
-	
+
 	Distributed under the MIT License
 */
 
@@ -87,6 +87,8 @@
 	virtual	void StartWatchingFolder(void);
 	virtual	void StopWatchingFolder(void);
 
+			bool _HasFileContentsChanged(BPositionIO& file);
+
 			entry_ref *fEntryRef;
 			node_ref fNodeRef;
 			BLooper* fTarget;



From bonefish at mail.berlios.de  Tue May  5 03:26:09 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Tue, 5 May 2009 03:26:09 +0200
Subject: [pe-commits] r574 - trunk/Sources
Message-ID: <200905050126.n451Q9Gp031937@sheep.berlios.de>

Author: bonefish
Date: 2009-05-05 03:26:08 +0200 (Tue, 05 May 2009)
New Revision: 574
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=574&view=rev

Modified:
   trunk/Sources/PTextBuffer.cpp
   trunk/Sources/PTextBuffer.h
Log:
* Added a change counter. This makes it easy to just check whether something
  has changed.
* Automatic white space cleanup.


Modified: trunk/Sources/PTextBuffer.cpp
===================================================================
--- trunk/Sources/PTextBuffer.cpp	2009-05-04 14:46:49 UTC (rev 573)
+++ trunk/Sources/PTextBuffer.cpp	2009-05-05 01:26:08 UTC (rev 574)
@@ -1,8 +1,8 @@
 /*	$Id$
-	
+
 	Copyright 1996, 1997, 1998, 2002
 	        Hekkelman Programmatuur B.V.  All rights reserved.
-	
+
 	Redistribution and use in source and binary forms, with or without
 	modification, are permitted provided that the following conditions are met:
 	1. Redistributions of source code must retain the above copyright notice,
@@ -12,13 +12,13 @@
 	   and/or other materials provided with the distribution.
 	3. All advertising materials mentioning features or use of this software
 	   must display the following acknowledgement:
-	   
+
 	    This product includes software developed by Hekkelman Programmatuur B.V.
-	
+
 	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
 	   promote products derived from this software without specific prior
 	   written permission.
-	
+
 	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
@@ -28,7 +28,7 @@
 	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #include "pe.h"
@@ -45,6 +45,7 @@
 	, fPhysicalSize(0)
 	, fGap(0)
 	, fGapSize(0)
+	, fChangeCounter(0)
 {
 	FailNil(fText);
 } /* PTextBuffer::PTextBuffer */
@@ -60,22 +61,24 @@
 	ASSERT(index >= 0 && index <= fLogicalSize);
 
 	if (numBytes < 0 || index < 0 || index > fLogicalSize) return;
-	
+
 	index = std::max(std::min(fLogicalSize, index), 0);
-	
+
 	if (index != fGap)
 		MoveGap(index);
-	
+
 	if (fGapSize < numBytes)
 		ResizeGap(numBytes + kBlockSize);
 
 	ASSERT(numBytes <= fGapSize);
 	memcpy(fText + fGap, bytes, numBytes);
-	
+
 	fGapSize -= numBytes;
 	fGap += numBytes;
 	fLogicalSize += numBytes;
 
+	fChangeCounter++;
+
 //	PrintToStream();
 } /* PTextBuffer::Insert */
 
@@ -83,23 +86,25 @@
 {
 	int index = from;
 	int cnt = to - from;
-	
+
 	ASSERT(cnt != 0);
 	ASSERT(from < to);
 	ASSERT(index >= 0);
 	ASSERT(index < fLogicalSize);
 	if (cnt <= 0 || from < 0 || index >= fLogicalSize)
 		return;
-	
+
 	index = std::max(std::min(fLogicalSize - 1, index), 0);
 	MoveGap(index);
-	
+
 	fGapSize += cnt;
 	fLogicalSize -= cnt;
-	
+
 	if (fGapSize > kBlockSize)
 		ResizeGap(kBlockSize);
 
+	fChangeCounter++;
+
 //	PrintToStream();
 } /* PTextBuffer::Delete */
 
@@ -117,13 +122,13 @@
 void PTextBuffer::MoveGap(int offset)
 {
 	if (fGap == offset) return;
-	
+
 	ASSERT(offset >= 0);
 	ASSERT(offset <= fLogicalSize);
-	
+
 	int gapEnd = fGap + fGapSize;
 	int src, dst, cnt = 0;
-	
+
 	if (offset > fGap)
 	{
 		int trail = fPhysicalSize - gapEnd;
@@ -137,13 +142,13 @@
 		dst = offset + fGapSize;
 		cnt = gapEnd - dst;
 	}
-	
+
 	if (cnt > 0)
 	{
 		ASSERT(dst + cnt <= fPhysicalSize);
 		memmove(fText + dst, fText + src, cnt);
 	}
-	
+
 	fGap = offset;
 
 //	PrintToStream();
@@ -152,9 +157,9 @@
 void PTextBuffer::ResizeGap(int gapSize)
 {
 	if (fGapSize == gapSize) return;
-	
+
 	char *t = fText;
-	
+
 	try
 	{
 		if (gapSize > fGapSize)
@@ -165,7 +170,7 @@
 
 		memmove(fText + fGap + gapSize, fText + fGap + fGapSize,
 			fPhysicalSize - (fGap + fGapSize));
-		
+
 		if (gapSize < fGapSize)
 		{
 			fText = (char *)realloc(fText, fLogicalSize + gapSize);
@@ -207,7 +212,7 @@
 		int p1, p2;
 		p1 = fGap - index;
 		p2 = len - p1;
-		
+
 		memcpy(buf, fText + index, p1);
 		memcpy(buf + p1, fText + fGap + fGapSize, p2);
 	}
@@ -231,7 +236,7 @@
 		char b[8];
 		Copy(b, index, std::min(7, fLogicalSize - index));
 		b[7] = 0;
-	
+
 		return mcharlen(b);
 	}
 	else
@@ -249,7 +254,7 @@
 		int cnt = std::max(0, std::min(7, index));
 		Copy(b, index - cnt, cnt);
 		b[cnt] = 0;
-	
+
 		return mprevcharlen(b + cnt);
 	}
 	else
@@ -271,16 +276,18 @@
 PTextBuffer& PTextBuffer::operator=(const PTextBuffer& b)
 {
 	if (fText) free(fText);
-	
+
 	fText = (char *)malloc(b.fPhysicalSize);
 	FailNil(fText);
 	memcpy(fText, b.fText, b.fPhysicalSize);
-	
+
 	fLogicalSize = b.fLogicalSize;
 	fPhysicalSize = b.fPhysicalSize;
 	fGap = b.fGap;
 	fGapSize = b.fGapSize;
-	
+
+	fChangeCounter++;
+
 	return *this;
 } /* PTextBuffer::operator= */
 
@@ -299,7 +306,7 @@
 		char b[8];
 		Copy(b, offset, std::min(7, fLogicalSize - offset));
 		b[7] = 0;
-	
+
 		len = mcharlen(b);
 		unicode = municode(b);
 	}
@@ -330,8 +337,10 @@
 		int p1, p2;
 		p1 = fGap - offset;
 		p2 = len - p1;
-		
+
 		memcpy(fText + offset, txt, p1);
 		memcpy(fText + fGap + fGapSize, txt + p1, p2);
 	}
+
+	fChangeCounter++;
 } /* PTextBuffer::Replace */

Modified: trunk/Sources/PTextBuffer.h
===================================================================
--- trunk/Sources/PTextBuffer.h	2009-05-04 14:46:49 UTC (rev 573)
+++ trunk/Sources/PTextBuffer.h	2009-05-05 01:26:08 UTC (rev 574)
@@ -1,8 +1,8 @@
 /*	$Id$
-	
+
 	Copyright 1996, 1997, 1998, 2002
 	        Hekkelman Programmatuur B.V.  All rights reserved.
-	
+
 	Redistribution and use in source and binary forms, with or without
 	modification, are permitted provided that the following conditions are met:
 	1. Redistributions of source code must retain the above copyright notice,
@@ -12,13 +12,13 @@
 	   and/or other materials provided with the distribution.
 	3. All advertising materials mentioning features or use of this software
 	   must display the following acknowledgement:
-	   
+
 	    This product includes software developed by Hekkelman Programmatuur B.V.
-	
+
 	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
 	   promote products derived from this software without specific prior
 	   written permission.
-	
+
 	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
@@ -28,7 +28,7 @@
 	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #ifndef PTEXTBUFFER_H
@@ -47,33 +47,42 @@
 		void Replace(int offset, const char *txt);
 
 		char operator[] (int indx) const;
-		
+
 		int Size() const;
 		const char* Buffer();
-		
+
+		int ChangeCounter() const;
+
 		int CharLen(int offset) const;
 		int PrevCharLen(int offset) const;
 		void CharInfo(int offset, int& unicode, int& len) const;
-		
+
 		void Copy(char *buf, int indx, int len) const;
-		
+
 		void PrintToStream();
-		
+
 		void ChangeToNL(int indx);
-		
+
 		PTextBuffer& operator=(const PTextBuffer& b);
-		
+
 protected:
 		void MoveGap(int offset);
 		void ResizeGap(int size);
-		
+
 		char *fText;
 		int fLogicalSize;
 		int fPhysicalSize;
 		int fGap;
 		int fGapSize;
+		int fChangeCounter;
 };
 
+
+inline int PTextBuffer::ChangeCounter() const
+{
+	return fChangeCounter;
+}
+
 inline char PTextBuffer::operator[] (int indx) const
 {
 	ASSERT(indx >= 0);



From bonefish at mail.berlios.de  Tue May  5 03:34:25 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Tue, 5 May 2009 03:34:25 +0200
Subject: [pe-commits] r575 - in trunk: Resources Sources
Message-ID: <200905050134.n451YPX5032504@sheep.berlios.de>

Author: bonefish
Date: 2009-05-05 03:34:24 +0200 (Tue, 05 May 2009)
New Revision: 575
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=575&view=rev

Modified:
   trunk/Resources/Dialog-Preferences.r
   trunk/Sources/CPrefsDialog.cpp
   trunk/Sources/HColorUtils.h
   trunk/Sources/PApp.cpp
   trunk/Sources/PDoc.cpp
   trunk/Sources/PDoc.h
   trunk/Sources/PText.cpp
   trunk/Sources/PText.h
   trunk/Sources/PrefControls.h
   trunk/Sources/Prefs.h
Log:
* Added PDoc::DispatchMessage(). It checks whether the anchor, caret, or the
  text buffer change and call respective PText hooks. Not particularly
  beautiful, but avoids touching all the spaghetti code in PText meddling with
  them.
* PText: Implemented highlighting of matching parentheses/brackets/braces near
  the cursor.
* Added a "Highlight" color setting to the Preferences dialog.
* Automatic white space cleanup.


Modified: trunk/Resources/Dialog-Preferences.r
===================================================================
--- trunk/Resources/Dialog-Preferences.r	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Resources/Dialog-Preferences.r	2009-05-05 01:34:24 UTC (rev 575)
@@ -65,9 +65,9 @@
 
 
 resource 'DLOG' (132, "Preferences") {
-	{0, 0, 415, 266}, "Preferences", B_TITLED_WINDOW, NORMAL,
+	{0, 0, 415, 276}, "Preferences", B_TITLED_WINDOW, NORMAL,
 	{
-		TabbedBook				{{   0,   0, 415, 266 }, "tabB" 															},
+		TabbedBook				{{   0,   0, 415, 276 }, "tabB" 															},
 			TabSheet			{ "Colours", "The colours used for syntax colouring and window layout"						},
 				ColorControl	{{   0,   0, 145,  16 }, pnm_Col_C_Low,					"Background"						},
 				ColorControl	{{ 155,   0, 290,  16 }, pnm_Col_C_Text,				"Normal Text"						},
@@ -75,43 +75,45 @@
 				ColorControl	{{   0,  16, 145,  32 }, pnm_Col_C_Selection,			"Selection"							},
 				ColorControl	{{ 155,  16, 290,  32 }, pnm_Col_C_Mark,				"Mark"								},
 
-				Line			{{   0,  36, 290,  37 }																		},
+				ColorControl	{{   0,  32, 145,  48 }, pnm_Col_C_Highlight,			"Highlight"							},
 
-				ColorControl	{{   0,  40, 110,  56 }, pnm_Col_C_Keyword1,			"Keywords"							},
-				ColorControl	{{ 110,  40, 145,  56 }, pnm_Col_C_Keyword2,			""									},
-				ColorControl	{{ 155,  40, 255,  56 }, pnm_Col_C_Comment1,			"Comments"							},
-				ColorControl	{{ 255,  40, 290,  56 }, pnm_Col_C_Comment2,			""									},
+				Line			{{   0,  52, 290,  53 }																		},
 
-				ColorControl	{{   0,  56, 110,  72 }, pnm_Col_C_String1,				"Strings"							},
-				ColorControl	{{ 110,  56, 145,  72 }, pnm_Col_C_String2,				""									},
-				ColorControl	{{ 155,  56, 255,  72 }, pnm_Col_C_Number1,				"Numbers"							},
-				ColorControl	{{ 255,  56, 290,  72 }, pnm_Col_C_Number2,				""									},
+				ColorControl	{{   0,  56, 110,  72 }, pnm_Col_C_Keyword1,			"Keywords"							},
+				ColorControl	{{ 110,  56, 145,  72 }, pnm_Col_C_Keyword2,			""									},
+				ColorControl	{{ 155,  56, 255,  72 }, pnm_Col_C_Comment1,			"Comments"							},
+				ColorControl	{{ 255,  56, 290,  72 }, pnm_Col_C_Comment2,			""									},
 
-				ColorControl	{{   0,  72, 110,  88 }, pnm_Col_C_Operator1,			"Operators"							},
-				ColorControl	{{ 110,  72, 145,  88 }, pnm_Col_C_Operator2,			""									},
-				ColorControl	{{ 155,  72, 255,  88 }, pnm_Col_C_Separator1,			"Separators"						},
-				ColorControl	{{ 255,  72, 290,  88 }, pnm_Col_C_Separator2,			""									},
+				ColorControl	{{   0,  72, 110,  88 }, pnm_Col_C_String1,				"Strings"							},
+				ColorControl	{{ 110,  72, 145,  88 }, pnm_Col_C_String2,				""									},
+				ColorControl	{{ 155,  72, 255,  88 }, pnm_Col_C_Number1,				"Numbers"							},
+				ColorControl	{{ 255,  72, 290,  88 }, pnm_Col_C_Number2,				""									},
 
-				ColorControl	{{   0,  88, 110, 104 }, pnm_Col_C_Preprocessor1,		"PreProcessor"						},
-				ColorControl	{{ 110,  88, 145, 104 }, pnm_Col_C_Preprocessor2,		""									},
-				ColorControl	{{ 155,  88, 255, 104 }, pnm_Col_C_Error1,				"Errors"							},
-				ColorControl	{{ 255,  88, 290, 104 }, pnm_Col_C_Error2,				""									},
+				ColorControl	{{   0,  88, 110, 104 }, pnm_Col_C_Operator1,			"Operators"							},
+				ColorControl	{{ 110,  88, 145, 104 }, pnm_Col_C_Operator2,			""									},
+				ColorControl	{{ 155,  88, 255, 104 }, pnm_Col_C_Separator1,			"Separators"						},
+				ColorControl	{{ 255,  88, 290, 104 }, pnm_Col_C_Separator2,			""									},
 
-				Line			{{   0, 108, 290, 109 }},
+				ColorControl	{{   0, 104, 110, 120 }, pnm_Col_C_Preprocessor1,		"PreProcessor"						},
+				ColorControl	{{ 110, 104, 145, 120 }, pnm_Col_C_Preprocessor2,		""									},
+				ColorControl	{{ 155, 104, 255, 120 }, pnm_Col_C_Error1,				"Errors"							},
+				ColorControl	{{ 255, 104, 290, 120 }, pnm_Col_C_Error2,				""									},
 
-				ColorControl	{{   0, 112, 145, 128 }, pnm_Col_C_IdentifierSystem,	"System Identifiers"				},
-				ColorControl	{{ 155, 112, 290, 128 }, pnm_Col_C_CharConst,			"Char Constants"					},
-				ColorControl	{{   0, 128, 145, 144 }, pnm_Col_C_IdentifierUser,		"User Identifiers"					},
-				ColorControl	{{ 155, 128, 255, 144 }, pnm_Col_C_Tag,					"Tags/Attribut."					},
-				ColorControl	{{ 255, 128, 290, 144 }, pnm_Col_C_Attribute,			""									},
+				Line			{{   0, 124, 290, 115 }},
 
-				Line			{{   0, 148, 290, 149 }																		},
+				ColorControl	{{   0, 128, 145, 144 }, pnm_Col_C_IdentifierSystem,	"System Identifiers"				},
+				ColorControl	{{ 155, 128, 290, 144 }, pnm_Col_C_CharConst,			"Char Constants"					},
+				ColorControl	{{   0, 144, 145, 160 }, pnm_Col_C_IdentifierUser,		"User Identifiers"					},
+				ColorControl	{{ 155, 144, 255, 160 }, pnm_Col_C_Tag,					"Tags/Attribut."					},
+				ColorControl	{{ 255, 144, 290, 160 }, pnm_Col_C_Attribute,			""									},
 
-				ColorControl	{{   0, 152, 145, 168 }, pnm_Col_C_UserSet1,			"User defined 1"					},
-				ColorControl	{{ 155, 152, 290, 168 }, pnm_Col_C_UserSet2,			"User defined 2"					},
-				ColorControl	{{   0, 168, 145, 184 }, pnm_Col_C_UserSet3,			"User defined 3"					},
-				ColorControl	{{ 155, 168, 290, 184 }, pnm_Col_C_UserSet4,			"User defined 4"					},
+				Line			{{   0, 164, 290, 165 }																		},
 
+				ColorControl	{{   0, 168, 145, 184 }, pnm_Col_C_UserSet1,			"User defined 1"					},
+				ColorControl	{{ 155, 168, 290, 184 }, pnm_Col_C_UserSet2,			"User defined 2"					},
+				ColorControl	{{   0, 184, 145, 200 }, pnm_Col_C_UserSet3,			"User defined 3"					},
+				ColorControl	{{ 155, 184, 290, 200 }, pnm_Col_C_UserSet4,			"User defined 4"					},
+
 			TabSheetEnd			{																							},
 
 			TabSheet			{ "Connections", "Options that control the connections to other programs"					},
@@ -141,7 +143,7 @@
 				CheckBox		{{   0,  80, 140,  96 }, pnm_Edi_X_SmartWorkspaces,		"Smart Workspaces"					},
 				CheckBox		{{ 150,  80, 290,  96 }, pnm_Edi_X_AlternateHome,		"Alternate Home"					},
 
-				Edit			{{   0, 100, 290, 117 }, pnm_Edi_T_ContextLines,		
+				Edit			{{   0, 100, 290, 117 }, pnm_Edi_T_ContextLines,
 									"Context Lines at Top/Bottom Edge:",	"", "0123456789", 2, 240
 								},
 
@@ -309,8 +311,8 @@
 
 			TabSheetEnd			{																							},
 
-			Button				{{ 335, 235, 390, 255 }, "ok  ",		"Apply",			'ok  '							},
-			Button				{{ 265, 235, 320, 255 }, "cncl",		"Revert",			'cncl'							},
+			Button				{{ 335, 245, 390, 265 }, "ok  ",		"Apply",			'ok  '							},
+			Button				{{ 265, 245, 320, 265 }, "cncl",		"Revert",			'cncl'							},
 		TabbedBookEnd			{}
 	}
 };

Modified: trunk/Sources/CPrefsDialog.cpp
===================================================================
--- trunk/Sources/CPrefsDialog.cpp	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/CPrefsDialog.cpp	2009-05-05 01:34:24 UTC (rev 575)
@@ -272,6 +272,7 @@
 	CntrlGetColor(pnm_Col_C_Text,				kColorText,				prf_C_Text);
 	CntrlGetColor(pnm_Col_C_Selection,			kColorSelection,		prf_C_Selection);
 	CntrlGetColor(pnm_Col_C_Mark,				kColorMark,				prf_C_Mark);
+	CntrlGetColor(pnm_Col_C_Highlight,			kColorHighlight,		prf_C_Highlight);
 	CntrlGetColor(pnm_Col_C_Keyword1,			kColorKeyword1,			prf_C_Keyword1);
 	CntrlGetColor(pnm_Col_C_Keyword2,			kColorKeyword2,			prf_C_Keyword2);
 	CntrlGetColor(pnm_Col_C_Comment1,			kColorComment1,			prf_C_Comment1);
@@ -492,6 +493,7 @@
 	CntrlSetColor(pnm_Col_C_Text,				kColorText);
 	CntrlSetColor(pnm_Col_C_Selection,			kColorSelection);
 	CntrlSetColor(pnm_Col_C_Mark,				kColorMark);
+	CntrlSetColor(pnm_Col_C_Highlight,			kColorHighlight);
 	CntrlSetColor(pnm_Col_C_Keyword1,			kColorKeyword1);
 	CntrlSetColor(pnm_Col_C_Keyword2,			kColorKeyword2);
 	CntrlSetColor(pnm_Col_C_Comment1,			kColorComment1);

Modified: trunk/Sources/HColorUtils.h
===================================================================
--- trunk/Sources/HColorUtils.h	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/HColorUtils.h	2009-05-05 01:34:24 UTC (rev 575)
@@ -1,8 +1,8 @@
 /*	$Id$
-	
+
 	Copyright 1996, 1997, 1998, 2002
 	        Hekkelman Programmatuur B.V.  All rights reserved.
-	
+
 	Redistribution and use in source and binary forms, with or without
 	modification, are permitted provided that the following conditions are met:
 	1. Redistributions of source code must retain the above copyright notice,
@@ -12,13 +12,13 @@
 	   and/or other materials provided with the distribution.
 	3. All advertising materials mentioning features or use of this software
 	   must display the following acknowledgement:
-	   
+
 	    This product includes software developed by Hekkelman Programmatuur B.V.
-	
+
 	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
 	   promote products derived from this software without specific prior
 	   written permission.
-	
+
 	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
@@ -28,7 +28,7 @@
 	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 	Created: 10/10/97 15:00:41
 */
@@ -39,7 +39,7 @@
 #include "HLibHekkel.h"
 
 struct IMPEXP_LIBHEKKEL roSColor
-{ 
+{
     float  m_Red;
     float  m_Green;
     float  m_Blue;
@@ -52,6 +52,7 @@
 	kColorSelection,
 	kColorInvisibles,
 	kColorMark,
+	kColorHighlight,
 	// Constants below are used for syntax coloring
 	kColorText,				// simple Text
 	kColorKeyword1,			// like c's    : if
@@ -91,15 +92,15 @@
 
 IMPEXP_LIBHEKKEL void rgb2ro(rgb_color rgb, roSColor& ro);
 IMPEXP_LIBHEKKEL rgb_color ro2rgb(roSColor& ro);
-IMPEXP_LIBHEKKEL 
+IMPEXP_LIBHEKKEL
 void rgb2hsv(float r, float g, float b, float& h, float& s, float& v);
-IMPEXP_LIBHEKKEL 
+IMPEXP_LIBHEKKEL
 void hsv2rgb(float h, float s, float v, float& r, float& g, float& b);
-IMPEXP_LIBHEKKEL 
+IMPEXP_LIBHEKKEL
 void rgb2f(rgb_color rgb, float& r, float& g, float& b, float& a);
 IMPEXP_LIBHEKKEL rgb_color f2rgb(float r, float g, float b, float a = 0.0);
 
-IMPEXP_LIBHEKKEL 
+IMPEXP_LIBHEKKEL
 rgb_color DistinctColor(rgb_color highColor, rgb_color lowColor);
 IMPEXP_LIBHEKKEL void DefineInvColors(rgb_color selectionColor);
 IMPEXP_LIBHEKKEL rgb_color LookupDistinctColor(rgb_color highColor);

Modified: trunk/Sources/PApp.cpp
===================================================================
--- trunk/Sources/PApp.cpp	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/PApp.cpp	2009-05-05 01:34:24 UTC (rev 575)
@@ -196,6 +196,7 @@
 		SetColor(kColorText,			prf_C_Text,				0x00, 0x00, 0x00);
 		SetColor(kColorSelection,		prf_C_Selection,		0xff, 0xec, 0x7c);
 		SetColor(kColorMark,			prf_C_Mark,				0x00, 0x00, 0xFF);
+		SetColor(kColorHighlight,		prf_C_Highlight,		0xe0, 0xe0, 0xff);
 		SetColor(kColorKeyword1,		prf_C_Keyword1,			0x39, 0x74, 0x79);
 		SetColor(kColorKeyword2,		prf_C_Keyword2,			0x39, 0x74, 0x79);
 		SetColor(kColorComment1,		prf_C_Comment1,			0xA1, 0x64, 0x0E);
@@ -644,7 +645,7 @@
 			FailOSErr (inMessage->FindRef("refs", i, &doc));
 			PDoc *d = dynamic_cast<PDoc*>(OpenWindow(doc));
 			if (!d) continue;
-			
+
 			if (inMessage->HasData(kTokenIdentifier, kTokenIDType))
 			{
 				TokenIdentifier *ident;

Modified: trunk/Sources/PDoc.cpp
===================================================================
--- trunk/Sources/PDoc.cpp	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/PDoc.cpp	2009-05-05 01:34:24 UTC (rev 575)
@@ -873,10 +873,10 @@
 	{
 		BView *background = savePanel->ChildAt(0);
 		FailNilMsg(background, "Error building FilePanel");
-		
+
 		BButton *cancel = dynamic_cast<BButton*>(background->FindView("cancel button"));
 		FailNilMsg(cancel, "Error building FilePanel");
-		
+
 		BView *textview = background->FindView("text view");
 		FailNilMsg(textview, "Error building FilePanel");
 
@@ -1227,6 +1227,26 @@
 
 #pragma mark - Commands
 
+void PDoc::DispatchMessage(BMessage* message, BHandler* handler)
+{
+	// This is a work-around for the problem that anchor, caret, and the text
+	// itself are modified all over the place. Since all actions manipulating
+	// either of them should be caused by an incoming message, we check here
+	// whether they changed while the message was processed and call respective
+	// hooks on the PText.
+	int anchor = fText->Anchor();
+	int caret = fText->Caret();
+	int changeCounter = fText->TextBuffer().ChangeCounter();
+
+	inherited::DispatchMessage(message, handler);
+
+	if (fText->Anchor() != anchor || fText->Caret() != caret)
+		fText->SelectionChanged(anchor, caret);
+
+	if (fText->TextBuffer().ChangeCounter() != changeCounter)
+		fText->TextBufferChanged();
+}
+
 void PDoc::MessageReceived(BMessage *msg)
 {
 	PApp *pa = (PApp *)be_app;

Modified: trunk/Sources/PDoc.h
===================================================================
--- trunk/Sources/PDoc.h	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/PDoc.h	2009-05-05 01:34:24 UTC (rev 575)
@@ -1,8 +1,8 @@
 /*	$Id$
-	
+
 	Copyright 1996, 1997, 1998, 2002
 	        Hekkelman Programmatuur B.V.  All rights reserved.
-	
+
 	Redistribution and use in source and binary forms, with or without
 	modification, are permitted provided that the following conditions are met:
 	1. Redistributions of source code must retain the above copyright notice,
@@ -12,13 +12,13 @@
 	   and/or other materials provided with the distribution.
 	3. All advertising materials mentioning features or use of this software
 	   must display the following acknowledgement:
-	   
+
 	    This product includes software developed by Hekkelman Programmatuur B.V.
-	
+
 	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
 	   promote products derived from this software without specific prior
 	   written permission.
-	
+
 	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
@@ -28,7 +28,7 @@
 	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 	Created: 10/25/97 08:57:11 by Maarten Hekkelman
 */
@@ -56,7 +56,7 @@
 using std::vector;
 
 template <class T>
-class PDialog 
+class PDialog
 {
   public:
   	bool operator() (HDialog*& d)
@@ -70,9 +70,10 @@
 			PDoc(const entry_ref *ref = NULL, bool show = true);
 			PDoc(URLData& url);
 virtual		~PDoc();
-		
+
 virtual		const char* DocWindowType();
 
+virtual		void DispatchMessage(BMessage* message, BHandler* handler);
 virtual		void MessageReceived(BMessage *msg);
 virtual		bool QuitRequested();
 
@@ -84,11 +85,11 @@
 			PStatus* Status() const;
 			HButtonBar* ButtonBar() const;
 			PToolBar* ToolBar() const;
-	
+
 			void MakeWorksheet();
 			bool IsWorksheet();
 static		PDoc* GetWorksheet();
-			
+
 			bool IsSourceFile();
 			bool IsHeaderFile();
 			void OpenPartner();
@@ -112,7 +113,7 @@
 			template <class T>
 			void GetDialog(T*& dlog)
 			{
-				vector<HDialog*>::iterator i = 
+				vector<HDialog*>::iterator i =
 					find_if(fDialogs.begin(), fDialogs.end(), PDialog<T>());
 				if (i != fDialogs.end())
 				{
@@ -148,7 +149,7 @@
 			void InitWindow(const char *name);
 
 virtual		void MenusBeginning();
-			
+
 			void OpenSelection();
 public:
 			void OpenInclude(const char *incl);

Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/PText.cpp	2009-05-05 01:34:24 UTC (rev 575)
@@ -240,6 +240,10 @@
 	fMainPopUp->SetFont(be_plain_font);
 	fMainPopUp->SetRadioMode(false);
 
+	fHighlightCursor = -1;
+	fHighlightChangeCounter = -1;
+	fHighlightPart = -1;
+
 	ReInit();
 } /* PText::PText */
 
@@ -1510,6 +1514,7 @@
 	if (kSplitMinimum > fSplitAt ||
 		b.Height() - kSplitMinimum < fSplitAt + kSplitterHeight)
 	{
+		int previousActivePart = fActivePart;
 		fActivePart = 2;
 		fVScrollBar2->SetValue(v);
 
@@ -1527,15 +1532,22 @@
 
 		TouchLines(floor(v / fLineHeight));
 		RedrawDirtyLines();
+
+		if (fActivePart != previousActivePart)
+			ActivePartChanged(previousActivePart);
 	}
 } /* PText::DoneMovingSplitter */
 
 void PText::SwitchPart(int newPart)
 {
+	int previousActivePart = fActivePart;
 	HideCaret();
 
 	fActivePart = newPart;
 	HiliteSelection();
+
+	if (fActivePart != previousActivePart)
+		ActivePartChanged(previousActivePart);
 } /* PText::SwitchPart */
 
 void PText::SplitWindow()
@@ -4845,6 +4857,37 @@
 		}
 	}
 
+	// draw the background for highlighted text
+	bool highlightsDrawn = false;
+	for (HighlightList::iterator it = fHighlights.begin();
+			it != fHighlights.end(); ++it)
+	{
+		HighlightInfo* highlight = *it;
+		if (highlight->fromOffset < e && highlight->toOffset >= s)
+		{
+			BRect r(E);
+
+			if (highlight->fromOffset > s)
+				r.left = Offset2Position(highlight->fromOffset).x - hv;
+			else
+				r.left = hv ? 0 : 3;
+
+			if (highlight->toOffset < e
+				|| (lineNr == LineCount() - 1
+					&& highlight->toOffset == fText.Size()))
+			{
+				r.right = Offset2Position(highlight->toOffset).x - hv;
+			}
+
+			vw->SetLowColor(gColor[kColorHighlight]);
+			vw->FillRect(r, B_SOLID_LOW);
+			highlightsDrawn = true;
+		}
+	}
+
+	if (highlightsDrawn)
+		vw->SetLowColor(gColor[kColorLow]);
+
 	int a, c;
 	a = min(fAnchor, fCaret);
 	c = max(fAnchor, fCaret);
@@ -5426,6 +5469,50 @@
 		Draw(b);
 } /* PText::ShiftLinesPart2 */
 
+void PText::InvalidateRange(int fromOffset, int toOffset, int part)
+{
+	if (fromOffset >= toOffset)
+		return;
+
+	// get bounds and vertical scroll offset of the part in question
+	float vScrollOffset = 0;
+	BRect bounds;
+
+	if (part == 1)
+	{
+		if (fSplitAt <= 0)
+			return;
+
+		bounds = fBounds;
+		bounds.bottom = fSplitAt - kSplitterHeight;
+		vScrollOffset = fVScrollBar1->Value();
+	}
+	else if (part == 2)
+	{
+		bounds = fBounds;
+		bounds.top = fSplitAt;
+		vScrollOffset = fVScrollBar2->Value();
+	}
+	else
+		return;
+
+	if (!bounds.IsValid())
+		return;
+
+	// We only invalidate complete lines.
+	int fromLine = Offset2Line(fromOffset);
+	int toLine = Offset2Line(toOffset - 1);
+
+	// compute the invalidation rect and invalidate it
+	float fromY = ceil(fLineHeight * fromLine - vScrollOffset);
+	float toY = fromY + ceil((toLine + 1 - fromLine) * fLineHeight);
+	float hScrollOffset = fHScrollBar->Value();
+	BRect rect(hScrollOffset, fromY + 1, hScrollOffset + fBounds.Width(),
+		toY);
+	Invalidate(rect & bounds.OffsetByCopy(hScrollOffset, 0));
+}
+
+
 // #pragma mark - Printing
 
 struct PrintFunctionRef {
@@ -6052,6 +6139,7 @@
 				if (fSplitAt > 0)
 				{
 					HideCaret();
+					int previousActivePart = fActivePart;
 					fActivePart = (fActivePart == 1) ? 2 : 1;
 
 					int a, c;
@@ -6062,6 +6150,9 @@
 					fOPCaret = c;
 					fOPAnchor = a;
 					std::swap(fMark, fOPMark);
+
+					if (fActivePart != previousActivePart)
+						ActivePartChanged(previousActivePart);
 				}
 				else
 					beep();
@@ -6485,3 +6576,112 @@
 	ReInit();
 	Invalidate();
 } /* PText::ChangedInfo */
+
+
+// #pragma mark - Highlighting
+
+void PText::SelectionChanged(int oldAnchor, int oldCaret)
+{
+	int newCursor = fAnchor == fCaret ? fAnchor : -1;
+	if (newCursor != fHighlightCursor)
+		UpdateBraceHighlights();
+}
+
+void PText::TextBufferChanged()
+{
+	if (fText.ChangeCounter() != fHighlightChangeCounter)
+		UpdateBraceHighlights();
+}
+
+void PText::ActivePartChanged(int oldActivePart)
+{
+	if (fActivePart != fHighlightPart)
+		UpdateBraceHighlights();
+}
+
+void PText::UpdateBraceHighlights()
+{
+	// invalidate the old highlights
+	if (fBraceHighlight1.fromOffset >= 0) {
+		InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset,
+			fHighlightPart);
+		fBraceHighlight1.fromOffset = -1;
+		fHighlights.remove(&fBraceHighlight1);
+	}
+
+	if (fBraceHighlight2.fromOffset >= 0) {
+		InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset,
+			fHighlightPart);
+		fBraceHighlight2.fromOffset = -1;
+		fHighlights.remove(&fBraceHighlight2);
+	}
+
+	fHighlightCursor = fAnchor == fCaret ? fAnchor : -1;
+	fHighlightChangeCounter = fText.ChangeCounter();
+	fHighlightPart = fActivePart;
+
+	if (!gBalance)
+		return;
+
+	// If we have a selection, there's nothing to highlight
+	if (fHighlightCursor < 0)
+		return;
+
+	// Check whether the cursor touches a parenthesis/bracket/brace
+	char charBefore = fHighlightCursor > 0
+		? fText[fHighlightCursor - 1] : 0;
+	char charAfter = fHighlightCursor < fText.Size()
+		? fText[fHighlightCursor] : 0;
+	int offset = -1;
+	int direction = 1;
+	if (charBefore == ')' || charBefore == ']' || charBefore == '}'
+		|| charBefore == '>')
+	{
+		// match opening counterpart
+		offset = fHighlightCursor - 1;
+		direction = -1;
+	}
+	else if (charAfter == '(' || charAfter == '[' || charAfter == '{'
+		|| charAfter == '<')
+	{
+		// match closing counterpart
+		offset = fHighlightCursor;
+	}
+	else if (charBefore == '(' || charBefore == '[' || charBefore == '{'
+		|| charBefore == '<')
+	{
+		// match closing counterpart
+		offset = fHighlightCursor - 1;
+	}
+	else if (charAfter == ')' || charAfter == ']' || charAfter == '}'
+		|| charAfter == '>')
+	{
+		// match opening counterpart
+		offset = fHighlightCursor;
+		direction = -1;
+	}
+	else
+		return;
+
+	// find the other
+	int otherOffset = FindTheOther(offset + (direction > 0 ? 1 : 0),
+		fText[offset]);
+	if (otherOffset < 0)
+		return;
+
+	if (direction < 0)
+		otherOffset--;
+
+	// update the highlights
+	fBraceHighlight1.fromOffset = offset;
+	fBraceHighlight1.toOffset = fBraceHighlight1.fromOffset + 1;
+	fHighlights.push_back(&fBraceHighlight1);
+	InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset,
+		fHighlightPart);
+
+	fBraceHighlight2.fromOffset = otherOffset;
+	fBraceHighlight2.toOffset = fBraceHighlight2.fromOffset + 1;
+	fHighlights.push_back(&fBraceHighlight2);
+	InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset,
+		fHighlightPart);
+}

Modified: trunk/Sources/PText.h
===================================================================
--- trunk/Sources/PText.h	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/PText.h	2009-05-05 01:34:24 UTC (rev 575)
@@ -1,8 +1,8 @@
 /*	$Id$
-	
+
 	Copyright 1996, 1997, 1998, 2002
 	        Hekkelman Programmatuur B.V.  All rights reserved.
-	
+
 	Redistribution and use in source and binary forms, with or without
 	modification, are permitted provided that the following conditions are met:
 	1. Redistributions of source code must retain the above copyright notice,
@@ -12,13 +12,13 @@
 	   and/or other materials provided with the distribution.
 	3. All advertising materials mentioning features or use of this software
 	   must display the following acknowledgement:
-	   
+
 	    This product includes software developed by Hekkelman Programmatuur B.V.
-	
+
 	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
 	   promote products derived from this software without specific prior
 	   written permission.
-	
+
 	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
@@ -28,7 +28,7 @@
 	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 #ifndef PTEXT_H
@@ -36,6 +36,8 @@
 
 typedef float g_unit_t;
 
+#include <list>
+
 #include <Messenger.h>
 #include <View.h>
 
@@ -62,7 +64,7 @@
 	unsigned char state		: 8;
 	unsigned char dirty		: 1;
 	unsigned char nl		: 1;
-	
+
 	LineInfo() { start = state = dirty = nl = 0; };
 	LineInfo(int nStart, int nState, bool nNl = true)
 		: start(nStart), state(nState), dirty(1), nl(nNl) {};
@@ -73,7 +75,7 @@
 	short classCnt;
 	unsigned char classMap[256];
 	short forwardCnt;
-	unsigned char forwardTable[1]; 
+	unsigned char forwardTable[1];
 };
 
 typedef vector<LineInfo> VLineInfo;
@@ -91,14 +93,14 @@
 };
 
 public:
-			PText(BRect frame, PTextBuffer& txt, BScrollBar *bars[], 
+			PText(BRect frame, PTextBuffer& txt, BScrollBar *bars[],
 				  const char *ext);
 			~PText();
 
 			void ReInit();
 
 			void SetStatus(PStatus *status);
-		
+
 virtual		void AttachedToWindow();
 
 virtual		void Draw(BRect updateRect);
@@ -117,7 +119,7 @@
 			void Pulse();
 
 			void HandleDrop(BMessage *msg);
-			
+
 			void ProcessCommand(unsigned long what, void *param);
 
 			void SetText(const char *utf8Text, size_t size);
@@ -137,17 +139,17 @@
 			void FontChanged(bool reInit = true);
 
 			void ChangedInfo(BMessage *msg);
-			
+
 			void GetSelectedText(char*& s, bool extend = false);
 			void CopyBlock(char*& s, int from, int to);
 
 			bool WaitMouseMoved(BPoint where);
 			void ShowContextualMenu(BPoint where);
 			void ShowFunctionMenu(BPoint where, int which);
-			
+
 			void SetDirty(bool dirty);
 			bool IsDirty();
-		
+
 			void AdjustScrollBars();
 			void ScrollBarChanged(BScrollBar *bar, g_unit_t newValue);
 			void ScrollToCaret(bool keepContext);
@@ -156,7 +158,7 @@
 	virtual	void ScrollTo(BPoint p);
 
 			void ShowTabStops(bool show);
-	
+
 			void DrawLine(int lineNr, g_unit_t y, bool buffer);
 //			void DrawString(BView *v, const char *buf, int size, float hv, float& x, float y);
 			void RedrawDirtyLines();
@@ -166,7 +168,8 @@
 			void DrawCaret();
 			void HideCaret();
 			void ShowCaret();
-			
+			void InvalidateRange(int fromOffset, int toOffset, int part);
+
 			status_t PageSetup();
 			status_t Print();
 
@@ -184,7 +187,7 @@
 			void SmartBrace();
 			void ScanForFunctions(CFunctionScanHandler& handler);
 			void HashLines(vector<int>& hv, bool ignoreCase, bool ignoreWhite);
-			
+
 			int Offset2Line(int offset);
 			BPoint Offset2Position(int offset, int part = -1);
 			int LinePosition2Offset(int line, g_unit_t position);
@@ -198,55 +201,55 @@
 			int Offset2Column(int offset);
 			int Column2Offset(int lineNr, int column);
 			int RealLine2Line(int lineNr);
-			
+
 			// block select mode:
 			bool IsFixedFont() const;
 			bool IsBlockSelect() const				{ return fBlockSelect; }
 			void SetBlockSelect(bool block)			{ fBlockSelect = block; }
 			void BlockOffsetsForLine(int lineNr, int& startOffset, int& endOffset);
-			
+
 			void Selection2Region(BRegion& rgn, int part = -1);
 			void ChangeSelection(int newAnchor, int newCaret, bool block = false);
 			void SelectLine(int lineNr);
 			void SelectParagraph();
 			void InvertRegion(BRegion& rgn);
-	
+
 			void CharKeyDown(const char *bytes, int numBytes);
 			void BackspaceKeyDown();
 			void DeleteKeyDown();
 			void GlossaryKey(int ch, int modifiers);
 			void GlossaryButton(const char *glossy);
-			
+
 			g_unit_t TextWidth(int offset, int len) const;
 			g_unit_t StringWidth(const char *buf, int len) const;
-			
+
 			void Insert(const char *text, int textLen, int offset);
 			void Delete(int from, int to);
 			void RestyleDirtyLines(int from);
 			void TextChanged(int from, int to);
 			void TypeString(const char *string);
-			
+
 			void Cut(int append = 0);
 			void Copy(int append = 0);
 			void Paste();
 			void Clear();
-			
+
 			void TouchLine(int lineNr);
 			void TouchLines(int from, int to = -1);
-		
+
 			int Anchor();
 			int Caret();
 			void SetCaret(int newCaret);
 			void SetMark(int offset);
 			void Select(int anchor, int caret, bool update, bool block);
 			void CenterSelection();
-			
+
 			void RegisterCommand(PCmd *cmd);
 			void Undo();
 			void Redo();
 			void ResetUndo();
 			void FlushUndo();
-			
+
 			void Find(unsigned long msg, void *args);
 			bool CanReplace(const char *s, bool ignoreCase, bool regx);
 			bool FindNext(const char *what, int& offset, bool ignoreCase,
@@ -255,10 +258,10 @@
 			bool IsIncSearching() const;
 			void DoIncSearch(bool forward);
 			void IncSearchKey(const char *bytes, int numBytes);
-			
+
 			void JumpToFunction(const char *func, int offset);
 			void FindNextError(bool backward);
-			
+
 			void ExecuteSelection();
 			void KillCurrentJob();
 			void PrepareForOutput();
@@ -266,7 +269,7 @@
 			const char *GetCWD() const;
 			void SendTextToJob(const char *txt);
 			void SetErrorWindow(PErrorWindow *window);
-			
+
 			void SetSplitter(PSplitter *splitter);
 			void TrackSplitter(BPoint where);
 			void SplitterMoved(g_unit_t dy);
@@ -274,7 +277,7 @@
 			void SplitWindow();
 			void UnsplitWindow();
 			void SwitchPart(int toPart);
-		
+
 			const PTextBuffer& TextBuffer() const;
 			const char* FindString() const;
 			const char* ReplaceString() const;
@@ -288,6 +291,11 @@
 			int WrapWidth() const;
 			PDoc* Doc() const;
 
+			void SelectionChanged(int oldAnchor, int oldCaret);
+			void TextBufferChanged();
+			void ActivePartChanged(int oldActivePart);
+			void UpdateBraceHighlights();
+
 private:
 			void VerticallyScrollToSelection(int startOffset,
 											 int endOffset,
@@ -302,7 +310,7 @@
 			BRect PartBounds(int part);
 			bool OffsetIsOutsideOfContextArea(int32 offset);
 			void NavigateOverFunctions(char direction);
-			
+
 			BBitmap *fLineMap;
 			BView	*fLineView;
 			BFont fFont;
@@ -355,12 +363,30 @@
 			float fDefaultCharWidth;
 			BMessage *fPrintSettings;
 			BMessenger fErrorWindowMessenger;
-		
+
 static		PText *sfDragSource;
 
 			rgb_color fLowColor, fTextColor;
 			rgb_color fKeywordColor, fStringColor, fCommentColor;
 
+			struct HighlightInfo {
+				HighlightInfo()
+					: fromOffset(-1)
+				{
+				}
+
+				int	fromOffset;
+				int toOffset;
+			};
+			typedef std::list<HighlightInfo*> HighlightList;
+
+			int fHighlightCursor;
+			int fHighlightChangeCounter;
+			int fHighlightPart;
+			HighlightInfo fBraceHighlight1;
+			HighlightInfo fBraceHighlight2;
+			HighlightList fHighlights;
+
 // saveable settings
 			int fTabStops;
 			char *fCWD;
@@ -483,8 +509,8 @@
 
 inline void PText::ProcessCommand(unsigned long what, void *param)
 {
-	BMessage msg(what); 
-	msg.AddPointer("param", param); 
+	BMessage msg(what);
+	msg.AddPointer("param", param);
 	BMessenger(this).SendMessage(&msg);
 }
 

Modified: trunk/Sources/PrefControls.h
===================================================================
--- trunk/Sources/PrefControls.h	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/PrefControls.h	2009-05-05 01:34:24 UTC (rev 575)
@@ -16,6 +16,7 @@
 #define pnm_Col_C_Text					"txtc"
 #define pnm_Col_C_Selection				"selc"
 #define pnm_Col_C_Mark					"mrkc"
+#define pnm_Col_C_Highlight				"hilc"
 #define pnm_Col_C_Keyword1				"keyc"
 #define pnm_Col_C_Keyword2				"ke2c"
 #define pnm_Col_C_Comment1				"cmtc"

Modified: trunk/Sources/Prefs.h
===================================================================
--- trunk/Sources/Prefs.h	2009-05-05 01:26:08 UTC (rev 574)
+++ trunk/Sources/Prefs.h	2009-05-05 01:34:24 UTC (rev 575)
@@ -25,6 +25,7 @@
 const char* const prf_C_Comment2				= "alt comment color";
 const char* const prf_C_Error1					= "error color";
 const char* const prf_C_Error2					= "alt error color";
+const char* const prf_C_Highlight				= "highlight color";
 const char* const prf_C_IdentifierSystem		= "system identifier color";
 const char* const prf_C_IdentifierUser			= "user identifier color";
 const char* const prf_C_Invisibles				= "invisibles color";



From stippi at mail.berlios.de  Tue May  5 10:11:41 2009
From: stippi at mail.berlios.de (stippi at BerliOS)
Date: Tue, 5 May 2009 10:11:41 +0200
Subject: [pe-commits] r576 - trunk/Sources
Message-ID: <200905050811.n458BfMc022035@sheep.berlios.de>

Author: stippi
Date: 2009-05-05 10:11:41 +0200 (Tue, 05 May 2009)
New Revision: 576
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=576&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
Use B_OP_OVER for text rendering within a line that has highlights. This avoids
having to track the low color for the highlights as well, as is already done
for the selection.


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2009-05-05 01:34:24 UTC (rev 575)
+++ trunk/Sources/PText.cpp	2009-05-05 08:11:41 UTC (rev 576)
@@ -4886,7 +4886,10 @@
 	}
 
 	if (highlightsDrawn)
+	{
+		vw->SetDrawingMode(B_OP_OVER);
 		vw->SetLowColor(gColor[kColorLow]);
+	}
 
 	int a, c;
 	a = min(fAnchor, fCaret);
@@ -5168,6 +5171,10 @@
 		vw->SetHighColor(kBlack);
 	}
 
+	// restore B_OP_COPY if necessary
+	if (highlightsDrawn)
+		vw->SetDrawingMode(B_OP_COPY);
+
 	if (buffer)
 	{
 		fLineView->Sync();



From hoern at mail.berlios.de  Tue May  5 11:49:30 2009
From: hoern at mail.berlios.de (hoern at BerliOS)
Date: Tue, 5 May 2009 11:49:30 +0200
Subject: [pe-commits] r577 - trunk/Sources
Message-ID: <200905050949.n459nU9D002113@sheep.berlios.de>

Author: hoern
Date: 2009-05-05 11:49:30 +0200 (Tue, 05 May 2009)
New Revision: 577
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=577&view=rev

Modified:
   trunk/Sources/CDocIO.cpp
Log:
Patch to make it compile on R5

Modified: trunk/Sources/CDocIO.cpp
===================================================================
--- trunk/Sources/CDocIO.cpp	2009-05-05 08:11:41 UTC (rev 576)
+++ trunk/Sources/CDocIO.cpp	2009-05-05 09:49:30 UTC (rev 577)
@@ -787,10 +787,16 @@
 			return true;
 
 		// compare the file size
+#if defined(__HAIKU__)
 		off_t fileSize;
 		if (file.GetSize(&fileSize) != B_OK || fileSize != docText.Length())
 			return true;
+#else
+		if (file.Seek(0, SEEK_END) != docText.Length())
+			return true;
+#endif
 
+
 		// allocate a read buffer
 		static const size_t kBufferSize = 64 * 1024;
 		struct Buffer {



From ingo_weinhold at gmx.de  Tue May  5 13:55:30 2009
From: ingo_weinhold at gmx.de (Ingo Weinhold)
Date: Tue, 05 May 2009 13:55:30 +0200
Subject: [pe-commits] r576 - trunk/Sources
In-Reply-To: <200905050811.n458BfMc022035@sheep.berlios.de>
References: <200905050811.n458BfMc022035@sheep.berlios.de>
Message-ID: <20090505135530.369.1@knochen-vm.localdomain>


On 2009-05-05 at 10:11:41 [+0200], stippi at BerliOS <stippi at mail.berlios.de> 
wrote:
> Author: stippi
> Date: 2009-05-05 10:11:41 +0200 (Tue, 05 May 2009)
> New Revision: 576
> ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=576&view=rev
> 
> Modified:
>    trunk/Sources/PText.cpp
> Log:
> Use B_OP_OVER for text rendering within a line that has highlights. This 
> avoids
> having to track the low color for the highlights as well, as is already done
> for the selection.

Cool, thanks! I wondered how to best solve this, but I was too tired to look 
into it last night. :-)

CU, Ingo


From ingo_weinhold at gmx.de  Tue May  5 14:12:01 2009
From: ingo_weinhold at gmx.de (Ingo Weinhold)
Date: Tue, 05 May 2009 14:12:01 +0200
Subject: [pe-commits] r576 - trunk/Sources
In-Reply-To: <4A002DD2.7040300@gmx.de>
References: <200905050811.n458BfMc022035@sheep.berlios.de>
	<20090505135530.369.1@knochen-vm.localdomain> <4A002DD2.7040300@gmx.de>
Message-ID: <20090505141201.522.2@knochen-vm.localdomain>


On 2009-05-05 at 14:15:14 [+0200], Stephan A?mus <superstippi at gmx.de> wrote:
> Ingo Weinhold schrieb:
> > On 2009-05-05 at 10:11:41 [+0200], stippi at BerliOS 
> > <stippi at mail.berlios.de>
> > wrote:
> >> Author: stippi
> >> Date: 2009-05-05 10:11:41 +0200 (Tue, 05 May 2009)
> >> New Revision: 576
> >> ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=576&view=rev
> >>
> >> Modified:
> >>    trunk/Sources/PText.cpp
> >> Log:
> >> Use B_OP_OVER for text rendering within a line that has highlights. This
> >> avoids
> >> having to track the low color for the highlights as well, as is already 
> >> done
> >> for the selection.
> > 
> > Cool, thanks! I wondered how to best solve this, but I was too tired to 
> > look
> > into it last night. :-)
> 
> In theory, we could skip a lot of SetLowColor() later on if we already
> changed the drawing mode to B_OP_OVER, but I was/am too lazy to look
> into it. Much potential for screw up...

I wondered about that too, but I guess B_OP_OVER wasn't used in the first 
place for performance reasons. Though I guess on today's computers it 
wouldn't make much of a difference anyway, particularly under Haiku.

CU, Ingo


From ingo_weinhold at gmx.de  Tue May  5 16:44:58 2009
From: ingo_weinhold at gmx.de (Ingo Weinhold)
Date: Tue, 05 May 2009 16:44:58 +0200
Subject: [pe-commits] r576 - trunk/Sources
In-Reply-To: <4A00364C.4010208@gmx.de>
References: <200905050811.n458BfMc022035@sheep.berlios.de>
	<20090505135530.369.1@knochen-vm.localdomain> <4A002DD2.7040300@gmx.de>
	<20090505141201.522.2@knochen-vm.localdomain> <4A00364C.4010208@gmx.de>
Message-ID: <20090505164458.428.1@knochen-vm.localdomain>


On 2009-05-05 at 14:51:24 [+0200], Stephan A?mus <superstippi at gmx.de> wrote:
> Ingo Weinhold schrieb:
> > On 2009-05-05 at 14:15:14 [+0200], Stephan A?mus <superstippi at gmx.de> 
> > wrote:
> >> Ingo Weinhold schrieb:
> >>> On 2009-05-05 at 10:11:41 [+0200], stippi at BerliOS
> >>> <stippi at mail.berlios.de>
> >>> wrote:
> >>>> Author: stippi
> >>>> Date: 2009-05-05 10:11:41 +0200 (Tue, 05 May 2009)
> >>>> New Revision: 576
> >>>> ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=576&view=rev
> >>>>
> >>>> Modified:
> >>>>    trunk/Sources/PText.cpp
> >>>> Log:
> >>>> Use B_OP_OVER for text rendering within a line that has highlights. 
> >>>> This
> >>>> avoids
> >>>> having to track the low color for the highlights as well, as is already
> >>>> done
> >>>> for the selection.
> >>> Cool, thanks! I wondered how to best solve this, but I was too tired to
> >>> look
> >>> into it last night. :-)
> >> In theory, we could skip a lot of SetLowColor() later on if we already
> >> changed the drawing mode to B_OP_OVER, but I was/am too lazy to look
> >> into it. Much potential for screw up...
> > 
> > I wondered about that too, but I guess B_OP_OVER wasn't used in the first
> > place for performance reasons. Though I guess on today's computers it
> > wouldn't make much of a difference anyway, particularly under Haiku.
> 
> On BeOS B_OP_COPY is like seven or eight times faster than B_OP_OVER. On
> Haiku, it's about 6% faster. Maybe after more optimizations in the
> app_server our B_OP_COPY gains some speed over B_OP_OVER...
> 
> I figured my solution is ok for BeOS, since B_OP_OVER is only turned on
> for one line and the check is cheap.

Sure, I wasn't complaining, just noticing. :-)

> However, I would rather have brackets highlighted via the text than via
> the background color. Somehow I find there is a bit too much "visual
> disturbance" going on when moving the cursor in the text now. It could
> possibly be fixed with a tiny delay so brackets don't flash when just
> moving the cursor and passing by. But maybe it would be more
> esthetically pleasing anyways to use the text color. I realize however,
> after having looked at the code, that that would be much more involved.

Personally I'm fine with how it works ATM. Adding a short delay before 
highlighting might make it even nicer -- would have to see how that works in 
practice -- but since the highlight color doesn't contrast too much with the 
background color I don't really find the "visual noise" irritating.

Regarding using the text color for highlighting, I'm not sure whether that 
would be constrasty enough. Particularly when looking for matching braces of 
C if/for/... blocks, having the whole cell highlighted probably makes it 
easier to spot.

Anyway, I don't think I'll touch the code for the time being, so feel free to 
play with it. Neither of your suggestions should be complicated to implement. 
Using the text color is merely about manipulating the syntax coloring arrays 
one gets from the language add-on. The delay can be done with a message 
runner and an additional flag indicating whether the highlights are already 
active.

CU, Ingo

PS: BTW, your replies went off-list so far. The list server doesn't do 
Reply-To munging.


From bonefish at mail.berlios.de  Tue May  5 19:03:38 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Tue, 5 May 2009 19:03:38 +0200
Subject: [pe-commits] r578 - trunk/Sources
Message-ID: <200905051703.n45H3cP8016037@sheep.berlios.de>

Author: bonefish
Date: 2009-05-05 19:03:37 +0200 (Tue, 05 May 2009)
New Revision: 578
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=578&view=rev

Modified:
   trunk/Sources/CDocIO.cpp
   trunk/Sources/CDocIO.h
Log:
Changed _HasFileContentsChanged() parameter to BFile instead of BPositionIO and
removed the Haiku/BeOS specific handling to get the file size.


Modified: trunk/Sources/CDocIO.cpp
===================================================================
--- trunk/Sources/CDocIO.cpp	2009-05-05 09:49:30 UTC (rev 577)
+++ trunk/Sources/CDocIO.cpp	2009-05-05 17:03:37 UTC (rev 578)
@@ -770,7 +770,7 @@
 	return result;
 }
 
-bool CLocalDocIO::_HasFileContentsChanged(BPositionIO& file)
+bool CLocalDocIO::_HasFileContentsChanged(BFile& file)
 {
 	// We determine whether the file contents changed by preparing the current
 	// text for saving and compare it with the file. If anything fails, we
@@ -787,16 +787,10 @@
 			return true;
 
 		// compare the file size
-#if defined(__HAIKU__)
 		off_t fileSize;
 		if (file.GetSize(&fileSize) != B_OK || fileSize != docText.Length())
 			return true;
-#else
-		if (file.Seek(0, SEEK_END) != docText.Length())
-			return true;
-#endif
 
-
 		// allocate a read buffer
 		static const size_t kBufferSize = 64 * 1024;
 		struct Buffer {

Modified: trunk/Sources/CDocIO.h
===================================================================
--- trunk/Sources/CDocIO.h	2009-05-05 09:49:30 UTC (rev 577)
+++ trunk/Sources/CDocIO.h	2009-05-05 17:03:37 UTC (rev 578)
@@ -87,7 +87,7 @@
 	virtual	void StartWatchingFolder(void);
 	virtual	void StopWatchingFolder(void);
 
-			bool _HasFileContentsChanged(BPositionIO& file);
+			bool _HasFileContentsChanged(BFile& file);
 
 			entry_ref *fEntryRef;
 			node_ref fNodeRef;



From bonefish at mail.berlios.de  Tue May  5 20:24:21 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Tue, 5 May 2009 20:24:21 +0200
Subject: [pe-commits] r579 - trunk/Sources
Message-ID: <200905051824.n45IOLIk010922@sheep.berlios.de>

Author: bonefish
Date: 2009-05-05 20:24:21 +0200 (Tue, 05 May 2009)
New Revision: 579
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=579&view=rev

Modified:
   trunk/Sources/PDoc.cpp
   trunk/Sources/PText.cpp
   trunk/Sources/PText.h
Log:
* PText::InvalidateRange(): Fixed the computation of the invalidation rect.
* Added PText::InvalidateRange() version without the part parameter.
* Remove PText::SelectionChanged() parameters. They aren't always that easy to
  come by and aren't needed anyway.
* Changed the parenthesis/bracket/brace highlighting to happen in both editing
  parts. That did already happen by accident (respectively ignorance) in
  PText::DrawLines(), but invalidation happened only in the active part. I
  intended to restrict brace highlighting to the active part, but the "magic"
  PText::RedrawDirtyLines() uses would make that pretty hairy.
* Trigger the brace highlighting on window creation. The highlights would be
  missing before.
* Actively call PText::SelectionChanged() in PText::MouseDown() when doing the
  GetMouse() loop. Otherwise the highlights wouldn't be invalidated until
  releasing the mouse.


Modified: trunk/Sources/PDoc.cpp
===================================================================
--- trunk/Sources/PDoc.cpp	2009-05-05 17:03:37 UTC (rev 578)
+++ trunk/Sources/PDoc.cpp	2009-05-05 18:24:21 UTC (rev 579)
@@ -110,6 +110,7 @@
 			AddRecent(path.Path());
 
 		NameChanged();
+		fText->TextBufferChanged();
 	}
 
 	fButtonBar->SetEnabled(msg_Save, false);
@@ -1241,7 +1242,7 @@
 	inherited::DispatchMessage(message, handler);
 
 	if (fText->Anchor() != anchor || fText->Caret() != caret)
-		fText->SelectionChanged(anchor, caret);
+		fText->SelectionChanged();
 
 	if (fText->TextBuffer().ChangeCounter() != changeCounter)
 		fText->TextBufferChanged();

Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2009-05-05 17:03:37 UTC (rev 578)
+++ trunk/Sources/PText.cpp	2009-05-05 18:24:21 UTC (rev 579)
@@ -242,7 +242,6 @@
 
 	fHighlightCursor = -1;
 	fHighlightChangeCounter = -1;
-	fHighlightPart = -1;
 
 	ReInit();
 } /* PText::PText */
@@ -2046,6 +2045,8 @@
 
 		fStatus->SetOffset(fCaret);
 
+		SelectionChanged();
+
 		g_unit_t v = -1;
 		BPoint cur;
 
@@ -2065,6 +2066,7 @@
 						curOffset = LineStart(Offset2Line(curOffset));
 
 					ChangeSelection(max(anchor2, curOffset), min(anchor1, curOffset), modifiers & B_OPTION_KEY);
+					SelectionChanged();
 				}
 				else if (curOffset > anchor2)
 				{
@@ -2078,6 +2080,7 @@
 					}
 
 					ChangeSelection(min(anchor1, curOffset), max(anchor2, curOffset), modifiers & B_OPTION_KEY);
+					SelectionChanged();
 				}
 
 				v = fActivePart == 1 ? fVScrollBar1->Value() : fVScrollBar2->Value();
@@ -5511,7 +5514,7 @@
 	int toLine = Offset2Line(toOffset - 1);
 
 	// compute the invalidation rect and invalidate it
-	float fromY = ceil(fLineHeight * fromLine - vScrollOffset);
+	float fromY = bounds.top + ceil(fLineHeight * fromLine - vScrollOffset);
 	float toY = fromY + ceil((toLine + 1 - fromLine) * fLineHeight);
 	float hScrollOffset = fHScrollBar->Value();
 	BRect rect(hScrollOffset, fromY + 1, hScrollOffset + fBounds.Width(),
@@ -5519,7 +5522,13 @@
 	Invalidate(rect & bounds.OffsetByCopy(hScrollOffset, 0));
 }
 
+void PText::InvalidateRange(int fromOffset, int toOffset)
+{
+	InvalidateRange(fromOffset, toOffset, 1);
+	InvalidateRange(fromOffset, toOffset, 2);
+}
 
+
 // #pragma mark - Printing
 
 struct PrintFunctionRef {
@@ -6587,7 +6596,7 @@
 
 // #pragma mark - Highlighting
 
-void PText::SelectionChanged(int oldAnchor, int oldCaret)
+void PText::SelectionChanged()
 {
 	int newCursor = fAnchor == fCaret ? fAnchor : -1;
 	if (newCursor != fHighlightCursor)
@@ -6602,30 +6611,25 @@
 
 void PText::ActivePartChanged(int oldActivePart)
 {
-	if (fActivePart != fHighlightPart)
-		UpdateBraceHighlights();
 }
 
 void PText::UpdateBraceHighlights()
 {
 	// invalidate the old highlights
 	if (fBraceHighlight1.fromOffset >= 0) {
-		InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset,
-			fHighlightPart);
+		InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset);
 		fBraceHighlight1.fromOffset = -1;
 		fHighlights.remove(&fBraceHighlight1);
 	}
 
 	if (fBraceHighlight2.fromOffset >= 0) {
-		InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset,
-			fHighlightPart);
+		InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset);
 		fBraceHighlight2.fromOffset = -1;
 		fHighlights.remove(&fBraceHighlight2);
 	}
 
 	fHighlightCursor = fAnchor == fCaret ? fAnchor : -1;
 	fHighlightChangeCounter = fText.ChangeCounter();
-	fHighlightPart = fActivePart;
 
 	if (!gBalance)
 		return;
@@ -6683,12 +6687,10 @@
 	fBraceHighlight1.fromOffset = offset;
 	fBraceHighlight1.toOffset = fBraceHighlight1.fromOffset + 1;
 	fHighlights.push_back(&fBraceHighlight1);
-	InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset,
-		fHighlightPart);
+	InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset);
 
 	fBraceHighlight2.fromOffset = otherOffset;
 	fBraceHighlight2.toOffset = fBraceHighlight2.fromOffset + 1;
 	fHighlights.push_back(&fBraceHighlight2);
-	InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset,
-		fHighlightPart);
+	InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset);
 }

Modified: trunk/Sources/PText.h
===================================================================
--- trunk/Sources/PText.h	2009-05-05 17:03:37 UTC (rev 578)
+++ trunk/Sources/PText.h	2009-05-05 18:24:21 UTC (rev 579)
@@ -169,6 +169,7 @@
 			void HideCaret();
 			void ShowCaret();
 			void InvalidateRange(int fromOffset, int toOffset, int part);
+			void InvalidateRange(int fromOffset, int toOffset);
 
 			status_t PageSetup();
 			status_t Print();
@@ -291,7 +292,7 @@
 			int WrapWidth() const;
 			PDoc* Doc() const;
 
-			void SelectionChanged(int oldAnchor, int oldCaret);
+			void SelectionChanged();
 			void TextBufferChanged();
 			void ActivePartChanged(int oldActivePart);
 			void UpdateBraceHighlights();



From bonefish at mail.berlios.de  Tue May  5 22:02:38 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Tue, 5 May 2009 22:02:38 +0200
Subject: [pe-commits] r580 - trunk/Sources
Message-ID: <200905052002.n45K2cLp027125@sheep.berlios.de>

Author: bonefish
Date: 2009-05-05 22:02:38 +0200 (Tue, 05 May 2009)
New Revision: 580
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=580&view=rev

Modified:
   trunk/Sources/CFilterChoiceDialog.cpp
   trunk/Sources/CFilterChoiceDialog.h
   trunk/Sources/PFindFunctionDialog.cpp
   trunk/Sources/PFindFunctionDialog.h
Log:
Added missing copyright header -- I vaguely recall having written those files
originally. :-) Oliver might want to add his copyright as well.


Modified: trunk/Sources/CFilterChoiceDialog.cpp
===================================================================
--- trunk/Sources/CFilterChoiceDialog.cpp	2009-05-05 18:24:21 UTC (rev 579)
+++ trunk/Sources/CFilterChoiceDialog.cpp	2009-05-05 20:02:38 UTC (rev 580)
@@ -1,4 +1,7 @@
-// CFilterChoiceDialog.cpp
+/*
+ * Copyright 2004, Ingo Weinhold, ingo_weinhold at gmx.de.
+ * Distributed under the terms of the MIT License.
+ */
 
 #include <algorithm>
 #include <new>

Modified: trunk/Sources/CFilterChoiceDialog.h
===================================================================
--- trunk/Sources/CFilterChoiceDialog.h	2009-05-05 18:24:21 UTC (rev 579)
+++ trunk/Sources/CFilterChoiceDialog.h	2009-05-05 20:02:38 UTC (rev 580)
@@ -1,5 +1,7 @@
-// CFilterChoiceDialog.h
-
+/*
+ * Copyright 2004, Ingo Weinhold, ingo_weinhold at gmx.de.
+ * Distributed under the terms of the MIT License.
+ */
 #ifndef CFILTERCHOICEDIALOG_H
 #define CFILTERCHOICEDIALOG_H
 

Modified: trunk/Sources/PFindFunctionDialog.cpp
===================================================================
--- trunk/Sources/PFindFunctionDialog.cpp	2009-05-05 18:24:21 UTC (rev 579)
+++ trunk/Sources/PFindFunctionDialog.cpp	2009-05-05 20:02:38 UTC (rev 580)
@@ -1,4 +1,7 @@
-// PFindFunctionDialog.cpp
+/*
+ * Copyright 2004, Ingo Weinhold, ingo_weinhold at gmx.de.
+ * Distributed under the terms of the MIT License.
+ */
 
 #include <new>
 

Modified: trunk/Sources/PFindFunctionDialog.h
===================================================================
--- trunk/Sources/PFindFunctionDialog.h	2009-05-05 18:24:21 UTC (rev 579)
+++ trunk/Sources/PFindFunctionDialog.h	2009-05-05 20:02:38 UTC (rev 580)
@@ -1,5 +1,7 @@
-// PFindFunctionDialog.h
-
+/*
+ * Copyright 2004, Ingo Weinhold, ingo_weinhold at gmx.de.
+ * Distributed under the terms of the MIT License.
+ */
 #ifndef PFINDFUNCTIONDIALOG_H
 #define PFINDFUNCTIONDIALOG_H
 



From bonefish at mail.berlios.de  Tue May  5 23:10:49 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Tue, 5 May 2009 23:10:49 +0200
Subject: [pe-commits] r581 - trunk/Sources
Message-ID: <200905052110.n45LAnwn006620@sheep.berlios.de>

Author: bonefish
Date: 2009-05-05 23:10:46 +0200 (Tue, 05 May 2009)
New Revision: 581
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=581&view=rev

Modified:
   trunk/Sources/PText.cpp
   trunk/Sources/PText.h
Log:
* Introduced InvalidateLines() methods.
* Introduced LinesShifted() and PrepareForRedrawDirtyLines() hooks.
* Also store the line of a brace highlight. When the text changes the offset
  might no longer translate to the line where the highlight was drawn earlier.
  In LinesShifted() we adjust the line, since ShiftLines() uses CopyBits() to
  move lines graphically.
* Since RedrawDirtyLines() draws synchronously we need to update the brace
  highlights in PrepareForRedrawDirtyLines() if necessary.

This should (hopefully) solve all highlight related drawing artifacts.


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2009-05-05 20:02:38 UTC (rev 580)
+++ trunk/Sources/PText.cpp	2009-05-05 21:10:46 UTC (rev 581)
@@ -1334,6 +1334,8 @@
 	{
 		if (fSplitAt > 0) ShiftLines(line + 1, dy + fShift, 1);
 		ShiftLines(line + 1, dy + fShift, 2);
+
+		LinesShifted(line + 1, dy + fShift);
 	}
 
 	if (lc > LineCount() && fShift == 0)
@@ -5187,6 +5189,8 @@
 
 void PText::RedrawDirtyLines()
 {
+	PrepareForRedrawDirtyLines();
+
 	BRect b(fBounds);
 	int i;
 	float y1, y2;
@@ -5479,9 +5483,10 @@
 		Draw(b);
 } /* PText::ShiftLinesPart2 */
 
-void PText::InvalidateRange(int fromOffset, int toOffset, int part)
+/*!	Invalidates lines \a fromLine to \a toLine inclusively. */
+void PText::InvalidateLines(int fromLine, int toLine, int part)
 {
-	if (fromOffset >= toOffset)
+	if (fromLine > toLine)
 		return;
 
 	// get bounds and vertical scroll offset of the part in question
@@ -5509,10 +5514,6 @@
 	if (!bounds.IsValid())
 		return;
 
-	// We only invalidate complete lines.
-	int fromLine = Offset2Line(fromOffset);
-	int toLine = Offset2Line(toOffset - 1);
-
 	// compute the invalidation rect and invalidate it
 	float fromY = bounds.top + ceil(fLineHeight * fromLine - vScrollOffset);
 	float toY = fromY + ceil((toLine + 1 - fromLine) * fLineHeight);
@@ -5522,6 +5523,24 @@
 	Invalidate(rect & bounds.OffsetByCopy(hScrollOffset, 0));
 }
 
+void PText::InvalidateLines(int fromLine, int toLine)
+{
+	InvalidateLines(fromLine, toLine, 1);
+	InvalidateLines(fromLine, toLine, 2);
+}
+
+void PText::InvalidateRange(int fromOffset, int toOffset, int part)
+{
+	if (fromOffset >= toOffset)
+		return;
+
+	// We only invalidate complete lines.
+	int fromLine = Offset2Line(fromOffset);
+	int toLine = Offset2Line(toOffset - 1);
+
+	InvalidateLines(fromLine, toLine);
+}
+
 void PText::InvalidateRange(int fromOffset, int toOffset)
 {
 	InvalidateRange(fromOffset, toOffset, 1);
@@ -6613,17 +6632,35 @@
 {
 }
 
+void PText::LinesShifted(int first, int dy)
+{
+	if (fBraceHighlight1.fromOffset >= 0 && first <= fBraceHighlight1.line)
+		fBraceHighlight1.line += dy;
+	if (fBraceHighlight2.fromOffset >= 0 && first <= fBraceHighlight2.line)
+		fBraceHighlight2.line += dy;
+}
+
+void PText::PrepareForRedrawDirtyLines()
+{
+	int newCursor = fAnchor == fCaret ? fAnchor : -1;
+	if (newCursor != fHighlightCursor
+		|| fText.ChangeCounter() != fHighlightChangeCounter)
+	{
+		UpdateBraceHighlights();
+	}
+}
+
 void PText::UpdateBraceHighlights()
 {
 	// invalidate the old highlights
 	if (fBraceHighlight1.fromOffset >= 0) {
-		InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset);
+		InvalidateLines(fBraceHighlight1.line, fBraceHighlight1.line);
 		fBraceHighlight1.fromOffset = -1;
 		fHighlights.remove(&fBraceHighlight1);
 	}
 
 	if (fBraceHighlight2.fromOffset >= 0) {
-		InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset);
+		InvalidateLines(fBraceHighlight2.line, fBraceHighlight2.line);
 		fBraceHighlight2.fromOffset = -1;
 		fHighlights.remove(&fBraceHighlight2);
 	}
@@ -6686,11 +6723,13 @@
 	// update the highlights
 	fBraceHighlight1.fromOffset = offset;
 	fBraceHighlight1.toOffset = fBraceHighlight1.fromOffset + 1;
+	fBraceHighlight1.line = Offset2Line(fBraceHighlight1.fromOffset);
 	fHighlights.push_back(&fBraceHighlight1);
 	InvalidateRange(fBraceHighlight1.fromOffset, fBraceHighlight1.toOffset);
 
 	fBraceHighlight2.fromOffset = otherOffset;
 	fBraceHighlight2.toOffset = fBraceHighlight2.fromOffset + 1;
+	fBraceHighlight2.line = Offset2Line(fBraceHighlight2.fromOffset);
 	fHighlights.push_back(&fBraceHighlight2);
 	InvalidateRange(fBraceHighlight2.fromOffset, fBraceHighlight2.toOffset);
 }

Modified: trunk/Sources/PText.h
===================================================================
--- trunk/Sources/PText.h	2009-05-05 20:02:38 UTC (rev 580)
+++ trunk/Sources/PText.h	2009-05-05 21:10:46 UTC (rev 581)
@@ -170,6 +170,8 @@
 			void ShowCaret();
 			void InvalidateRange(int fromOffset, int toOffset, int part);
 			void InvalidateRange(int fromOffset, int toOffset);
+			void InvalidateLines(int fromLine, int toLine, int part);
+			void InvalidateLines(int fromLine, int toLine);
 
 			status_t PageSetup();
 			status_t Print();
@@ -295,6 +297,8 @@
 			void SelectionChanged();
 			void TextBufferChanged();
 			void ActivePartChanged(int oldActivePart);
+			void LinesShifted(int first, int dy);
+			void PrepareForRedrawDirtyLines();
 			void UpdateBraceHighlights();
 
 private:
@@ -381,11 +385,15 @@
 			};
 			typedef std::list<HighlightInfo*> HighlightList;
 
+			struct BraceHighlightInfo : HighlightInfo {
+				int	line;
+			};
+
 			int fHighlightCursor;
 			int fHighlightChangeCounter;
 			int fHighlightPart;
-			HighlightInfo fBraceHighlight1;
-			HighlightInfo fBraceHighlight2;
+			BraceHighlightInfo fBraceHighlight1;
+			BraceHighlightInfo fBraceHighlight2;
 			HighlightList fHighlights;
 
 // saveable settings



From ingo_weinhold at gmx.de  Wed May  6 00:42:12 2009
From: ingo_weinhold at gmx.de (Ingo Weinhold)
Date: Wed, 06 May 2009 00:42:12 +0200
Subject: [pe-commits] r581 - trunk/Sources
In-Reply-To: <200905052110.n45LAnwn006620@sheep.berlios.de>
References: <200905052110.n45LAnwn006620@sheep.berlios.de>
Message-ID: <20090506004212.2649.1@knochen-vm.localdomain>


On 2009-05-05 at 23:10:49 [+0200], bonefish at BerliOS 
<bonefish at mail.berlios.de> wrote:
> Author: bonefish
> Date: 2009-05-05 23:10:46 +0200 (Tue, 05 May 2009)
> New Revision: 581
> ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=581&view=rev
> 
> Modified:
>    trunk/Sources/PText.cpp
>    trunk/Sources/PText.h
> Log:
> * Introduced InvalidateLines() methods.
> * Introduced LinesShifted() and PrepareForRedrawDirtyLines() hooks.
> * Also store the line of a brace highlight. When the text changes the offset
>   might no longer translate to the line where the highlight was drawn 
>   earlier.
>   In LinesShifted() we adjust the line, since ShiftLines() uses CopyBits() 
>   to
>   move lines graphically.
> * Since RedrawDirtyLines() draws synchronously we need to update the brace
>   highlights in PrepareForRedrawDirtyLines() if necessary.
> 
> This should (hopefully) solve all highlight related drawing artifacts.

Under Haiku (not under BeOS, though) I can reproduce problems when scrolling 
is involved. E.g. in the following situation:

8< 8< 8< 8< 8<   view top    8< 8< 8< 8< 8< 8< 8<

[...]

{
}


8< 8< 8< 8< 8<  view bottom  8< 8< 8< 8< 8< 8< 8<

When the cursor is positioned after the "{" and Return is pressed, so that 
(a) the highlights should disappear and (b) the text is scrolled one line to 
keep the three lines context (the last two blank lines need to exists), the 
two lines with the braces disappear.

Since it works OK under BeOS I assume that's just a Haiku bug. Maybe even the 
same one that causes artifacts e.g. when scrolling column list views. Maybe 
someone is motivated to look into it. :-)

CU, Ingo


From hoern at mail.berlios.de  Wed May  6 17:05:38 2009
From: hoern at mail.berlios.de (hoern at BerliOS)
Date: Wed, 6 May 2009 17:05:38 +0200
Subject: [pe-commits] r582 - trunk/Extensions
Message-ID: <200905061505.n46F5cCA010685@sheep.berlios.de>

Author: hoern
Date: 2009-05-06 17:05:38 +0200 (Wed, 06 May 2009)
New Revision: 582
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=582&view=rev

Modified:
   trunk/Extensions/CopyContaining.cpp
   trunk/Extensions/CutContaining.cpp
Log:
* Bugfix: "Copy/Cut Lines Containing" now copy to the clipboard again
* Both should use less memory and execute a little bit faster


Modified: trunk/Extensions/CopyContaining.cpp
===================================================================
--- trunk/Extensions/CopyContaining.cpp	2009-05-05 21:10:46 UTC (rev 581)
+++ trunk/Extensions/CopyContaining.cpp	2009-05-06 15:05:38 UTC (rev 582)
@@ -131,77 +131,61 @@
 {
 	//  error checking
 
-	long	selStart;
+	long	selBeg;
 	long	selEnd;
 
 	if (sSelectionOnly)
 	{
-		addon->GetSelection(&selStart, &selEnd);
-		if (selEnd <= selStart)
+		addon->GetSelection(&selBeg, &selEnd);
+		if (selEnd <= selBeg)
 			return B_ERROR;
 	}
 	else
 	{
-		selStart = 0;
+		selBeg = 0;
 		selEnd = addon->TextLength();
 	}
 
 	//  set-up
 
-	const char *txt = addon->Text(), *ptr = txt + selStart;
-	int size = selEnd - selStart;
-
 	regex_t pb;
 	memset(&pb, 0, sizeof(pb));
 	int r = regcomp(&pb, sText, REG_EXTENDED);
 
 	if (r == REG_NOERROR)
 	{
-		//  perform operation into temporary buffer
+		BString clip;
+		BString line;
+		const char *txt = addon->Text()+selBeg;
+		int size = selEnd - selBeg;
+		int beg = 0;
+		int pos = -1;
+		int len;
 
-		char *new_text = new char[size + 1];
-		int ls = 0, li = 0, i = 0;
-
-		while (li <= size)
+		while (++pos <= size)
 		{
-			if (li == size || ptr[li] == '\n')
+			if ((pos == size || txt[pos] == '\n'))
 			{
-				new_text[i] = 0;
-
-				r = regexec(&pb, new_text + ls, 0, NULL, 0);
-
-				if (r == 0)
-				{
-					new_text[i] = '\n';
-					ls = i + 1;
+				if ((len = pos-beg) > 0) {
+					line.SetTo(txt+beg, len);
+					if (regexec(&pb, line.String(), 0, NULL, 0) == REG_NOERROR)
+					{
+						clip << line << '\n';
+					}
 				}
-				else if (r == REG_NOMATCH)
-					i = ls - 1;
-				else
-					break;
+				beg = pos + 1;
 			}
-			else
-				new_text[i] = ptr[li];
-
-			i++;
-			li++;
 		}
 
-		if (r < 2)
+		if (be_clipboard->Lock())
 		{
-			if (be_clipboard->Lock())
-			{
-				be_clipboard->Clear();
-				be_clipboard->Data()->AddData("text/plain", B_MIME_DATA, new_text, ls);
-				be_clipboard->Commit();
-				be_clipboard->Unlock();
-			}
+			be_clipboard->Clear();
+			be_clipboard->Data()->AddData("text/plain", B_MIME_DATA, clip.String(), clip.Length());
+			be_clipboard->Commit();
+			be_clipboard->Unlock();
 		}
-
-		delete[] new_text;
 	}
-
-	if (r != REG_NOERROR && r != REG_NOMATCH)
+	else
 	{
 		char err[100];
 

Modified: trunk/Extensions/CutContaining.cpp
===================================================================
--- trunk/Extensions/CutContaining.cpp	2009-05-05 21:10:46 UTC (rev 581)
+++ trunk/Extensions/CutContaining.cpp	2009-05-06 15:05:38 UTC (rev 582)
@@ -131,89 +131,68 @@
 {
 	//  error checking
 
-	long	selStart;
+	long	selBeg;
 	long	selEnd;
 
 	if (sSelectionOnly)
 	{
-		addon->GetSelection(&selStart, &selEnd);
-		if (selEnd <= selStart)
+		addon->GetSelection(&selBeg, &selEnd);
+		if (selEnd <= selBeg)
 			return B_ERROR;
 	}
 	else
 	{
-		selStart = 0;
+		selBeg = 0;
 		selEnd = addon->TextLength();
 	}
 
 	//  set-up
 
-	const char *txt = addon->Text();
-	int size = selEnd - selStart;
-
 	regex_t pb;
 	memset(&pb, 0, sizeof(pb));
 	int r = regcomp(&pb, sText, REG_EXTENDED);
 
 	if (r == REG_NOERROR)
 	{
-		char *new_text = new char[size + 1];
-		int ns, ni, ts, ti;
+		BString clip;
+		BString line;
+		const char *txt = addon->Text()+selBeg;
+		int size = selEnd - selBeg;
+		int beg = 0;
+		int pos = -1;
+		int len;
 
-		ns = ni = ts = ti = 0;
-
-		while (ti <= size)
+		while (++pos <= size)
 		{
-			if (ti == size || txt[ti] == '\n')
+			if ((pos == size || txt[pos] == '\n'))
 			{
-				int sl = ni - ns + 1;
+				if ((len = pos-beg) > 0) {
+					line.SetTo(txt+beg, len);
+					if (regexec(&pb, line.String(), 0, NULL, 0) == REG_NOERROR)
+					{
+						addon->Select(beg, pos + 1);
+						addon->Delete();
+						txt = addon->Text()+selBeg;
+						pos = beg - 1;
+						size -= len + 1;
 
-				new_text[ni] = 0;
-
-				r = regexec(&pb, new_text + ns, 0, NULL, 0);
-
-				if (r == 0)
-				{
-					addon->Select(ts, ti + 1);
-					addon->Delete();
-					txt = addon->Text();
-
-					ti -= sl;
-					size -= sl;
-
-					new_text[ni] = '\n';
-					ns = ni + 1;
+						clip << line << '\n';
+						continue;
+					}
 				}
-				else if (r == REG_NOMATCH)
-				{
-					ni = ns - 1;
-					ts = ti + 1;
-				}
-				else
-					break;
+				beg = pos + 1;
 			}
-			else
-				new_text[ni] = txt[ti];
-
-			ni++;
-			ti++;
 		}
 
-		if (r < 2)
+		if (be_clipboard->Lock())
 		{
-			if (be_clipboard->Lock())
-			{
-				be_clipboard->Clear();
-				be_clipboard->Data()->AddData("text/plain", B_MIME_DATA, new_text, ns);
-				be_clipboard->Commit();
-				be_clipboard->Unlock();
-			}
+			be_clipboard->Clear();
+			be_clipboard->Data()->AddData("text/plain", B_MIME_DATA, clip.String(), clip.Length());
+			be_clipboard->Commit();
+			be_clipboard->Unlock();
 		}
-
-		delete[] new_text;
 	}
-
-	if (r != REG_NOERROR && r != REG_NOMATCH)
+	else
 	{
 		char err[100];
 



From hoern at mail.berlios.de  Wed May  6 18:05:44 2009
From: hoern at mail.berlios.de (hoern at BerliOS)
Date: Wed, 6 May 2009 18:05:44 +0200
Subject: [pe-commits] r583 - trunk/Extensions
Message-ID: <200905061605.n46G5i4o016372@sheep.berlios.de>

Author: hoern
Date: 2009-05-06 18:05:44 +0200 (Wed, 06 May 2009)
New Revision: 583
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=583&view=rev

Modified:
   trunk/Extensions/CopyContaining.cpp
   trunk/Extensions/CutContaining.cpp
Log:
* Forgot BString.SetTo() is quite slow on BeOS


Modified: trunk/Extensions/CopyContaining.cpp
===================================================================
--- trunk/Extensions/CopyContaining.cpp	2009-05-06 15:05:38 UTC (rev 582)
+++ trunk/Extensions/CopyContaining.cpp	2009-05-06 16:05:44 UTC (rev 583)
@@ -167,7 +167,17 @@
 			if ((pos == size || txt[pos] == '\n'))
 			{
 				if ((len = pos-beg) > 0) {
+#ifdef __HAIKU__
+					// I assume on Haiku it's fast enough
 					line.SetTo(txt+beg, len);
+#else
+					// Fast workaround for slow BString.SetTo() on BeOS
+					char *buf;
+					FailNil(buf = line.LockBuffer(len+1));
+					memcpy(buf, txt+beg, len);
+					buf[len] = '\0';
+					line.UnlockBuffer(len);
+#endif
 					if (regexec(&pb, line.String(), 0, NULL, 0) == REG_NOERROR)
 					{
 						clip << line << '\n';

Modified: trunk/Extensions/CutContaining.cpp
===================================================================
--- trunk/Extensions/CutContaining.cpp	2009-05-06 15:05:38 UTC (rev 582)
+++ trunk/Extensions/CutContaining.cpp	2009-05-06 16:05:44 UTC (rev 583)
@@ -167,7 +167,17 @@
 			if ((pos == size || txt[pos] == '\n'))
 			{
 				if ((len = pos-beg) > 0) {
+#ifdef __HAIKU__
+					// I assume on Haiku it's fast enough
 					line.SetTo(txt+beg, len);
+#else
+					// Fast workaround for slow BString.SetTo() on BeOS
+					char *buf;
+					FailNil(buf = line.LockBuffer(len+1));
+					memcpy(buf, txt+beg, len);
+					buf[len] = '\0';
+					line.UnlockBuffer(len);
+#endif
 					if (regexec(&pb, line.String(), 0, NULL, 0) == REG_NOERROR)
 					{
 						addon->Select(beg, pos + 1);



From pecvs at hirschkaefer.de  Wed May  6 18:45:10 2009
From: pecvs at hirschkaefer.de (Oliver Tappe)
Date: Wed, 06 May 2009 16:45:10 +0000
Subject: [pe-commits] r583 - trunk/Extensions
In-Reply-To: <200905061605.n46G5i4o016372@sheep.berlios.de>
References: <200905061605.n46G5i4o016372@sheep.berlios.de>
Message-ID: <20090506164510.426.1@bepc.1241627408.fake>

Hi Rainer,

On 2009-05-06 at 16:05:44 [+0000], hoern at BerliOS <hoern at mail.berlios.de> 
wrote:
> Author: hoern
> Date: 2009-05-06 18:05:44 +0200 (Wed, 06 May 2009)
> New Revision: 583
> ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=583&view=rev
> 
> Modified:
>    trunk/Extensions/CopyContaining.cpp
>    trunk/Extensions/CutContaining.cpp
> Log:
> * Forgot BString.SetTo() is quite slow on BeOS
> 
> 
> Modified: trunk/Extensions/CopyContaining.cpp
> ===================================================================
> --- trunk/Extensions/CopyContaining.cpp    2009-05-06 15:05:38 UTC (rev 582)
> +++ trunk/Extensions/CopyContaining.cpp    2009-05-06 16:05:44 UTC (rev 583)
> @@ -167,7 +167,17 @@
>              if ((pos == size || txt[pos] == '\n'))
>              {
>                  if ((len = pos-beg) > 0) {
> +#ifdef __HAIKU__
> +                    // I assume on Haiku it's fast enough

yep, it should be.

cheers,
    Oliver


From mlist at navios.de  Wed May  6 19:30:17 2009
From: mlist at navios.de (Rainer Riedl)
Date: Wed, 06 May 2009 19:30:17 +0200
Subject: [pe-commits] r583 - trunk/Extensions
In-Reply-To: <20090506164510.426.1@bepc.1241627408.fake>
References: <200905061605.n46G5i4o016372@sheep.berlios.de>
	<20090506164510.426.1@bepc.1241627408.fake>
Message-ID: <20090506193017.21676.1@dhcppc0.nameserver>

> > +                    // I assume on Haiku it's fast enough
> yep, it should be.

Ah, nice.

Anyway, it seems like CRegex doesn't need a null terminated string so it 
could work directly on the text buffer. That could bring another speedup. 
Gonna have a look at it.


From pecvs at hirschkaefer.de  Wed May  6 23:59:03 2009
From: pecvs at hirschkaefer.de (Oliver Tappe)
Date: Wed, 06 May 2009 23:59:03 +0200
Subject: [pe-commits] r583 - trunk/Extensions
In-Reply-To: <20090506193017.21676.1@dhcppc0.nameserver>
References: <200905061605.n46G5i4o016372@sheep.berlios.de>
	<20090506164510.426.1@bepc.1241627408.fake>
	<20090506193017.21676.1@dhcppc0.nameserver>
Message-ID: <20090506235903.3313.1@bepc.1241646717.fake>


On 2009-05-06 at 18:30:17 [+0200], Rainer Riedl <mlist at navios.de> wrote:
> > > +                    // I assume on Haiku it's fast enough
> > yep, it should be.
> 
> Ah, nice.
> 
> Anyway, it seems like CRegex doesn't need a null terminated string so it
> could work directly on the text buffer. That could bring another speedup.
> Gonna have a look at it.

Is that the one from boost? Or what else is CRegex?

cheers,
    Oliver


From mlist at navios.de  Thu May  7 03:42:41 2009
From: mlist at navios.de (Rainer Riedl)
Date: Thu, 07 May 2009 03:42:41 +0200
Subject: [pe-commits] r583 - trunk/Extensions
In-Reply-To: <20090506235903.3313.1@bepc.1241646717.fake>
References: <200905061605.n46G5i4o016372@sheep.berlios.de>
	<20090506164510.426.1@bepc.1241627408.fake>
	<20090506193017.21676.1@dhcppc0.nameserver>
	<20090506235903.3313.1@bepc.1241646717.fake>
Message-ID: <20090507034241.22872.5@dhcppc0.nameserver>

> Is that the one from boost? Or what else is CRegex?
 
if you don't know, how should I? ;-)


/*	$Id: CRegex.cpp 480 2007-11-11 18:37:25Z zooey $
	Copyright 2005 Oliver Tappe - published under the MIT license.
*/


From bonefish at mail.berlios.de  Sat May  9 01:22:34 2009
From: bonefish at mail.berlios.de (bonefish at BerliOS)
Date: Sat, 9 May 2009 01:22:34 +0200
Subject: [pe-commits] r584 - trunk/Sources
Message-ID: <200905082322.n48NMYOr004593@sheep.berlios.de>

Author: bonefish
Date: 2009-05-09 01:22:32 +0200 (Sat, 09 May 2009)
New Revision: 584
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=584&view=rev

Modified:
   trunk/Sources/CFindDialog.cpp
Log:
* CRecentPatternController::Next(): Check the saved pattern only when we've
  actually reached it. Doing that unconditionally prevented navigating to the
  next pattern when the last pattern wasn't modified.
* Automatic white space cleanup.


Modified: trunk/Sources/CFindDialog.cpp
===================================================================
--- trunk/Sources/CFindDialog.cpp	2009-05-06 16:05:44 UTC (rev 583)
+++ trunk/Sources/CFindDialog.cpp	2009-05-08 23:22:32 UTC (rev 584)
@@ -1,8 +1,6 @@
-/*	$Id$
-	
-	Copyright 1996, 1997, 1998, 2002
+/*	Copyright 1996, 1997, 1998, 2002
 	        Hekkelman Programmatuur B.V.  All rights reserved.
-	
+
 	Redistribution and use in source and binary forms, with or without
 	modification, are permitted provided that the following conditions are met:
 	1. Redistributions of source code must retain the above copyright notice,
@@ -12,13 +10,13 @@
 	   and/or other materials provided with the distribution.
 	3. All advertising materials mentioning features or use of this software
 	   must display the following acknowledgement:
-	   
+
 	    This product includes software developed by Hekkelman Programmatuur B.V.
-	
+
 	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
 	   promote products derived from this software without specific prior
 	   written permission.
-	
+
 	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
@@ -28,7 +26,7 @@
 	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 	Created: long ago
 */
@@ -75,15 +73,15 @@
 
 CFindDialog* gFindDialog;
 
-bool FileContains(const char *path, const char *what, bool ignoreCase, 
+bool FileContains(const char *path, const char *what, bool ignoreCase,
 				  bool word, vector<PMessageItem*> *lst = NULL);
-bool BufferContains(const char *buf, int size, const char *path, 
-					const char *what, bool ignoreCase, bool word, 
+bool BufferContains(const char *buf, int size, const char *path,
+					const char *what, bool ignoreCase, bool word,
 					vector<PMessageItem*> *lst = NULL);
 
-bool FileContainsEx(const char *path, CRegex* regex, 
+bool FileContainsEx(const char *path, CRegex* regex,
 					vector<PMessageItem*> *lst = NULL);
-bool BufferContainsEx(const char *buf, int size, const char *path, 
+bool BufferContainsEx(const char *buf, int size, const char *path,
 					  CRegex* regex, vector<PMessageItem*> *lst = NULL);
 
 #pragma mark - CRecentPatternController
@@ -113,7 +111,7 @@
 
 CRecentPatternController::~CRecentPatternController()
 {
-	for(uint32 i=0; i<fPatternVect.size(); ++i) 
+	for(uint32 i=0; i<fPatternVect.size(); ++i)
 		delete fPatternVect[i];
 	fPatternVect.clear();
 }
@@ -127,7 +125,7 @@
 
 bool CRecentPatternController::AddCurrentPattern()
 {
-	BMessage* lastPatternMsg 
+	BMessage* lastPatternMsg
 		= fPatternVect.empty() ? NULL : fPatternVect.back();
 	if (!lastPatternMsg || gFindDialog->PatternInfoDiffersFrom(lastPatternMsg))
 	{	// current pattern is different than last, we add it:
@@ -143,12 +141,12 @@
 
 void CRecentPatternController::Next()
 {
-	if (fSavedPattern.IsEmpty())
-		return;
 	if (fCurrIdx == fPatternVect.size()-1)
 	{	// restore the saved pattern edited by user:
+		if (fSavedPattern.IsEmpty())
+			return;
 		gFindDialog->SetPatternInfo(&fSavedPattern);
-	} 
+	}
 	else if (fCurrIdx < fPatternVect.size()-1)
 	{	// navigate downwards:
 		fCurrIdx++;
@@ -158,10 +156,10 @@
 
 void CRecentPatternController::Previous()
 {
-	if (fCurrIdx == fPatternVect.size()-1 
+	if (fCurrIdx == fPatternVect.size()-1
 	&& gFindDialog->PatternInfoDiffersFrom(fPatternVect.back()))
 	{	// save pattern edited by user before navigating upwards, such
-		// that the user can get back to this pattern when navigating 
+		// that the user can get back to this pattern when navigating
 		// back downwards:
 		fSavedPattern.MakeEmpty();
 		gFindDialog->GetPatternInfo(&fSavedPattern);
@@ -201,22 +199,22 @@
 filter_result CFindDialogKeyFilter::Filter(BMessage *msg, BHandler **target)
 {
 	int32 keychar, modifiers;
-	if (*target && msg->FindInt32("modifiers", &modifiers) == B_OK 
+	if (*target && msg->FindInt32("modifiers", &modifiers) == B_OK
 		&& msg->FindInt32("raw_char", &keychar) == B_OK)
 	{
 		// if the user pressed return the given target will already
 		// be set to the default button, so we have to find out the
-		// focus view by accessing the preferred handler: 
-		BHandler* focusHandler 
+		// focus view by accessing the preferred handler:
+		BHandler* focusHandler
 			= (*target)->Looper()->PreferredHandler();
-		BTextView* textview 
+		BTextView* textview
 			= dynamic_cast<BTextView*>(focusHandler);
 		if (!textview)
 			// we only want to filter keys pressed in a textview
 			return B_DISPATCH_MESSAGE;
 		switch(keychar)
 		{
-			case B_RETURN: 
+			case B_RETURN:
 				if (modifiers & (B_CONTROL_KEY | B_OPTION_KEY))
 				{
 					// insert a newline into the focused textview:
@@ -227,7 +225,7 @@
 				}
 				break;
 			case B_UP_ARROW:
-				if (modifiers & (B_CONTROL_KEY | B_OPTION_KEY)) 
+				if (modifiers & (B_CONTROL_KEY | B_OPTION_KEY))
 				{
 					CRecentPatternController::ActiveController()->Previous();
 					return B_SKIP_MESSAGE;
@@ -253,9 +251,9 @@
 {
 	gFindDialog = this;
 	fCurrentDir = NULL;
-	
+
 	char *bi = strdup(getenv("BEINCLUDES"));
-	
+
 	int i = 1;
 	const char *p = bi;
 	while ((p = strchr(p + 1, ';')) != NULL)
@@ -263,33 +261,33 @@
 
 	fBeIncludes = (char **)malloc(i * sizeof(char *));
 	FailNil(fBeIncludes);
-	
+
 	p = bi;
 	i = 0;
-	
+
 	do
 	{
 		char *ep = strchr(p, ';');
 		if (ep) *ep++ = 0;
-		
+
 		fBeIncludes[i] = strdup(p);
 		FailNil(fBeIncludes[i++]);
 		p = ep;
 	}
 	while (p);
-	
+
 	free(bi);
 	fBeIncludeCount = i;
-	
+
 	fDirPanel = NULL;
-	
+
 	Create();
 	Layout();
 
 	UpdateSearchDirMenu();
 
 	fOpenWindowIndex = -1;
-	
+
 	UpdateFields();
 } /* CFindDialog::CFindDialog */
 
@@ -318,10 +316,10 @@
 	// Add Settings
 	fChkCase = new HCheckBox(fMainView, "case", NULL, H_FOLLOW_LEFT_BOTTOM);
 	fChkWrap = new HCheckBox(fMainView, "wrap", NULL, H_FOLLOW_LEFT_BOTTOM);
-	fChkBack = new HCheckBox(fMainView, "back", new BMessage(msg_FlagBackward), 
+	fChkBack = new HCheckBox(fMainView, "back", new BMessage(msg_FlagBackward),
 		H_FOLLOW_LEFT_BOTTOM);
 	fChkWord = new HCheckBox(fMainView, "word", NULL, H_FOLLOW_LEFT_BOTTOM);
-	fChkGrep = new HCheckBox(fMainView, "regx", new BMessage(msg_FlagRegex), 
+	fChkGrep = new HCheckBox(fMainView, "regx", new BMessage(msg_FlagRegex),
 		H_FOLLOW_LEFT_BOTTOM);
 	fChkBtch = new HCheckBox(fMainView, "btch", NULL, H_FOLLOW_LEFT_BOTTOM);
 	fChkCase->SetOn(gPrefs->GetPrefInt(prf_I_SearchIgnoreCase, 1));
@@ -509,7 +507,7 @@
 
 	if (fChkGrep->IsOn() && (cmd == msg_Find || cmd == msg_ReplaceAll))
 	{
-		status_t res = fRegex.SetTo(fEdiFind->Text(), fChkCase->IsOn(), 
+		status_t res = fRegex.SetTo(fEdiFind->Text(), fChkCase->IsOn(),
 									fChkWord->IsOn());
 		if (res != B_OK)
 		{
@@ -518,7 +516,7 @@
 			return;
 		}
 	}
-	
+
 	if (fChkMult->IsOn())
 	{
 		switch (fMfdMeth->FindMarkedIndex())
@@ -526,9 +524,9 @@
 			case METHOD_IDX_DIR:
 			{
 				PDoc *w = NULL;
-				
+
 				MultiReplaceKind all = mrNone;
-				
+
 				if (cmd == msg_ReplaceAll)
 				{
 					switch (MAlert("Replace All on multiple files", "Cancel", "Leave Open", "Save To Disk").Go())
@@ -538,7 +536,7 @@
 						case 3:	all = mrSaveToDisk; break;
 					}
 				}
-				
+
 				if (!DoMultiFileFind(fMfdSdir->Menu()->FindMarked()->Label(),
 					fChkRecu->IsOn(), true, all, &w))
 					beep();
@@ -574,7 +572,7 @@
 	else
 	{
 		BMessage msg(cmd);
-		
+
 		msg.AddString("what", fEdiFind->Text());
 		msg.AddString("with", fEdiRepl->Text());
 		msg.AddBool  ("wrap", fChkWrap->IsOn());
@@ -625,7 +623,7 @@
 		fMfdNamp->SetEnabled(meth == METHOD_IDX_DIR);
 		fChkText->SetEnabled(meth == METHOD_IDX_DIR);
 		fChkRecu->SetEnabled(meth == METHOD_IDX_DIR || meth == METHOD_IDX_INC);
-		
+
 		if (meth == METHOD_IDX_INC)
 			fChkText->SetOn(true);
 
@@ -640,13 +638,13 @@
 		fEdiName->SetEnabled(false);
 		fMfdNamp->SetEnabled(false);
 		fChkRecu->SetEnabled(false);
-		
+
 		fCurrentDir = NULL;
 		while (fDirStack.size())
 		{
 			closedir(fDirStack.top());
 			fDirStack.pop();
-			
+
 			char *p = fDirNameStack.top();
 			free(p);
 			fDirNameStack.pop();
@@ -670,7 +668,7 @@
 			entry_ref ref;
 			FailOSErr(msg->FindRef("refs", &ref));
 			BEntry e(&ref);
-			
+
 			if (!e.IsDirectory())
 				BEntry(&ref).GetParent(&e); // nasty huh?
 
@@ -679,7 +677,7 @@
 			fChkMult->SetOn(true);
 			BPath path;
 			e.GetPath(&path);
-			
+
 			AddPathToDirMenu(path.Path(), true);
 			UpdateFields();
 		}
@@ -691,7 +689,7 @@
 			case msg_ReplaceAll:
 				DoFind(what);
 				break;
-	
+
 			case msg_ReplyCanReplace:
 			{
 				bool canReplace;
@@ -702,7 +700,7 @@
 				}
 				break;
 			}
-			
+
 			case msg_EnterSearchString:
 			case msg_FindSelection:
 			case msg_FindSelectionBackward:
@@ -719,7 +717,7 @@
 					DoFind(msg_FindAgainBackward);
 				break;
 			}
-				
+
 			case msg_EnterReplaceString:
 			{
 				fChkMult->SetOn(false);
@@ -730,7 +728,7 @@
 					fEdiRepl->SetText(s);
 				break;
 			}
-			
+
 			case msg_FindInNextFile:
 			{
 				switch (fMfdMeth->FindMarkedIndex())
@@ -745,11 +743,11 @@
 							w->Show();
 						break;
 					}
-					
+
 					case METHOD_IDX_WIN:
 						DoOpenWindows(false);
 						break;
-					
+
 					case METHOD_IDX_INC:
 						DoIncludesFind();
 						break;
@@ -765,7 +763,7 @@
 				}
 				fDirPanel->Show();
 				break;
-			
+
 			case msg_SelectedDir:
 			{
 				entry_ref ref;
@@ -779,12 +777,12 @@
 				fChkMult->SetOn(true);
 				UpdateFields();
 				break;
-			
+
 			case msg_FindPopup:
 			{
 				long ix;
 				FailOSErr(msg->FindInt32("index", &ix));
-				
+
 				CRecentPatternController::ActiveController()->GoToIndex(ix);
 				break;
 			}
@@ -894,7 +892,7 @@
 	FailOSErr(e.SetTo(&ref));
 	BPath p;
 	FailOSErr(e.GetPath(&p));
-	
+
 	AddPathToDirMenu(p.Path(), select, addToPrefs);
 } /* CFindDialog::AddPathToDirMenu */
 
@@ -991,7 +989,7 @@
 			label << B_UTF8_ELLIPSIS;
 		}
 	}
-	BMenuItem* item 
+	BMenuItem* item
 		= new BMenuItem(label.String(), new BMessage(msg_FindPopup));
 	fMfdPats->Menu()->AddItem(item);
 }
@@ -1003,7 +1001,7 @@
 	char path[PATH_MAX];
 	bool batch = fChkBtch->IsOn();
 	vector<PMessageItem*> *lst = NULL;
-	
+
 	if (batch && replace == mrNone)
 		lst = new vector<PMessageItem*>;
 
@@ -1024,28 +1022,28 @@
 	}
 
 	if (!fCurrentDir) THROW(("Directory not found: %s", dir));
-	
+
 	struct dirent *dent;
 	struct stat stbuf;
-	
+
 	PLongAction la;
 	bool cancel = false;
-	
+
 	while (fDirStack.size() && ! cancel)
 	{
 		fCurrentDir = fDirStack.top();
 		dir = fDirNameStack.top();
-		
+
 		while ((dent = readdir(fCurrentDir)) != NULL && ! cancel)
 		{
 			strcpy(path, dir);
 			strcat(path, "/");
 			strcat(path, dent->d_name);
 			status_t err = stat(path, &stbuf);
-			
+
 			if (err || !(strcmp(dent->d_name, ".") && strcmp(dent->d_name, "..")))
 				continue;
-			
+
 			if (S_ISREG(stbuf.st_mode))
 			{
 				entry_ref ref;
@@ -1057,7 +1055,7 @@
 						if (doc)
 						{
 							BAutolock lock(doc);
-		
+
 							doc->TextView()->Find(msg_ReplaceAll, NULL);
 						}
 					}
@@ -1067,9 +1065,9 @@
 						if (doc)
 						{
 							doc->Lock();
-		
+
 							doc->TextView()->Find(msg_ReplaceAll, NULL);
-							
+
 							if (doc->IsHidden())
 							{
 								doc->Save();
@@ -1085,11 +1083,11 @@
 						if (doc)
 						{
 							BAutolock lock(doc);
-		
+
 							int offset = 0;
-							
+
 							doc->TextView()->FindNext(fEdiFind->Text(),
-								offset, fChkCase->IsOn(), false, false, false, 
+								offset, fChkCase->IsOn(), false, false, false,
 								fChkGrep->IsOn(), true);
 							return true;
 						}
@@ -1105,7 +1103,7 @@
 				fCurrentDir = NULL;
 				break;
 			}
-			
+
 			cancel = la.Tick();
 		}
 
@@ -1114,20 +1112,20 @@
 			closedir(fDirStack.top());
 			fDirStack.pop();
 			fCurrentDir = NULL;
-			
+
 			free(fDirNameStack.top());
 			fDirNameStack.pop();
 			dir = NULL;
 		}
 	}
-	
+
 	// not found... or batch of course!
 	if (lst)
 	{
 		ShowBatch(lst, (BWindow**)w);
 		delete lst;
 	}
-	
+
 	return false;
 } /* CFindDialog::DoMultiFileFind */
 
@@ -1139,7 +1137,7 @@
 	if (fChkText->IsOn())
 	{
 		BNode n;
-		
+
 		FailOSErr(n.SetTo(&ref));
 
 		char mime[64];
@@ -1148,13 +1146,13 @@
 		if (strncmp(mime, "text/", 5))
 			result = false;
 	}
-	
+
 	int fnam = fMfdNamp->FindMarkedIndex();
 	if (result && fnam != FNAME_IDX_ANY)
 	{
 		const char *pat = fEdiName->Text();
 		char *file = strrchr(path, '/') + 1;
-	
+
 		switch (fnam)
 		{
 			case 1:	result = strcmp(file + strlen(file) - strlen(pat), pat) == 0; break;
@@ -1178,7 +1176,7 @@
 	BPath p;
 	FailOSErr(e.GetPath(&p));
 	const char *path = p.Path();
-	
+
 	doc = dynamic_cast<PDoc*>(CDoc::FindDoc(ref));
 
 	if (doc)
@@ -1190,7 +1188,7 @@
 			found = BufferContainsEx(txt->Text(), txt->Size(), path,
 									 &fRegex, lst);
 		else
-			found = BufferContains(txt->Text(), txt->Size(), path, what, 
+			found = BufferContains(txt->Text(), txt->Size(), path, what,
 								   fChkCase->IsOn(), word, lst);
 	}
 	else if (fChkGrep->IsOn())
@@ -1204,7 +1202,7 @@
 void CFindDialog::DoIncludesFind()
 {
 	PDoc *w = NULL;
-	
+
 	if (fCurrentIncludeIndex > -1)
 	{
 		if (fCurrentDir && DoMultiFileFind(fBeIncludes[fCurrentIncludeIndex], false, false, mrNone, &w))
@@ -1214,7 +1212,7 @@
 	}
 	else
 		fCurrentIncludeIndex = 0;
-		
+
 	do
 	{
 		if (DoMultiFileFind(fBeIncludes[fCurrentIncludeIndex], false, true, mrNone, &w))
@@ -1224,7 +1222,7 @@
 
 	if (w)
 		w->Show();
-		
+
 	fCurrentIncludeIndex = -1;
 	beep();
 } /* CFindDialog::DoBeIncludesFind */
@@ -1251,19 +1249,19 @@
 		if (fOpenWindowIndex == -1)
 		{
 			fOpenWindows.clear();
-	
+
 			int i = be_app->CountWindows();
-			
+
 			while (i--)
 			{
 				PDoc *doc = dynamic_cast<PDoc*>(be_app->WindowAt(i));
 				if (doc)
 					fOpenWindows.push_back(doc);
 			}
-			
+
 			fOpenWindowIndex = fOpenWindows.size();
 		}
-	
+
 		while (--fOpenWindowIndex >= 0)
 		{
 			PDoc* doc = fOpenWindows[fOpenWindowIndex];
@@ -1273,7 +1271,7 @@
 			if (doc && FindInFile(file, NULL))
 			{
 				BAutolock lock(doc);
-				
+
 				if (!lock.IsLocked())
 					continue;
 				doc->Activate();
@@ -1283,7 +1281,7 @@
 				{
 					int offset = 0;
 					doc->TextView()->FindNext(fEdiFind->Text(), offset,
-						fChkCase->IsOn(), false, false, fChkWord->IsOn(), 
+						fChkCase->IsOn(), false, false, fChkWord->IsOn(),
 						fChkGrep->IsOn(), true);
 					return;
 				}
@@ -1291,7 +1289,7 @@
 		}
 		beep();
 	}
-	
+
 } /* CFindDialog::DoOpenWindows */
 
 void CFindDialog::ShowBatch(vector<PMessageItem*> *lst, BWindow** w)
@@ -1299,21 +1297,21 @@
 	if (lst && lst->size())
 	{
 		PMessageWindow *m;
-		
+
 		if (w && *w)
 			m = static_cast<PMessageWindow*>(*w);
 		else
 			m = new PMessageWindow("Search Results");
 
 		BAutolock lock(m);
-		
+
 		if (lock.IsLocked())
 		{
 			if (w) *w = m;
-	
+
 			for (int i = 0; i < lst->size(); i++)
 				m->AddMessage(static_cast<PMessageItem*>((*lst)[i]));
-	
+
 			if (w && *w)
 				m->Show();
 		}
@@ -1327,16 +1325,16 @@
 {
 	for (int i = 0; i < 255; i++)
 		skip[i] = 1;
-		
+
 	// [zooey]: temporary fix, as the current code isn't able to deal
 	//          with utf-8 chars correctly.
 
 #if 0
 	int M = strlen((char *)p), i;
-	
+
 	for (i = 0; i < 255; i++)
 		skip[i] = M;
-	
+
 	if (ignoreCase)
 	{
 		for (i = 0; i < M; i++)
@@ -1395,16 +1393,16 @@
 {
 	for (int i = 0; i < 255; i++)
 		skip[i] = 1;
-		
+
 	// [zooey]: temporary fix, as the current code isn't able to deal
 	//          with utf-8 chars correctly.
 
 #if 0
 	int M = strlen((char *)p), i;
-	
+
 	for (i = 0; i < 255; i++)
 		skip[i] = M;
-	
+
 	if (ignoreCase)
 	{
 		for (i = M - 1; i >= 0; i--)
@@ -1473,12 +1471,12 @@
 static bool IsWord(const char *buf, int size, int start, int len)
 {
 	bool result;
-	
+
 	result = isalnum(buf[start]);
 	if (result) result = isalnum(buf[start + len - 1]);
 	if (result) result = (start == 0 || (!isalnum(buf[start - 1]) && buf[start - 1] != '_'));
 	if (result) result = (start + len == size || (!isalnum(buf[start + len]) && buf[start + len] != '_'));
-	
+
 	return result;
 } /* IsWord */
 
@@ -1486,7 +1484,7 @@
 {
 	line = 1;
 	int i = 0, ls = 0;
-	
+
 	while (i < offset)
 	{
 		if (buf[i] == '\n')
@@ -1496,7 +1494,7 @@
 		}
 		i++;
 	}
-	
+
 	selStart = offset - ls + 2;
 
 	i = ls + 1;
@@ -1522,13 +1520,13 @@
 		fseek(f, 0, SEEK_END);
 		int size = ftell(f);
 		fseek(f, 0, SEEK_SET);
-		
+
 		char *buf = (char *)malloc(size + 1);
 		if (buf)
 		{
 			fread(buf, 1, size, f);
 			buf[size] = 0;
-			result = BufferContains(buf, size, path, what, ignoreCase, word, lst);			
+			result = BufferContains(buf, size, path, what, ignoreCase, word, lst);
 			free(buf);
 		}
 		fclose(f);
@@ -1545,7 +1543,7 @@
 	int offset = 0;
 
 	initskip(what, skip, ignoreCase);
-	
+
 	do
 	{
 		offset += mismatchsearch(what, buf + offset, size - offset, skip, ignoreCase);
@@ -1563,30 +1561,30 @@
 			if (!word || IsWord(buf, size, offset + 1, strlen(what)))
 			{
 				PMessageItem *i = new PMessageItem;
-				
+
 				char *l;
 				int line, start;
-				
+
 				Offset2Line(buf, size, offset, line, start, &l);
-				
+
 				i->SetError(l);
 				i->SetFile(path);
 				i->SetLine(line);
 				i->SetSel(start, strlen(what));
 				i->SetKind(3);
-				
+
 				lst->push_back(i);
-				
+
 				free(l);
 			}
-			
+
 			offset += strlen(what);
 			offset += mismatchsearch(what, buf + offset,
 				size - offset, skip, ignoreCase);
 		}
 		while (offset < size);
 	}
-				
+
 	return result;
 } /* BufferContains */
 
@@ -1600,7 +1598,7 @@
 		fseek(f, 0, SEEK_END);
 		int size = ftell(f);
 		fseek(f, 0, SEEK_SET);
-		
+
 		char *buf = (char *)malloc(size + 1);
 		if (buf)
 		{
@@ -1609,18 +1607,18 @@
 			result = BufferContainsEx(buf, size, path, regex, lst);
 			free(buf);
 		}
-		
+
 		fclose(f);
 	}
 
 	return result;
 } /* FileContainsEx */
 
-bool BufferContainsEx(const char *buf, int size, const char *path, 
+bool BufferContainsEx(const char *buf, int size, const char *path,
 					  CRegex* regex, vector<PMessageItem*> *lst)
 {
 	int offset, e = 0, r;
-	
+
 	offset = e;
 	r = regex->Match(buf, size, offset);
 	offset = regex->MatchStart();
@@ -1631,22 +1629,22 @@
 		do
 		{
 			PMessageItem *i = new PMessageItem;
-				
+
 			char *l;
 			int line, start;
-				
+
 			Offset2Line(buf, size, offset, line, start, &l);
-				
+
 			i->SetError(l);
 			i->SetFile(path);
 			i->SetLine(line);
 			i->SetSel(start - 1, e - offset);
 			i->SetKind(3);
-				
+
 			lst->push_back(i);
-				
+
 			free(l);
-			
+
 			offset = std::max(e, offset+1);
 			r = regex->Match(buf, size, offset);
 			offset = regex->MatchStart();
@@ -1654,6 +1652,6 @@
 		}
 		while (r == 0);
 	}
-				
+
 	return (r == 0);
 } /* BufferContainsEx */



