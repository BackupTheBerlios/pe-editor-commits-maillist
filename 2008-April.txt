From mmu_man at mail.berlios.de  Tue Apr  8 04:28:39 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 8 Apr 2008 04:28:39 +0200
Subject: [pe-commits] r502 - trunk/Extensions
Message-ID: <200804080228.m382Sdcl000608@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-08 04:28:36 +0200 (Tue, 08 Apr 2008)
New Revision: 502
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=502&view=rev

Added:
   trunk/Extensions/WebPaste.cpp
Modified:
   trunk/Extensions/Jamfile
Log:
New extension that pastes the selection to http://rafb.net/paste/ and copies the url to the clipboard (and opens the browser to it).
Handy to share code with someone else on IRC...


Modified: trunk/Extensions/Jamfile
===================================================================
--- trunk/Extensions/Jamfile	2008-03-28 12:06:25 UTC (rev 501)
+++ trunk/Extensions/Jamfile	2008-04-08 02:28:36 UTC (rev 502)
@@ -118,3 +118,10 @@
 	: libhekkel.so be $(STDC++LIB) 
 	;
 # </pe-src>
+
+# <pe-src>
+PeExtension WebPaste 
+	: WebPaste.cpp 
+	: libhekkel.so be
+	;
+# </pe-src>

Added: trunk/Extensions/WebPaste.cpp
===================================================================
--- trunk/Extensions/WebPaste.cpp	2008-03-28 12:06:25 UTC (rev 501)
+++ trunk/Extensions/WebPaste.cpp	2008-04-08 02:28:36 UTC (rev 502)
@@ -0,0 +1,291 @@
+//
+// WebPaste Extension for Pe Editor:
+// pastes the selected text online at http://rafb.net/.
+//
+// written by Fran?ois Revol, 2008.
+//
+
+#include "PeAddOn.h"
+#include <stdio.h>
+
+#define PASTE_URL "http://rafb.net/paste/paste.php"
+#define OPEN_IN_BROWSER 1
+#define COPY_TO_CLIPBOARD 1
+
+//------------------------------------------------------------------------------
+
+#if 0
+class StdDataIO : public BDataIO {
+public:
+	StdDataIO(FILE *f, bool closeOnDelete=true);
+	virtual ~StdDataIO();
+	virtual ssize_t Read(void *buffer, size_t size);
+	virtual ssize_t Write(const void *buffer, size_t size);
+private:
+	FILE *fFile;
+	bool fCloDelete;
+}
+
+StdDataIO::StdDataIO(FILE *f, bool closeOnDelete)
+{
+	fFile = f;
+	fCloDelete = closeOnDelete;
+}
+
+StdDataIO::~StdDataIO()
+{
+	if (fCloDelete)
+		fclose(fFile);
+}
+
+#endif
+
+class StdIOInString : public BString {
+public:
+	StdIOInString(FILE *f, bool closeOnDelete=true);
+	virtual ~StdIOInString();
+private:
+	FILE *fFile;
+	bool fCloDelete;
+};
+
+StdIOInString::StdIOInString(FILE *f, bool closeOnDelete)
+{
+	fFile = f;
+	fCloDelete = closeOnDelete;
+	ssize_t len = 0;
+	do {
+		len = Length();
+		char *buf = LockBuffer(len + 4096);
+		buf += len;
+		int got = fread(buf, 1, 4096, fFile);
+		//fprintf(stderr, "got %d\n", got);
+		UnlockBuffer();
+		if (got < 4096) {
+			buf[got] = '\0';
+			return;
+		}
+	} while (true);
+}
+
+StdIOInString::~StdIOInString()
+{
+	if (fCloDelete)
+		fclose(fFile);
+}
+
+
+//------------------------------------------------------------------------------
+
+static const char *PeLangToPasteLang(const char *lang);
+static status_t UrlEscape(BString &str);
+status_t POpenOut(const char *cmd, BString &output);
+static status_t RunWgetPaste(const char *language, const char *nick, const char *desc, const char *text);
+
+//------------------------------------------------------------------------------
+
+const char *
+PeLangToPasteLang(const char *lang)
+{
+	BString l(lang);
+	if (l == "C")
+		return "C (99)";
+	if (l == "C++")
+		return "C++";
+	if (l == "Java")
+		return "Java";
+	//XXX
+	return "Plain Text";
+	
+}
+
+status_t
+UrlEscape(BString &str)
+{
+	// XXX: assumes UTF-8!
+	for (int32 i = 0; i < str.Length(); i++) {
+		if (str[i] >= '0' && str[i] < '9')
+			continue;
+		if (str[i] >= 'A' && str[i] < 'Z')
+			continue;
+		if (str[i] >= 'a' && str[i] < 'z')
+			continue;
+		uint8 c = (uint8)str[i];
+		// seems those are byte-based, not UTF68 char-based
+		char escape[5];
+		//printf("%x\n", c);
+		sprintf(escape, "%%%2.2x", c);
+		str.Remove(i,1);
+		str.Insert(escape, i);
+		i+=2;
+	}
+	return B_OK;
+}
+
+
+
+status_t 
+POpenOut(const char *cmd, BString &output)
+{
+	FILE *f;
+	f = popen(cmd, "r");
+	if (!f)
+		return errno;
+	StdIOInString out(f);
+	output = out;
+	return B_OK;
+}
+
+
+// sample post:
+// wget --post-data="lang=C++&nick=mmu_man&desc=SamplePasting&cvt_tabs=No&text=int%20main()%20{}" http://rafb.net/paste/paste.php
+// <td><small>URL: http://rafb.net/p/ngZGZU48.html</small></td>
+// http://rafb.net/p/ngZGZU48.html
+
+status_t
+RunWgetPaste(const char *language, const char *nick, const char *desc, const char *text)
+{
+	BString langStr(PeLangToPasteLang(language));
+	BString nickStr(nick);
+	BString descStr(desc);
+	BString textStr(text);
+	UrlEscape(langStr);
+	UrlEscape(nickStr);
+	UrlEscape(descStr);
+	UrlEscape(textStr);
+	BString postStr;
+	postStr << "lang=" << langStr << "&";
+	postStr << "nick=" << nickStr << "&";
+	postStr << "desc=" << descStr << "&";
+	postStr << "cvt_tabs=No" << "&";
+	postStr << "text=" << textStr;
+	
+	BString command("wget");
+	command << " -O - "; // output to stdout
+	//command << "--header=\"Content-Type: text/plain; charset=utf-8\" ";
+	command << "--post-data=\"" << postStr << "\"";
+	command << " ";
+	command << PASTE_URL;
+	
+	BString result;
+	status_t err;
+	
+	err = POpenOut(command.String(), result);
+	// TEST
+	/*
+	err = B_OK;
+	FILE *ftmp = fopen("/work/pe/trunk/xpTxSh16.html", "r");
+	printf("FILE:%p\n", ftmp);
+	StdIOInString tmp(ftmp);
+	result = tmp;
+	*/
+	
+	//fprintf(stderr, "error 0x%08lx\n", err);
+	if (err < B_OK)
+		return err;
+	int32 urlIndex = result.FindFirst("URL: ");
+	if (urlIndex < 0)
+		return EIO;
+	urlIndex += 5;
+	int32 urlEnd = result.FindFirst('<', urlIndex);
+	BString pasteUrl;
+	if (urlEnd <= urlIndex)
+		return EIO;
+	result.CopyInto(pasteUrl, urlIndex, urlEnd - urlIndex);
+
+	//printf("got %s\n", result.String());
+
+#ifdef COPY_TO_CLIPBOARD
+	if (be_clipboard->Lock()) {
+		be_clipboard->Clear();
+		BMessage *clip;
+		clip = be_clipboard->Data();
+		if (clip) {
+			clip->AddData("text/plain", B_MIME_TYPE, pasteUrl.String(), pasteUrl.Length());
+			clip->AddData("text/url", B_MIME_TYPE, pasteUrl.String(), pasteUrl.Length());
+			clip->AddData("text/x-url", B_MIME_TYPE, pasteUrl.String(), pasteUrl.Length());
+			be_clipboard->Commit();
+		}
+		be_clipboard->Unlock();
+	}
+#endif
+
+#ifdef OPEN_IN_BROWSER
+	char *args[2] = { NULL, NULL };
+	args[0] = (char *)pasteUrl.String();
+	be_roster->Launch(B_URL_HTTP, 1, args);
+#endif
+
+	
+/*
+	BString message("Error running wget.\n");
+	message << pasteUrl;
+	MInfoAlert(message.String()).Go();
+*/
+	
+	return B_OK;
+}
+
+
+//------------------------------------------------------------------------------
+//	#pragma mark - Addon Entry
+
+#if __INTEL__
+	extern "C" _EXPORT long perform_edit(MTextAddOn* addon);
+#else
+	#pragma export on
+	extern "C" {
+		long perform_edit(MTextAddOn* addon);
+	}
+	#pragma export reset
+#endif
+
+
+long
+perform_edit(MTextAddOn* addon)
+{
+	status_t err;
+	long selStart;
+	long selEnd;
+
+	addon->GetSelection(&selStart, &selEnd);
+
+	if (selEnd <= selStart)
+		return B_ERROR;
+
+	int length = selEnd - selStart;
+
+	// Do NOT run the query if we have less than 3 chars. It works, but takes
+	// ages and produces an useless giant popup menu.
+	if (length < 3) {
+		MIdeaAlert("The text selection is too short.\n"
+					"Please select at least three characters.").Go();
+		return B_ERROR;
+	}
+
+	BString selection;
+	selection.SetTo(addon->Text() + selStart, length);
+	
+	BString description;
+	if (addon->Window()) {
+		description = addon->Window()->Title();
+	}
+
+	err = RunWgetPaste("C++", 
+		"unknown", 
+		description.String(), 
+		selection.String());
+	if (err >= B_OK)
+		return B_OK;
+
+
+	if (err == B_LAUNCH_FAILED) {
+		MStopAlert("Can't run Wget!").Go();
+		return B_OK;
+	}
+	
+	BString message("Error running wget.");
+	MInfoAlert(message.String()).Go();
+
+	return B_OK;
+}



From mmu_man at mail.berlios.de  Tue Apr  8 16:54:05 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 8 Apr 2008 16:54:05 +0200
Subject: [pe-commits] r503 - trunk/Extensions
Message-ID: <200804081454.m38Es51Z014049@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-08 16:54:05 +0200 (Tue, 08 Apr 2008)
New Revision: 503
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=503&view=rev

Modified:
   trunk/Extensions/WebPaste.cpp
Log:
Cleanup


Modified: trunk/Extensions/WebPaste.cpp
===================================================================
--- trunk/Extensions/WebPaste.cpp	2008-04-08 02:28:36 UTC (rev 502)
+++ trunk/Extensions/WebPaste.cpp	2008-04-08 14:54:05 UTC (rev 503)
@@ -5,6 +5,10 @@
 // written by Fran?ois Revol, 2008.
 //
 
+// TODO:
+// Someone said http://pastebin.ca/ handles UTF-8 correctly (unline rafb.net)
+// maybe later add configurable multiple handlers ?
+
 #include "PeAddOn.h"
 #include <stdio.h>
 
@@ -13,33 +17,8 @@
 #define COPY_TO_CLIPBOARD 1
 
 //------------------------------------------------------------------------------
+//	#pragma mark - class StdIOInString
 
-#if 0
-class StdDataIO : public BDataIO {
-public:
-	StdDataIO(FILE *f, bool closeOnDelete=true);
-	virtual ~StdDataIO();
-	virtual ssize_t Read(void *buffer, size_t size);
-	virtual ssize_t Write(const void *buffer, size_t size);
-private:
-	FILE *fFile;
-	bool fCloDelete;
-}
-
-StdDataIO::StdDataIO(FILE *f, bool closeOnDelete)
-{
-	fFile = f;
-	fCloDelete = closeOnDelete;
-}
-
-StdDataIO::~StdDataIO()
-{
-	if (fCloDelete)
-		fclose(fFile);
-}
-
-#endif
-
 class StdIOInString : public BString {
 public:
 	StdIOInString(FILE *f, bool closeOnDelete=true);
@@ -76,6 +55,7 @@
 
 
 //------------------------------------------------------------------------------
+//	#pragma mark - Helper functions
 
 static const char *PeLangToPasteLang(const char *lang);
 static status_t UrlEscape(BString &str);
@@ -216,13 +196,6 @@
 	be_roster->Launch(B_URL_HTTP, 1, args);
 #endif
 
-	
-/*
-	BString message("Error running wget.\n");
-	message << pasteUrl;
-	MInfoAlert(message.String()).Go();
-*/
-	
 	return B_OK;
 }
 
@@ -255,11 +228,11 @@
 
 	int length = selEnd - selStart;
 
-	// Do NOT run the query if we have less than 3 chars. It works, but takes
-	// ages and produces an useless giant popup menu.
-	if (length < 3) {
+	// Do NOT paste anything if we have less than 5 chars.
+	// It's probably unwanted action.
+	if (length < 5) {
 		MIdeaAlert("The text selection is too short.\n"
-					"Please select at least three characters.").Go();
+					"Please select at least five characters.").Go();
 		return B_ERROR;
 	}
 



From mmu_man at mail.berlios.de  Tue Apr  8 19:53:47 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 8 Apr 2008 19:53:47 +0200
Subject: [pe-commits] r504 - in trunk: Resources Sources
Message-ID: <200804081753.m38Hrlkp019704@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-08 19:53:46 +0200 (Tue, 08 Apr 2008)
New Revision: 504
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=504&view=rev

Modified:
   trunk/Resources/Menus.r
   trunk/Sources/PDoc.cpp
   trunk/Sources/PMessages.h
   trunk/Sources/PText.cpp
   trunk/Sources/PText.h
Log:
Preliminary support for printing. One goal is to be able to print to a PDF file and generate bookmarks from the function list.


Modified: trunk/Resources/Menus.r
===================================================================
--- trunk/Resources/Menus.r	2008-04-08 14:54:05 UTC (rev 503)
+++ trunk/Resources/Menus.r	2008-04-08 17:53:46 UTC (rev 504)
@@ -55,9 +55,9 @@
 		Item		{ "Save All",				msg_SaveAll,					none,	noKey	},
 		Item		{ "Revert?",				msg_Revert,						none,	noKey	},
 		Separator	{																			},
-//		Item		{ "Page Setup?",			msg_PageSetup,					none,	noKey	},
-//		Item		{ "Print?",					msg_Print,						none,	'P'		},
-//		Separator	{																			},
+		Item		{ "Page Setup?",			msg_PageSetup,					none,	noKey	},
+		Item		{ "Print?",					msg_Print,						none,	'P'		},
+		Separator	{																			},
 		Item		{ "Quit",					msg_Quit,						none,	'Q'		}
 	}
 };

Modified: trunk/Sources/PDoc.cpp
===================================================================
--- trunk/Sources/PDoc.cpp	2008-04-08 14:54:05 UTC (rev 503)
+++ trunk/Sources/PDoc.cpp	2008-04-08 17:53:46 UTC (rev 504)
@@ -1487,6 +1487,18 @@
 				break;
 			}
 
+			case msg_PageSetup:
+			{
+				fText->PageSetup();
+				break;
+			}
+
+			case msg_Print:
+			{
+				fText->Print();
+				break;
+			}
+
 			default:
 			{
 				if ((msg->what & 0xffff0000) == 0x65780000)	// that's 'ex..'

Modified: trunk/Sources/PMessages.h
===================================================================
--- trunk/Sources/PMessages.h	2008-04-08 14:54:05 UTC (rev 503)
+++ trunk/Sources/PMessages.h	2008-04-08 17:53:46 UTC (rev 504)
@@ -47,6 +47,8 @@
 #define msg_Save						'Save'
 #define msg_SaveAs						'SvAs'
 #define msg_Revert						'Rvrt'
+#define msg_PageSetup					'PagS'
+#define msg_Print						'Prin'
 #define msg_Close						'Clse'
 #define msg_Quit						'Quit'
 #define msg_Undo						'Undo'

Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2008-04-08 14:54:05 UTC (rev 503)
+++ trunk/Sources/PText.cpp	2008-04-08 17:53:46 UTC (rev 504)
@@ -36,6 +36,7 @@
 #include "pe.h"
 
 #include <signal.h>
+#include <PrintJob.h>
 #include <String.h>
 
 #include "PText.h"
@@ -201,6 +202,7 @@
 	fAppendNextCut = false;
 	fLastKillPoint = -1;
 	fLastSavedStateCmd = NULL;
+	fPrintSettings = NULL;
 
 	fSoftWrap = gPrefs->GetPrefInt(prf_I_SoftWrap, false);
 	fWrapType = gPrefs->GetPrefInt(prf_I_WrapType, 3);
@@ -273,6 +275,7 @@
 	free(fCWD);
 	delete fMainPopUp;
 	delete fLineMap;
+	delete fPrintSettings;
 } /* PText::~PText */
 
 void PText::SetDefaultLanguageByExtension(const char *extension)
@@ -5418,6 +5421,130 @@
 		Draw(b);
 } /* PText::ShiftLinesPart2 */
 
+#pragma mark - Printing
+
+status_t PText::PageSetup()
+{
+	BPrintJob printJob(Window()->Title());
+
+	if (fPrintSettings) {
+		printJob.SetSettings(new BMessage(*fPrintSettings));
+	}
+
+	status_t result = printJob.ConfigPage();
+	if (result >= B_OK) {
+		delete fPrintSettings;
+		fPrintSettings = printJob.Settings();
+		//fPrintSettings->PrintToStream();
+	} else
+		FailOSErr(result);
+	return result;
+} /* PText::PageSetup */
+
+status_t PText::Print()
+{
+	status_t result;
+
+	if (fPrintSettings == NULL) {
+		result = PageSetup();
+		if (result < B_OK)
+			return result;
+	}
+
+	BPrintJob printJob(Window()->Title());
+	
+	// 
+	//fPrintSettings->PrintToStream();
+
+	printJob.SetSettings(new BMessage(*fPrintSettings));
+	result = printJob.ConfigJob();
+	FailOSErr(result);
+
+	// information from printJob
+	BRect printableRect = printJob.PrintableRect();	
+	int32 firstPage = printJob.FirstPage();
+	int32 lastPage = printJob.LastPage();
+   
+	// lines eventually to be used to compute pages to print
+	int32 firstLine = 0;
+	int32 lastLine = LineCount();
+
+	// values to be computed
+	int32 pagesInDocument = 1;
+	int32 linesInDocument = LineCount();
+
+	if (!printableRect.IsValid()) {
+		//FailOSErr(B_INVALID_PRINT_SETTINGS);
+		FailOSErr(B_BAD_VALUE);
+	}
+
+fprintf(stderr, "printableRect = {%f, %f, %f, %f}\n", printableRect.left, printableRect.top, printableRect.right, printableRect.bottom);
+fprintf(stderr, "firstLine = %d\n", firstLine);
+fprintf(stderr, "lastLine = %d\n", lastLine);
+fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
+fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+
+	int32 currentLine = 0;
+	while (currentLine < linesInDocument) {
+		float currentHeight = 0;
+//fprintf(stderr, "currentLine = %d\n", currentLine);
+		while (currentHeight < printableRect.Height() && currentLine < linesInDocument) {
+fprintf(stderr, "currentHeight = %d\n", currentHeight);
+			currentHeight += fLineHeight;
+			if (currentHeight < printableRect.Height())
+				currentLine++;
+		}
+		if (pagesInDocument == lastPage)
+			lastLine = currentLine;
+
+		if (currentHeight >= printableRect.Height()) {
+			pagesInDocument++;
+			if (pagesInDocument == firstPage)
+				firstLine = currentLine;
+		}
+	}
+
+	if (lastPage > pagesInDocument - 1) {
+		lastPage = pagesInDocument - 1;
+		lastLine = currentLine - 1;
+	}
+
+	
+fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
+fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+	printJob.BeginJob();
+	if (LineCount() > 0 && Size() > 0) {
+		int32 printLine = firstLine;
+		while (printLine <= lastLine) {
+fprintf(stderr, "printLine = %d\n", printLine);
+			float currentHeight = 0;
+			int32 firstLineOnPage = printLine;
+			while (currentHeight < printableRect.Height() && printLine <= lastLine) {
+fprintf(stderr, "currentHeight = %d\n", currentHeight);
+				currentHeight += fLineHeight;
+				if (currentHeight < printableRect.Height())
+					printLine++;
+			}
+
+			float top = 0;
+			if (firstLineOnPage != 0)
+				top = fLineHeight * firstLineOnPage;
+
+#define TEXT_INSET 3.0
+			float bottom = fLineHeight * printLine;
+			BRect textRect(0.0, top + TEXT_INSET, printableRect.Width(), bottom + TEXT_INSET);
+			printJob.DrawView(this, textRect, B_ORIGIN);
+			printJob.SpoolPage();
+		}
+	}
+	
+
+	printJob.CommitJob();
+
+	//FailOSErr(B_UNSUPPORTED);
+	return B_OK;
+} /* PText::Print */
+
 #pragma mark - Commands
 
 BFilePanel *gCwdPanel = NULL;
@@ -5959,6 +6086,13 @@
 				break;
 			}
 
+			case msg_PageSetup:
+				PageSetup();
+				break;
+			case msg_Print:
+				Print();
+				break;
+
 			case 'test':
 				ASSERT(false);
 				break;

Modified: trunk/Sources/PText.h
===================================================================
--- trunk/Sources/PText.h	2008-04-08 14:54:05 UTC (rev 503)
+++ trunk/Sources/PText.h	2008-04-08 17:53:46 UTC (rev 504)
@@ -163,6 +163,9 @@
 			void HideCaret();
 			void ShowCaret();
 			
+			status_t PageSetup();
+			status_t Print();
+
 			int FindWord(int key, bool subWord = false);
 			int FindWord(int indx, int key, bool mouseSelect = false, bool subWord = false);
 			int FindNextWord(int offset);
@@ -345,6 +348,7 @@
 			bool fAppendNextCut;
 			PCmd* fLastSavedStateCmd;
 			float fDefaultCharWidth;
+			BMessage *fPrintSettings;
 		
 static		PText *sfDragSource;
 



From mmu_man at mail.berlios.de  Tue Apr  8 20:25:53 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 8 Apr 2008 20:25:53 +0200
Subject: [pe-commits] r505 - trunk/Sources
Message-ID: <200804081825.m38IPr04024783@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-08 20:25:53 +0200 (Tue, 08 Apr 2008)
New Revision: 505
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=505&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
Simplify page count calculation as we use fixed height.


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2008-04-08 17:53:46 UTC (rev 504)
+++ trunk/Sources/PText.cpp	2008-04-08 18:25:53 UTC (rev 505)
@@ -5487,13 +5487,12 @@
 	int32 currentLine = 0;
 	while (currentLine < linesInDocument) {
 		float currentHeight = 0;
-//fprintf(stderr, "currentLine = %d\n", currentLine);
-		while (currentHeight < printableRect.Height() && currentLine < linesInDocument) {
-fprintf(stderr, "currentHeight = %d\n", currentHeight);
-			currentHeight += fLineHeight;
-			if (currentHeight < printableRect.Height())
-				currentLine++;
-		}
+fprintf(stderr, "currentLine = %d\n", currentLine);
+		// smallest of remaining lines or number of lines fitting the page
+		int32 lines = (int32)(MIN((1 + linesInDocument - currentLine), printableRect.Height() / fLineHeight));
+		currentHeight += fLineHeight * lines;
+		currentLine += lines;
+
 		if (pagesInDocument == lastPage)
 			lastLine = currentLine;
 
@@ -5516,15 +5515,13 @@
 	if (LineCount() > 0 && Size() > 0) {
 		int32 printLine = firstLine;
 		while (printLine <= lastLine) {
-fprintf(stderr, "printLine = %d\n", printLine);
+fprintf(stderr, "printLine = %d, lastLine = %d\n", printLine, lastLine);
 			float currentHeight = 0;
 			int32 firstLineOnPage = printLine;
-			while (currentHeight < printableRect.Height() && printLine <= lastLine) {
-fprintf(stderr, "currentHeight = %d\n", currentHeight);
-				currentHeight += fLineHeight;
-				if (currentHeight < printableRect.Height())
-					printLine++;
-			}
+			// smallest of remaining lines or number of lines fitting the page
+			int32 lines = (int32)(MIN((1 + lastLine - printLine), printableRect.Height() / fLineHeight));
+			currentHeight += fLineHeight * lines;
+			printLine += lines;
 
 			float top = 0;
 			if (firstLineOnPage != 0)



From mmu_man at mail.berlios.de  Tue Apr  8 23:34:15 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 8 Apr 2008 23:34:15 +0200
Subject: [pe-commits] r506 - trunk/Sources
Message-ID: <200804082134.m38LYF2q015020@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-08 23:34:14 +0200 (Tue, 08 Apr 2008)
New Revision: 506
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=506&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
Some preliminary work for sending metadata to the print driver (function index as bookmarks).


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2008-04-08 18:25:53 UTC (rev 505)
+++ trunk/Sources/PText.cpp	2008-04-08 21:34:14 UTC (rev 506)
@@ -5423,6 +5423,86 @@
 
 #pragma mark - Printing
 
+struct PrintFunctionRef {
+	int32 offset;
+	int32 line;
+	int32 page;
+	int32 level;
+	bool italic;
+	bool separator;
+	BString name;
+	BString params;
+};
+
+struct PrintFunctionScanHandler : public CFunctionScanHandler {
+	PrintFunctionScanHandler(bool sorted, int whichVal)
+		: sorted(sorted)
+		, which(whichVal)
+		, functionLevel(0)
+	{
+	}
+
+	void AddFunction(const char *name, const char *match, int offset,
+		bool italic, uint32 nestLevel, const char *params)
+	{
+		if (which != kFunctionsOnly)
+			return;
+
+		struct PrintFunctionRef *ref = new struct PrintFunctionRef;
+		ref->offset = offset;
+		ref->line = -1;//Offset2Line(offset);
+		ref->page = -1;
+		ref->level = functionLevel;
+		ref->italic = italic;
+		ref->separator = false;
+		ref->name = name;
+
+		functions.AddItem(ref);
+	}
+
+	void AddInclude(const char *name, const char *open, bool italic)
+	{
+		// we don't care
+	}
+
+	void AddSeparator(const char* name)
+	{
+		if (which != kFunctionsOnly)
+			return;
+
+		struct PrintFunctionRef *ref = new struct PrintFunctionRef;
+		ref->offset = -1;
+		ref->line = -1;
+		ref->page = -1;
+		ref->level = 0;
+		ref->italic = false;
+		ref->separator = false;
+		ref->name = name;
+
+		if (!sorted) {
+			// strip unnamed separators if followed by other separators:
+			struct PrintFunctionRef *last = static_cast<struct PrintFunctionRef *>(functions.LastItem());
+			if (last && last->separator /*&& last->name.Length() == 0*/) {
+				if (functions.RemoveItem(last))
+					delete last;
+			}
+			functions.AddItem(ref);
+		}
+		functionLevel = 1;
+	}
+
+	static int CompareFunc(const void *a, const void* b)
+	{
+		return strcasecmp((*(const struct PrintFunctionRef **)a)->name.String(),
+								(*(const struct PrintFunctionRef **)b)->name.String());
+	}
+
+	BList functions;
+	bool sorted;
+	int which;
+	int32 functionLevel;
+};
+
 status_t PText::PageSetup()
 {
 	BPrintJob printJob(Window()->Title());
@@ -5460,6 +5540,20 @@
 	result = printJob.ConfigJob();
 	FailOSErr(result);
 
+	// for later use (by PDF Writer)
+	/*
+	PrintFunctionScanHandler bookmarkHandler(false, kFunctionsOnly);
+	ScanForFunctions(bookmarkHandler);
+
+	for (int32 i = 0; i < bookmarkHandler.functions.CountItems(); i++) {
+		struct PrintFunctionRef *ref;
+		ref = (struct PrintFunctionRef *)bookmarkHandler.functions.ItemAt(i);
+		fprintf(stderr, "ref[%ld]: {%d, %d, %d, %d, %d, %d, '%s'}\n", i, 
+			ref->offset, ref->line, ref->page, ref->level, ref->italic, ref->separator, ref->name.String());
+
+	}
+	*/
+
 	// information from printJob
 	BRect printableRect = printJob.PrintableRect();	
 	int32 firstPage = printJob.FirstPage();
@@ -5511,7 +5605,10 @@
 	
 fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
 fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+
+	// let's do it!
 	printJob.BeginJob();
+	
 	if (LineCount() > 0 && Size() > 0) {
 		int32 printLine = firstLine;
 		while (printLine <= lastLine) {



From mmu_man at mail.berlios.de  Wed Apr  9 17:43:50 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Wed, 9 Apr 2008 17:43:50 +0200
Subject: [pe-commits] r507 - trunk/Sources
Message-ID: <200804091543.m39FhodG025964@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-09 17:43:49 +0200 (Wed, 09 Apr 2008)
New Revision: 507
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=507&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
Fix style on the code I added.


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2008-04-08 21:34:14 UTC (rev 506)
+++ trunk/Sources/PText.cpp	2008-04-09 15:43:49 UTC (rev 507)
@@ -5507,16 +5507,17 @@
 {
 	BPrintJob printJob(Window()->Title());
 
-	if (fPrintSettings) {
+	if (fPrintSettings)
 		printJob.SetSettings(new BMessage(*fPrintSettings));
-	}
 
 	status_t result = printJob.ConfigPage();
-	if (result >= B_OK) {
+	if (result >= B_OK)
+	{
 		delete fPrintSettings;
 		fPrintSettings = printJob.Settings();
 		//fPrintSettings->PrintToStream();
-	} else
+	}
+	else
 		FailOSErr(result);
 	return result;
 } /* PText::PageSetup */
@@ -5525,7 +5526,8 @@
 {
 	status_t result;
 
-	if (fPrintSettings == NULL) {
+	if (fPrintSettings == NULL)
+	{
 		result = PageSetup();
 		if (result < B_OK)
 			return result;
@@ -5545,7 +5547,8 @@
 	PrintFunctionScanHandler bookmarkHandler(false, kFunctionsOnly);
 	ScanForFunctions(bookmarkHandler);
 
-	for (int32 i = 0; i < bookmarkHandler.functions.CountItems(); i++) {
+	for (int32 i = 0; i < bookmarkHandler.functions.CountItems(); i++)
+	{
 		struct PrintFunctionRef *ref;
 		ref = (struct PrintFunctionRef *)bookmarkHandler.functions.ItemAt(i);
 		fprintf(stderr, "ref[%ld]: {%d, %d, %d, %d, %d, %d, '%s'}\n", i, 
@@ -5567,21 +5570,23 @@
 	int32 pagesInDocument = 1;
 	int32 linesInDocument = LineCount();
 
-	if (!printableRect.IsValid()) {
+	if (!printableRect.IsValid())
+	{
 		//FailOSErr(B_INVALID_PRINT_SETTINGS);
 		FailOSErr(B_BAD_VALUE);
 	}
 
-fprintf(stderr, "printableRect = {%f, %f, %f, %f}\n", printableRect.left, printableRect.top, printableRect.right, printableRect.bottom);
-fprintf(stderr, "firstLine = %d\n", firstLine);
-fprintf(stderr, "lastLine = %d\n", lastLine);
-fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
-fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+	fprintf(stderr, "printableRect = {%f, %f, %f, %f}\n", printableRect.left, printableRect.top, printableRect.right, printableRect.bottom);
+	fprintf(stderr, "firstLine = %d\n", firstLine);
+	fprintf(stderr, "lastLine = %d\n", lastLine);
+	fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
+	fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
 
 	int32 currentLine = 0;
-	while (currentLine < linesInDocument) {
+	while (currentLine < linesInDocument)
+	{
 		float currentHeight = 0;
-fprintf(stderr, "currentLine = %d\n", currentLine);
+		fprintf(stderr, "currentLine = %d\n", currentLine);
 		// smallest of remaining lines or number of lines fitting the page
 		int32 lines = (int32)(MIN((1 + linesInDocument - currentLine), printableRect.Height() / fLineHeight));
 		currentHeight += fLineHeight * lines;
@@ -5590,29 +5595,33 @@
 		if (pagesInDocument == lastPage)
 			lastLine = currentLine;
 
-		if (currentHeight >= printableRect.Height()) {
+		if (currentHeight >= printableRect.Height())
+		{
 			pagesInDocument++;
 			if (pagesInDocument == firstPage)
 				firstLine = currentLine;
 		}
 	}
 
-	if (lastPage > pagesInDocument - 1) {
+	if (lastPage > pagesInDocument - 1)
+	{
 		lastPage = pagesInDocument - 1;
 		lastLine = currentLine - 1;
 	}
 
 	
-fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
-fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+	fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
+	fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
 
 	// let's do it!
 	printJob.BeginJob();
 	
-	if (LineCount() > 0 && Size() > 0) {
+	if (LineCount() > 0 && Size() > 0)
+	{
 		int32 printLine = firstLine;
-		while (printLine <= lastLine) {
-fprintf(stderr, "printLine = %d, lastLine = %d\n", printLine, lastLine);
+		while (printLine <= lastLine)
+		{
+			fprintf(stderr, "printLine = %d, lastLine = %d\n", printLine, lastLine);
 			float currentHeight = 0;
 			int32 firstLineOnPage = printLine;
 			// smallest of remaining lines or number of lines fitting the page



From mmu_man at mail.berlios.de  Wed Apr  9 17:57:05 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Wed, 9 Apr 2008 17:57:05 +0200
Subject: [pe-commits] r508 - trunk/Extensions
Message-ID: <200804091557.m39Fv5iT026984@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-09 17:57:05 +0200 (Wed, 09 Apr 2008)
New Revision: 508
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=508&view=rev

Modified:
   trunk/Extensions/Jamfile
   trunk/Extensions/WebPaste.cpp
Log:
Map language names on best effort. Also pass tabstops info.


Modified: trunk/Extensions/Jamfile
===================================================================
--- trunk/Extensions/Jamfile	2008-04-09 15:43:49 UTC (rev 507)
+++ trunk/Extensions/Jamfile	2008-04-09 15:57:05 UTC (rev 508)
@@ -122,6 +122,6 @@
 # <pe-src>
 PeExtension WebPaste 
 	: WebPaste.cpp 
-	: libhekkel.so be
+	: libhekkel.so <nogrist>pe be $(STDC++LIB)
 	;
 # </pe-src>

Modified: trunk/Extensions/WebPaste.cpp
===================================================================
--- trunk/Extensions/WebPaste.cpp	2008-04-09 15:43:49 UTC (rev 507)
+++ trunk/Extensions/WebPaste.cpp	2008-04-09 15:57:05 UTC (rev 508)
@@ -10,12 +10,56 @@
 // maybe later add configurable multiple handlers ?
 
 #include "PeAddOn.h"
+#include "PDoc.h"
+#include "PText.h"
+#include "CLanguageInterface.h"
 #include <stdio.h>
 
 #define PASTE_URL "http://rafb.net/paste/paste.php"
 #define OPEN_IN_BROWSER 1
 #define COPY_TO_CLIPBOARD 1
 
+struct {
+	const char *pe_name;
+	const char *cgi_name;
+} kLanguageNamesMap[] = {
+/*
+	{ "Antlr",	""	},
+	{ "ASM-x86",	""	},
+	{ "D",	""	},
+	{ "Diff",	""	},
+	{ "HTML-CSS-JS-PHP",	""	},
+	{ "HTML-JS",	""	},
+	{ "HTML",	""	},
+	{ "Jam",	""	},
+	{ "Lout",	""	},
+	{ "Lua",	""	},
+	{ "Mathematica",	""	},
+	{ "Oberon-2",	""	},
+	{ "Rez",	""	},
+	{ "Shell",	""	},
+	{ "TeX",	""	},
+*/
+	//{ ,	"C89"	/*C (C89)*/ }
+	//{ ,	"C"	/*C (C99)*/ },
+	{ "C/C++",	"C++"	},
+	//{ ,	"C#"	},
+	{ "Java",	"Java"	},
+	{ "Pascal",	"Pascal"	},
+	{ "Perl",	"Perl"	},
+	//{ ,	"PHP"	},
+	//{ ,	"PL/I"	},
+	{ "Python",	"Python"	},
+	//{ ,	"Ruby"	},
+	//{ ,	"Scheme"	},
+	{ "SQL",	"SQL"	},
+	//{ ,	"VB"	},
+	//{ ,	"XML"	},
+	/*{ ,	"Plain Text Wrap"	},
+	{ ,	"Plain Text"	},*/
+	{ NULL, NULL }
+};
+
 //------------------------------------------------------------------------------
 //	#pragma mark - class StdIOInString
 
@@ -60,23 +104,22 @@
 static const char *PeLangToPasteLang(const char *lang);
 static status_t UrlEscape(BString &str);
 status_t POpenOut(const char *cmd, BString &output);
-static status_t RunWgetPaste(const char *language, const char *nick, const char *desc, const char *text);
+static status_t RunWgetPaste(const char *language, const char *nick, const char *desc, int tabstops, const char *text);
 
 //------------------------------------------------------------------------------
 
 const char *
 PeLangToPasteLang(const char *lang)
 {
+	int i;
 	BString l(lang);
-	if (l == "C")
-		return "C (99)";
-	if (l == "C++")
-		return "C++";
-	if (l == "Java")
-		return "Java";
-	//XXX
+	for (i = 0; kLanguageNamesMap[i].pe_name; i++)
+	{
+		if (l == kLanguageNamesMap[i].pe_name)
+			return kLanguageNamesMap[i].cgi_name;
+	}
 	return "Plain Text";
-	
+	//return "Plain Text Wrap";
 }
 
 status_t
@@ -123,21 +166,28 @@
 // http://rafb.net/p/ngZGZU48.html
 
 status_t
-RunWgetPaste(const char *language, const char *nick, const char *desc, const char *text)
+RunWgetPaste(const char *language, const char *nick, const char *desc, int tabstops, const char *text)
 {
 	BString langStr(PeLangToPasteLang(language));
 	BString nickStr(nick);
 	BString descStr(desc);
 	BString textStr(text);
+	BString tabsStr;
+	nickStr.Truncate(30);
+	descStr.Truncate(50);
 	UrlEscape(langStr);
 	UrlEscape(nickStr);
 	UrlEscape(descStr);
 	UrlEscape(textStr);
+	if (tabstops)
+		tabsStr << tabstops;
+	else
+		tabsStr << "No";
 	BString postStr;
 	postStr << "lang=" << langStr << "&";
 	postStr << "nick=" << nickStr << "&";
 	postStr << "desc=" << descStr << "&";
-	postStr << "cvt_tabs=No" << "&";
+	postStr << "cvt_tabs=" << tabsStr << "&";
 	postStr << "text=" << textStr;
 	
 	BString command("wget");
@@ -240,13 +290,29 @@
 	selection.SetTo(addon->Text() + selStart, length);
 	
 	BString description;
-	if (addon->Window()) {
+	BString language("C++");
+	BString nickname("unknown");
+	int tabstops = 0;
+	if (addon->Window())
+	{
 		description = addon->Window()->Title();
+		PDoc *doc = dynamic_cast<PDoc *>(addon->Window());
+		if (doc && doc->TextView())
+		{
+			CLanguageInterface *langintf;
+			langintf = CLanguageInterface::FindIntf(doc->TextView()->Language());
+			if (langintf)
+				language = langintf->Name();
+			tabstops = doc->TextView()->TabStops();
+		}
 	}
+	
+	
 
-	err = RunWgetPaste("C++", 
-		"unknown", 
+	err = RunWgetPaste(language.String(), 
+		nickname.String(), 
 		description.String(), 
+		tabstops,
 		selection.String());
 	if (err >= B_OK)
 		return B_OK;
@@ -262,3 +328,4 @@
 
 	return B_OK;
 }
+



From mmu_man at mail.berlios.de  Thu Apr 10 18:45:16 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Thu, 10 Apr 2008 18:45:16 +0200
Subject: [pe-commits] r509 - trunk/Extensions
Message-ID: <200804101645.m3AGjG0r005142@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-10 18:45:15 +0200 (Thu, 10 Apr 2008)
New Revision: 509
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=509&view=rev

Modified:
   trunk/Extensions/WebPaste.cpp
Log:
Using -1 as index to a C array... bad.
This fixes WebPasting when no language is selected.


Modified: trunk/Extensions/WebPaste.cpp
===================================================================
--- trunk/Extensions/WebPaste.cpp	2008-04-09 15:57:05 UTC (rev 508)
+++ trunk/Extensions/WebPaste.cpp	2008-04-10 16:45:15 UTC (rev 509)
@@ -299,8 +299,10 @@
 		PDoc *doc = dynamic_cast<PDoc *>(addon->Window());
 		if (doc && doc->TextView())
 		{
-			CLanguageInterface *langintf;
-			langintf = CLanguageInterface::FindIntf(doc->TextView()->Language());
+			CLanguageInterface *langintf = NULL;
+			int lang = doc->TextView()->Language();
+			if (lang > -1)
+				langintf = CLanguageInterface::FindIntf(lang);
 			if (langintf)
 				language = langintf->Name();
 			tabstops = doc->TextView()->TabStops();



From zooey at mail.berlios.de  Sat Apr 12 11:10:45 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 11:10:45 +0200
Subject: [pe-commits] r510 - trunk
Message-ID: <200804120910.m3C9Aj1X029183@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 11:10:44 +0200 (Sat, 12 Apr 2008)
New Revision: 510
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=510&view=rev

Modified:
   trunk/Jamrules
Log:
* added link to documentation on top level of distribution folder


Modified: trunk/Jamrules
===================================================================
--- trunk/Jamrules	2008-04-10 16:45:15 UTC (rev 509)
+++ trunk/Jamrules	2008-04-12 09:10:44 UTC (rev 510)
@@ -47,6 +47,7 @@
 	cp -a $(TOP)/doc/*.html $(DISTRO_DIR)/Documentation/ ;
 	mkdir $(DISTRO_DIR)/Documentation/gifs ;
 	cp -a $(TOP)/doc/gifs/*.gif $(DISTRO_DIR)/Documentation/gifs/ ;
+	ln -sf Documentation/index.html $(DISTRO_DIR)/Documentation.html ;
 	ln -sf /boot/home/config/bin/ $(DISTRO_DIR)/\(drag\ lpe\ here\ to\ install\) ;
 	cp -a /boot/home/config/lib/libpcre*.so $(DISTRO_DIR)/lib/ ;
 }



From zooey at mail.berlios.de  Sat Apr 12 11:18:14 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 11:18:14 +0200
Subject: [pe-commits] r511 - branches
Message-ID: <200804120918.m3C9IE8A030093@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 11:18:14 +0200 (Sat, 12 Apr 2008)
New Revision: 511
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=511&view=rev

Added:
   branches/model-based-editing/
Log:
* created branch for model-based editing



Copied: branches/model-based-editing (from rev 510, trunk)



From zooey at mail.berlios.de  Sat Apr 12 11:57:33 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 11:57:33 +0200
Subject: [pe-commits] r512 - trunk/Sources
Message-ID: <200804120957.m3C9vXmQ002910@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 11:57:33 +0200 (Sat, 12 Apr 2008)
New Revision: 512
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=512&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
* fixed warnings about mismatching printf args & formats

Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2008-04-12 09:18:14 UTC (rev 511)
+++ trunk/Sources/PText.cpp	2008-04-12 09:57:33 UTC (rev 512)
@@ -5577,16 +5577,16 @@
 	}
 
 	fprintf(stderr, "printableRect = {%f, %f, %f, %f}\n", printableRect.left, printableRect.top, printableRect.right, printableRect.bottom);
-	fprintf(stderr, "firstLine = %d\n", firstLine);
-	fprintf(stderr, "lastLine = %d\n", lastLine);
-	fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
-	fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+	fprintf(stderr, "firstLine = %ld\n", firstLine);
+	fprintf(stderr, "lastLine = %ld\n", lastLine);
+	fprintf(stderr, "pagesInDocument = %ld\n", pagesInDocument);
+	fprintf(stderr, "linesInDocument = %ld\n", linesInDocument);
 
 	int32 currentLine = 0;
 	while (currentLine < linesInDocument)
 	{
 		float currentHeight = 0;
-		fprintf(stderr, "currentLine = %d\n", currentLine);
+		fprintf(stderr, "currentLine = %ld\n", currentLine);
 		// smallest of remaining lines or number of lines fitting the page
 		int32 lines = (int32)(MIN((1 + linesInDocument - currentLine), printableRect.Height() / fLineHeight));
 		currentHeight += fLineHeight * lines;
@@ -5610,8 +5610,8 @@
 	}
 
 	
-	fprintf(stderr, "pagesInDocument = %d\n", pagesInDocument);
-	fprintf(stderr, "linesInDocument = %d\n", linesInDocument);
+	fprintf(stderr, "pagesInDocument = %ld\n", pagesInDocument);
+	fprintf(stderr, "linesInDocument = %ld\n", linesInDocument);
 
 	// let's do it!
 	printJob.BeginJob();
@@ -5621,7 +5621,7 @@
 		int32 printLine = firstLine;
 		while (printLine <= lastLine)
 		{
-			fprintf(stderr, "printLine = %d, lastLine = %d\n", printLine, lastLine);
+			fprintf(stderr, "printLine = %ld, lastLine = %ld\n", printLine, lastLine);
 			float currentHeight = 0;
 			int32 firstLineOnPage = printLine;
 			// smallest of remaining lines or number of lines fitting the page



From zooey at mail.berlios.de  Sat Apr 12 13:43:36 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 13:43:36 +0200
Subject: [pe-commits] r513 - trunk/Sources
Message-ID: <200804121143.m3CBhaFH009491@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 13:43:36 +0200 (Sat, 12 Apr 2008)
New Revision: 513
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=513&view=rev

Modified:
   trunk/Sources/Prefs.h
Log:
* sorted prefs entries in order to make scanning for an item easier


Modified: trunk/Sources/Prefs.h
===================================================================
--- trunk/Sources/Prefs.h	2008-04-12 09:57:33 UTC (rev 512)
+++ trunk/Sources/Prefs.h	2008-04-12 11:43:36 UTC (rev 513)
@@ -19,32 +19,32 @@
 const char* const prf_X_SearchPath				= "searchpath";
 const char* const prf_X_StdErrPattern			= "stderrpattern";
 
-const char* const prf_C_Low						= "low color";
-const char* const prf_C_Text					= "text color";
+const char* const prf_C_Attribute				= "attribute color";
+const char* const prf_C_CharConst				= "char constant color";
 const char* const prf_C_Comment1				= "comment color";
 const char* const prf_C_Comment2				= "alt comment color";
 const char* const prf_C_Error1					= "error color";
 const char* const prf_C_Error2					= "alt error color";
+const char* const prf_C_IdentifierSystem		= "system identifier color";
+const char* const prf_C_IdentifierUser			= "user identifier color";
+const char* const prf_C_Invisibles				= "invisibles color";
+const char* const prf_C_Keyword1				= "keyword color";
 const char* const prf_C_Keyword2				= "alt keyword color";
+const char* const prf_C_Low						= "low color";
+const char* const prf_C_Mark					= "mark color";
 const char* const prf_C_Number1					= "number color";
 const char* const prf_C_Number2					= "alt number color";
 const char* const prf_C_Operator1				= "operator color";
 const char* const prf_C_Operator2				= "alt operator color";
-const char* const prf_C_Separator1				= "separator color";
-const char* const prf_C_Separator2				= "alt separator color";
 const char* const prf_C_Preprocessor1			= "preprocessor color";
 const char* const prf_C_Preprocessor2			= "altprocessor color";
-const char* const prf_C_CharConst				= "char constant color";
-const char* const prf_C_Invisibles				= "invisibles color";
-const char* const prf_C_Keyword1				= "keyword color";
-const char* const prf_C_Mark					= "mark color";
 const char* const prf_C_Selection				= "selection color";
+const char* const prf_C_Separator1				= "separator color";
+const char* const prf_C_Separator2				= "alt separator color";
 const char* const prf_C_String1					= "string color";
 const char* const prf_C_String2					= "tagstring color";
-const char* const prf_C_IdentifierSystem		= "system identifier color";
 const char* const prf_C_Tag						= "tag color";
-const char* const prf_C_Attribute				= "attribute color";
-const char* const prf_C_IdentifierUser			= "user identifier color";
+const char* const prf_C_Text					= "text color";
 const char* const prf_C_UserSet1				= "user1";
 const char* const prf_C_UserSet2				= "user2";
 const char* const prf_C_UserSet3				= "user3";
@@ -54,40 +54,26 @@
 const char* const prf_D_AltFontSize				= "alt font size";
 const char* const prf_D_FontSize				= "font size";
 
-const char* const prf_I_SearchBackwards			= "Search Backwards";
-const char* const prf_I_SearchBatch				= "Search Batch";
-const char* const prf_I_SearchEntireWord		= "Search Entire Word";
-const char* const prf_I_SearchIgnoreCase		= "Search Ignore Case";
-const char* const prf_I_SearchMultikind			= "Search Multikind";
-const char* const prf_I_SearchRecursive			= "Search Recursive";
-const char* const prf_I_SearchTextFilesOnly		= "Search Text Files Only";
-const char* const prf_I_SearchWhichDir			= "Search Whichdir";
-const char* const prf_I_SearchWrap				= "Search Wrap";
-const char* const prf_I_SearchWithGrep			= "Search with Grep";
 const char* const prf_I_AltFontSize				= "alt font size";
 const char* const prf_I_AltHome					= "althome";
 const char* const prf_I_AutoIndent				= "auto indent";
 const char* const prf_I_AutodetectProjects		= "autodetect projects";
-const char* const prf_I_MakeBackup				= "backup";
 const char* const prf_I_BalanceWhileTyping		= "balance";
 const char* const prf_I_BeIncludes				= "beincludes";
 const char* const prf_I_BlockCursor				= "block cursor";
 const char* const prf_I_CenterFoundString		= "centerfound";
+const char* const prf_I_ContextChars			= "contextchars";
 const char* const prf_I_ContextLines			= "contextlines";
-const char* const prf_I_ContextChars			= "contextchars";
 const char* const prf_I_DiffCaseInsensitive		= "diffcase";
 const char* const prf_I_DiffIgnoreWhiteSpace	= "diffwhite";
+const char* const prf_I_EndWithNewline			= "nl at eof";
 const char* const prf_I_FlashCursor				= "flash cursor";
 const char* const prf_I_FontSize				= "font size";
 const char* const prf_I_FullPathInTitle			= "fullpath";
-const char* const prf_I_ShowBeIdeMenu			= "ide menu";
-const char* const prf_I_ShowIncludes			= "includes";
 const char* const prf_I_InclSearchIgnoreCase	= "isearch_igncase";
 const char* const prf_I_LoadBeIdeExt			= "mw plugins";
-const char* const prf_I_EndWithNewline			= "nl at eof";
-const char* const prf_I_SearchParent			= "parent";
+const char* const prf_I_MakeBackup				= "backup";
 const char* const prf_I_PassiveFtp				= "passive ftp";
-const char* const prf_I_ShowPrototypes			= "protos";
 const char* const prf_I_RecentSize				= "recent size";
 const char* const prf_I_RedirectStdErr			= "redirect stderr";
 const char* const prf_I_RelativeGroupPaths		= "relative group paths";
@@ -99,15 +85,30 @@
 const char* const prf_I_SavedState				= "saved state";
 const char* const prf_I_ScrollwheelLines		= "scrollwheel lines";
 						// Currently not in GUI
-const char* const prf_I_ShowPaletteForHtml		= "show htmlpalette for html";
+const char* const prf_I_SearchBackwards			= "Search Backwards";
+const char* const prf_I_SearchBatch				= "Search Batch";
+const char* const prf_I_SearchEntireWord		= "Search Entire Word";
+const char* const prf_I_SearchIgnoreCase		= "Search Ignore Case";
+const char* const prf_I_SearchMultikind			= "Search Multikind";
+const char* const prf_I_SearchParent			= "parent";
+const char* const prf_I_SearchRecursive			= "Search Recursive";
+const char* const prf_I_SearchTextFilesOnly		= "Search Text Files Only";
+const char* const prf_I_SearchWhichDir			= "Search Whichdir";
+const char* const prf_I_SearchWithGrep			= "Search with Grep";
+const char* const prf_I_SearchWrap				= "Search Wrap";
+const char* const prf_I_ShowBeIdeMenu			= "ide menu";
+const char* const prf_I_ShowGlossary			= "showglossary";
 const char* const prf_I_ShowHtmlPalette			= "show htmlpalette";
+const char* const prf_I_ShowIncludes			= "includes";
 const char* const prf_I_ShowInvisibles			= "show invisibles";
+const char* const prf_I_ShowPaletteForHtml		= "show htmlpalette for html";
+const char* const prf_I_ShowPrototypes			= "protos";
 const char* const prf_I_ShowTabs				= "show tabs";
-const char* const prf_I_ShowGlossary			= "showglossary";
 const char* const prf_I_SingleClickGlossary		= "singleclickglossary";
 const char* const prf_I_SkipHtmlExt				= "skiphtmlext";
 const char* const prf_I_SkipTmpFiles			= "skiptmp";
 const char* const prf_I_SmartBraces				= "smart braces";
+const char* const prf_I_SmartWorkspaces			= "window to workspace";
 const char* const prf_I_SoftWrap				= "softwrap";
 const char* const prf_I_SortGroup				= "sortgroup";
 const char* const prf_I_SortPopup				= "sortpopup";
@@ -118,15 +119,14 @@
 const char* const prf_I_SyntaxColoring			= "syntax coloring";
 const char* const prf_I_ShowTypes				= "types";
 const char* const prf_I_VerifyOpenFiles			= "verify";
-const char* const prf_I_SmartWorkspaces			= "window to workspace";
 const char* const prf_I_Worksheet				= "worksheet";
 const char* const prf_I_WrapCol					= "wrapcol";
 const char* const prf_I_WrapType				= "wraptype";
 const char* const prf_I_ZoomOpenPanel			= "zoomopen";
 
+const char* const prf_R_DefaultDocumentRect		= "default document rect";
 const char* const prf_R_GlossaryPosition		= "GlossaryPosition";
 const char* const prf_R_HtmlPalettePos			= "HTMLPalettePos";
-const char* const prf_R_DefaultDocumentRect		= "default document rect";
 
 const char* const prf_S_AltFontFamily			= "alt font family";
 const char* const prf_S_AltFontStyle			= "alt font style";



From zooey at mail.berlios.de  Sat Apr 12 13:53:53 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 13:53:53 +0200
Subject: [pe-commits] r514 - trunk/Sources
Message-ID: <200804121153.m3CBrruP011009@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 13:53:47 +0200 (Sat, 12 Apr 2008)
New Revision: 514
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=514&view=rev

Modified:
   trunk/Sources/PText.cpp
Log:
* instead of inserting dropped files a the drop position, they now get opened
  as documents (dragging text fragments between windows works as before)


Modified: trunk/Sources/PText.cpp
===================================================================
--- trunk/Sources/PText.cpp	2008-04-12 11:43:36 UTC (rev 513)
+++ trunk/Sources/PText.cpp	2008-04-12 11:53:47 UTC (rev 514)
@@ -2170,94 +2170,66 @@
 {
 	fWindowActive = Window()->IsActive();
 
-	char *s = NULL;
-	ssize_t sl;
-
 	if (msg->HasData("text/plain", B_MIME_TYPE))
 	{
-		char *t;
+		char *s;
+		ssize_t sl;
 
-		FailOSErr(msg->FindData("text/plain", B_MIME_TYPE, (const void**)&t, &sl));
-		s = new char[sl];
-		FailNil(s);
-		memcpy(s, t, sl);
-	}
-	else if (msg->HasRef("refs"))
-	{
-		entry_ref ref;
-
-		FailOSErr(msg->FindRef("refs", &ref));
-
-		BFile file;
-		FailOSErr(file.SetTo(&ref, B_READ_ONLY));
-
-		key_info ki;
-		if (get_key_info(&ki) == B_OK && ki.modifiers & (B_COMMAND_KEY | B_OPTION_KEY))
-			be_app->RefsReceived(msg);
-		else
+		FailOSErr(msg->FindData("text/plain", B_MIME_TYPE, (const void**)&s, &sl));
+		if (s)
 		{
-			char m[B_MIME_TYPE_LENGTH];
-			BNodeInfo(&file).GetType(m);
-
-			if (strncmp(m, "text/", 5) == 0)
+			int offset;
+			if (msg->IsSourceRemote() || msg->IsSystem() || sfDragSource != this)
+				offset = -1;
+			else if (fDragButtons & B_TERTIARY_MOUSE_BUTTON)
+				offset = -1;
+			else if (fDragButtons & B_SECONDARY_MOUSE_BUTTON)
 			{
-				sl = file.Seek(0, SEEK_END);
-				file.Seek(0, SEEK_SET);
-
-				s = new char[sl];
-				if (file.Read(s, sl) != sl)
-					THROW(("Read Error"));
+				BPopUpMenu popup("copy or move");
+				popup.SetFont(be_plain_font);
+				popup.AddItem(new BMenuItem("Move", NULL));
+				popup.AddItem(new BMenuItem("Copy", NULL));
+				BMenuItem *item = popup.Go(msg->DropPoint(), false, true);
+	
+				if (!item)
+				{
+					HideCaret();
+					fAnchor = fSavedAnchor;
+					fCaret = fSavedCaret;
+					return;
+				}
+	
+				if (popup.IndexOf(item) == 0)
+					offset = fDragStart;
+				else
+					offset = -1;
 			}
-		}
-	}
-
-	if (s)
-	{
-		int offset;
-		if (msg->IsSourceRemote() || msg->IsSystem() || sfDragSource != this)
-			offset = -1;
-		else if (fDragButtons & B_TERTIARY_MOUSE_BUTTON)
-			offset = -1;
-		else if (fDragButtons & B_SECONDARY_MOUSE_BUTTON)
-		{
-			BPopUpMenu popup("copy or move");
-			popup.SetFont(be_plain_font);
-			popup.AddItem(new BMenuItem("Move", NULL));
-			popup.AddItem(new BMenuItem("Copy", NULL));
-			BMenuItem *item = popup.Go(msg->DropPoint(), false, true);
-
-			if (!item)
-			{
-				HideCaret();
-				fAnchor = fSavedAnchor;
-				fCaret = fSavedCaret;
-				return;
-			}
-
-			if (popup.IndexOf(item) == 0)
-				offset = fDragStart;
 			else
-				offset = -1;
-		}
-		else
-			offset = fDragStart;
-
-		if (offset == -1 || fCaret < offset || fCaret > offset + sl)
-		{
-			if (sfDragSource == this)
+				offset = fDragStart;
+	
+			if (offset == -1 || fCaret < offset || fCaret > offset + sl)
 			{
-				int a, c;
-
-				a = Offset2Line(fSavedAnchor);
-				c = Offset2Line(fSavedCaret);
-				TouchLines(min(a, c), max(a, c));
+				if (sfDragSource == this)
+				{
+					int a, c;
+	
+					a = Offset2Line(fSavedAnchor);
+					c = Offset2Line(fSavedCaret);
+					TouchLines(min(a, c), max(a, c));
+				}
+				RegisterCommand(new PDropCmd(this, s, sl, offset, fCaret));
 			}
-			RegisterCommand(new PDropCmd(this, s, sl, offset, fCaret));
 		}
-
-		if (msg->HasRef("refs"))
-			delete s;
 	}
+	else if (msg->HasRef("refs"))
+	{
+		// open all dropped files as documents:
+		BMessage openMsg(B_REFS_RECEIVED);
+		entry_ref ref;
+		for(int32 i=0; msg->FindRef("refs", i, &ref) == B_OK; ++i)
+			openMsg.AddRef("refs", &ref);
+		be_app_messenger.SendMessage(&openMsg);
+	}
 } /* PText::HandleDrop */
 
 bool PText::WaitMouseMoved(BPoint where)



From zooey at mail.berlios.de  Sat Apr 12 14:33:26 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 14:33:26 +0200
Subject: [pe-commits] r515 - in branches/model-based-editing:
	Languages/Sources Sources
Message-ID: <200804121233.m3CCXQiY015130@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 14:33:24 +0200 (Sat, 12 Apr 2008)
New Revision: 515
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=515&view=rev

Added:
   branches/model-based-editing/Sources/CTextBuffer.cpp
   branches/model-based-editing/Sources/CTextBuffer.h
   branches/model-based-editing/Sources/CTextEditor.cpp
   branches/model-based-editing/Sources/CTextEditor.h
Removed:
   branches/model-based-editing/Sources/PTextBuffer.cpp
   branches/model-based-editing/Sources/PTextBuffer.h
Modified:
   branches/model-based-editing/Languages/Sources/HtmlCssJsPhp_Popup.cpp
   branches/model-based-editing/Sources/CLanguageInterface.cpp
   branches/model-based-editing/Sources/CLanguageInterface.h
   branches/model-based-editing/Sources/Jamfile
   branches/model-based-editing/Sources/MTextAddOnImpl.cpp
   branches/model-based-editing/Sources/PAbout.cpp
   branches/model-based-editing/Sources/PAddOn.cpp
   branches/model-based-editing/Sources/PCmd.cpp
   branches/model-based-editing/Sources/PCmd.h
   branches/model-based-editing/Sources/PDoc.cpp
   branches/model-based-editing/Sources/PDoc.h
   branches/model-based-editing/Sources/PText.cpp
   branches/model-based-editing/Sources/PText.h
Log:
Started to work on model-based editing:
* added CTextEditor and temporarily made it a base class of PText (since PText
  is being used by addons and we want to migrate a lot of methods from PText
  to CTextEditor)
* added empty stubs for CTextStructure, CTextSelection and CTextSearch
* renamed PTextBuffer to CTextBuffer and removed all external references to it 
  (only CTextEditor + its implementation classes will access the buffer from now on)
* wrapped the CTextBuffer interface in CTextEditor (which simply double dispatches
  to CTextBuffer)
Seems to work the same as before.



Modified: branches/model-based-editing/Languages/Sources/HtmlCssJsPhp_Popup.cpp
===================================================================
--- branches/model-based-editing/Languages/Sources/HtmlCssJsPhp_Popup.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Languages/Sources/HtmlCssJsPhp_Popup.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -56,6 +56,10 @@
 	const char * position;
 	bool italic;
 	
+#ifdef __MWERKS__
+	PopupMenu () {};
+#endif
+
 //	PopupMenu (const char *lab, const char *txt, const char * pos)
 //		: label(lab), text(txt), position(pos) {}
 	
@@ -455,7 +459,7 @@
 
 const char *PhpScript(const char *txt, PopupList &lstPhpFunctions, PopupList &lstPhpClasses, bool sorted)
 {
-	map <int,int,int> headings;
+	map <int,int> headings;
 	BString class_name;
 	while (*txt)
 	{

Modified: branches/model-based-editing/Sources/CLanguageInterface.cpp
===================================================================
--- branches/model-based-editing/Sources/CLanguageInterface.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/CLanguageInterface.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -46,6 +46,7 @@
 #include "HColorUtils.h"
 #include "ResourcesMisc.h"
 #include "Prefs.h"
+#include "utf-support.h"
 #include <algorithm>
 
 unsigned char *CLanguageInterface::sfWordBreakTable = NULL;
@@ -474,7 +475,7 @@
 				size = min(text.LineStart(line + 1) - offset, 1024);
 
 			CAlloca txt(size + 1);
-			text.TextBuffer().Copy(txt, offset, size);
+			text.CopyText(txt, offset, size);
 			txt[size] = 0;
 
 			CLanguageProxy proxy(*this, txt, size);
@@ -496,7 +497,7 @@
 
 			while (state > 0 && i < text.Size())
 			{
-				text.TextBuffer().CharInfo(i, unicode, len);
+				text.CharInfo(i, unicode, len);
 
 				int cl = 0;
 
@@ -780,7 +781,7 @@
 						end = start + strcspn(start, "\n");
 					}
 				} else {
-					fKeywordMap.insert(pair<BString, int>(word, currType));
+					fKeywordMap.insert(pair<const BString, int>(word, currType));
 				}
 				start = end + strspn(end, white);
 				end = start + strcspn(start, white);

Modified: branches/model-based-editing/Sources/CLanguageInterface.h
===================================================================
--- branches/model-based-editing/Sources/CLanguageInterface.h	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/CLanguageInterface.h	2008-04-12 12:33:24 UTC (rev 515)
@@ -69,10 +69,10 @@
 static	void SetupLanguageInterfaces();
 static	CLanguageInterface* FindIntf(int index)	{ return fInterfaces[index]; }
 static	CLanguageInterface* FindByExtension(const char *filename);
-static CLanguageInterface* FindByName(const char *language);
+static  CLanguageInterface* FindByName(const char *language);
 
-static CLanguageInterface* NextIntf(int& cookie);
-static int GetIndex(const CLanguageInterface* intf);
+static  CLanguageInterface* NextIntf(int& cookie);
+static  int GetIndex(const CLanguageInterface* intf);
 
 		const char* LineCommentStart() const;
 		const char* LineCommentEnd() const;

Copied: branches/model-based-editing/Sources/CTextBuffer.cpp (from rev 511, branches/model-based-editing/Sources/PTextBuffer.cpp)
===================================================================
--- branches/model-based-editing/Sources/PTextBuffer.cpp	2008-04-12 09:18:14 UTC (rev 511)
+++ branches/model-based-editing/Sources/CTextBuffer.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -0,0 +1,294 @@
+/*	$Id$
+	
+	Copyright 1996, 1997, 1998, 2002
+	        Hekkelman Programmatuur B.V.  All rights reserved.
+	
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions are met:
+	1. Redistributions of source code must retain the above copyright notice,
+	   this list of conditions and the following disclaimer.
+	2. Redistributions in binary form must reproduce the above copyright notice,
+	   this list of conditions and the following disclaimer in the documentation
+	   and/or other materials provided with the distribution.
+	3. All advertising materials mentioning features or use of this software
+	   must display the following acknowledgement:
+	   
+	    This product includes software developed by Hekkelman Programmatuur B.V.
+	
+	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
+	   promote products derived from this software without specific prior
+	   written permission.
+	
+	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+*/
+
+#include "pe.h"
+
+#include "CTextBuffer.h"
+
+#include "HError.h"
+
+const int
+	kBlockSize = 2048;
+
+CTextBuffer::CTextBuffer()
+	: fText(strdup(""))
+	, fLogicalSize(0)
+	, fPhysicalSize(0)
+	, fGap(0)
+	, fGapSize(0)
+{
+	FailNil(fText);
+} /* CTextBuffer::CTextBuffer */
+
+CTextBuffer::~CTextBuffer()
+{
+	free(fText);
+} /* CTextBuffer::~CTextBuffer */
+
+void CTextBuffer::Insert(const char *bytes, int numBytes, int index)
+{
+	ASSERT(numBytes >= 0);
+	ASSERT(index >= 0 && index <= fLogicalSize);
+
+	if (numBytes < 0 || index < 0 || index > fLogicalSize) return;
+	
+	index = max(min(fLogicalSize, index), 0);
+	
+	if (index != fGap)
+		_MoveGap(index);
+	
+	if (fGapSize < numBytes)
+		_ResizeGap(numBytes + kBlockSize);
+
+	ASSERT(numBytes <= fGapSize);
+	memcpy(fText + fGap, bytes, numBytes);
+	
+	fGapSize -= numBytes;
+	fGap += numBytes;
+	fLogicalSize += numBytes;
+} /* CTextBuffer::Insert */
+
+void CTextBuffer::Delete(int from, int to)
+{
+	int index = from;
+	int cnt = to - from;
+	
+	ASSERT(cnt != 0);
+	ASSERT(from < to);
+	ASSERT(index >= 0);
+	ASSERT(index < fLogicalSize);
+	if (cnt <= 0 || from < 0 || index >= fLogicalSize)
+		return;
+	
+	index = max(min(fLogicalSize - 1, index), 0);
+	_MoveGap(index);
+	
+	fGapSize += cnt;
+	fLogicalSize -= cnt;
+	
+	if (fGapSize > kBlockSize)
+		_ResizeGap(kBlockSize);
+} /* CTextBuffer::Delete */
+
+void CTextBuffer::Overwrite(int offset, const char *txt)
+{
+	int len = strlen(txt);
+
+	ASSERT(offset >= 0);
+	ASSERT(offset + len <= fLogicalSize);
+	ASSERT(len >= 0);
+
+	if (offset < 0) offset = 0;
+	if (offset + len > fLogicalSize) len = fLogicalSize - offset;
+	if (len <= 0) return;
+
+	if (offset + len <= fGap)
+	{
+		memcpy(fText + offset, txt, len);
+	}
+	else if (offset >= fGap)
+	{
+		memcpy(fText + fGapSize + offset, txt, len);
+	}
+	else
+	{
+		int p1, p2;
+		p1 = fGap - offset;
+		p2 = len - p1;
+		
+		memcpy(fText + offset, txt, p1);
+		memcpy(fText + fGap + fGapSize, txt + p1, p2);
+	}
+} /* CTextBuffer::Replace */
+
+const char* CTextBuffer::Buffer()
+{
+	_MoveGap(fLogicalSize);
+	if (fGapSize < 1)
+		_ResizeGap(kBlockSize);
+	fText[fLogicalSize] = 0;
+
+	return fText;
+}
+
+void CTextBuffer::CopyText(char *buf, int index, int len) const
+{
+	ASSERT(index >= 0);
+	ASSERT(index + len <= fLogicalSize);
+	ASSERT(len >= 0);
+
+	if (index < 0) index = 0;
+	if (index + len > fLogicalSize) len = fLogicalSize - index;
+	if (len <= 0) return;
+
+	if (index + len <= fGap)
+	{
+		memcpy(buf, fText + index, len);
+	}
+	else if (index >= fGap)
+	{
+		memcpy(buf, fText + fGapSize + index, len);
+	}
+	else
+	{
+		int p1, p2;
+		p1 = fGap - index;
+		p2 = len - p1;
+		
+		memcpy(buf, fText + index, p1);
+		memcpy(buf + p1, fText + fGap + fGapSize, p2);
+	}
+} /* CTextBuffer::Copy */
+
+int CTextBuffer::CharLen(int index) const
+{
+	ASSERT(index >= 0);
+	ASSERT(index <= fLogicalSize);
+
+	if (index < fLogicalSize && index >= 0)
+	{
+		char b[8];
+		CopyText(b, index, min(7, fLogicalSize - index));
+		b[7] = 0;
+	
+		return mcharlen(b);
+	}
+	else
+		return 1;
+} /* CTextBuffer::CharLen */
+
+int CTextBuffer::PrevCharLen(int index) const
+{
+	ASSERT(index <= fLogicalSize);
+	ASSERT(index >= 0);
+
+	if (index > 0 && index <= fLogicalSize)
+	{
+		char b[8];
+		int cnt = max(0, min(7, index));
+		CopyText(b, index - cnt, cnt);
+		b[cnt] = 0;
+	
+		return mprevcharlen(b + cnt);
+	}
+	else
+		return 1;
+} /* CTextBuffer::PrevCharLen */
+
+void CTextBuffer::CharInfo(int offset, int& unicode, int& len) const
+{
+	ASSERT(offset >= 0);
+//	ASSERT(index <= fLogicalSize);
+
+	if (offset >= fLogicalSize || offset < 0)
+	{
+		unicode = 0;
+		len = 1;
+	}
+	else
+	{
+		char b[8];
+		CopyText(b, offset, min(7, fLogicalSize - offset));
+		b[7] = 0;
+	
+		len = mcharlen(b);
+		unicode = municode(b);
+	}
+} /* CTextBuffer::CharInfo */
+
+void CTextBuffer::_MoveGap(int offset)
+{
+	if (fGap == offset) return;
+	
+	ASSERT(offset >= 0);
+	ASSERT(offset <= fLogicalSize);
+	
+	int gapEnd = fGap + fGapSize;
+	int src, dst, cnt = 0;
+	
+	if (offset > fGap)
+	{
+		int trail = fPhysicalSize - gapEnd;
+		src = gapEnd;
+		dst = fGap;
+		cnt = min(trail, fGapSize + offset - src);
+	}
+	else
+	{
+		src = offset;
+		dst = offset + fGapSize;
+		cnt = gapEnd - dst;
+	}
+	
+	if (cnt > 0)
+	{
+		ASSERT(dst + cnt <= fPhysicalSize);
+		memmove(fText + dst, fText + src, cnt);
+	}
+	
+	fGap = offset;
+} /* CTextBuffer::_MoveGap */
+
+void CTextBuffer::_ResizeGap(int gapSize)
+{
+	if (fGapSize == gapSize) return;
+	
+	char *t = fText;
+	
+	try
+	{
+		if (gapSize > fGapSize)
+		{
+			fText = (char *)realloc(fText, fLogicalSize + gapSize);
+			FailNil(fText);
+		}
+
+		memmove(fText + fGap + gapSize, fText + fGap + fGapSize,
+			fPhysicalSize - (fGap + fGapSize));
+		
+		if (gapSize < fGapSize)
+		{
+			fText = (char *)realloc(fText, fLogicalSize + gapSize);
+			FailNil(fText);
+		}
+
+		fGapSize = gapSize;
+		fPhysicalSize = fLogicalSize + gapSize;
+	}
+	catch (HErr& e)
+	{
+		fText = t;
+		throw;
+	}
+} /* CTextBuffer::_ResizeGap */
+

Copied: branches/model-based-editing/Sources/CTextBuffer.h (from rev 511, branches/model-based-editing/Sources/PTextBuffer.h)
===================================================================
--- branches/model-based-editing/Sources/PTextBuffer.h	2008-04-12 09:18:14 UTC (rev 511)
+++ branches/model-based-editing/Sources/CTextBuffer.h	2008-04-12 12:33:24 UTC (rev 515)
@@ -0,0 +1,87 @@
+/*	$Id$
+	
+	Copyright 1996, 1997, 1998, 2002
+	        Hekkelman Programmatuur B.V.  All rights reserved.
+	
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions are met:
+	1. Redistributions of source code must retain the above copyright notice,
+	   this list of conditions and the following disclaimer.
+	2. Redistributions in binary form must reproduce the above copyright notice,
+	   this list of conditions and the following disclaimer in the documentation
+	   and/or other materials provided with the distribution.
+	3. All advertising materials mentioning features or use of this software
+	   must display the following acknowledgement:
+	   
+	    This product includes software developed by Hekkelman Programmatuur B.V.
+	
+	4. The name of Hekkelman Programmatuur B.V. may not be used to endorse or
+	   promote products derived from this software without specific prior
+	   written permission.
+	
+	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+*/
+
+#ifndef CTEXTBUFFER_H
+#define CTEXTBUFFER_H
+
+#include <Debug.h>
+#include "utf-support.h"
+
+class CTextBuffer {
+public:
+		CTextBuffer();
+virtual	~CTextBuffer();
+
+		void Insert(const char *bytes, int numBytes, int index);
+		void Delete(int from, int to);
+		void Overwrite(int offset, const char *txt);
+
+		char operator[] (int indx) const;
+		
+		int Size() const;
+		const char* Buffer();
+		
+		int CharLen(int offset) const;
+		int PrevCharLen(int offset) const;
+		void CharInfo(int offset, int& unicode, int& len) const;
+		
+		void CopyText(char *buf, int indx, int len) const;
+		
+		void PrintToStream();
+		
+private:
+		void _MoveGap(int offset);
+		void _ResizeGap(int size);
+		
+		char *fText;
+		int fLogicalSize;
+		int fPhysicalSize;
+		int fGap;
+		int fGapSize;
+};
+
+inline char CTextBuffer::operator[] (int indx) const
+{
+	ASSERT(indx >= 0);
+	ASSERT(indx < fLogicalSize);
+	if (indx < 0 || indx >= fLogicalSize)
+		return 0;
+	else
+		return fText[indx < fGap ? indx : indx + fGapSize];
+}
+
+inline int CTextBuffer::Size() const {
+	return fLogicalSize;
+}
+
+#endif // CTEXTBUFFER_H

Added: branches/model-based-editing/Sources/CTextEditor.cpp
===================================================================
--- branches/model-based-editing/Sources/CTextEditor.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/CTextEditor.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -0,0 +1,78 @@
+/*	$Id: $
+
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#include "pe.h"
+
+#include "CTextEditor.h"
+
+#include "CTextBuffer.h"
+#include "CTextStructure.h"
+#include "CTextSelection.h"
+#include "CTextSearch.h"
+
+CTextEditor::CTextEditor()
+	: fTextBuffer(new CTextBuffer)
+	, fTextStructure(new CTextStructure(fTextBuffer))
+	, fTextSelection(new CTextSelection(fTextBuffer, fTextStructure))
+	, fTextSearch(new CTextSearch(fTextBuffer))
+{
+}
+
+CTextEditor::~CTextEditor()
+{
+	delete fTextBuffer;
+}
+
+void CTextEditor::Insert(const char *bytes, int numBytes, int index)
+{
+	fTextBuffer->Insert(bytes, numBytes, index);
+}
+
+void CTextEditor::Delete(int from, int to)
+{
+	fTextBuffer->Delete(from, to);
+}
+
+void CTextEditor::Overwrite(int offset, const char *txt)
+{
+	fTextBuffer->Overwrite(offset, txt);
+}
+
+int CTextEditor::Size() const
+{
+	return fTextBuffer->Size();
+}
+
+const char* CTextEditor::Buffer()
+{
+	return fTextBuffer->Buffer();
+}
+
+char CTextEditor::operator[] (int indx) const
+{
+	return fTextBuffer->operator[](indx);
+}
+
+void CTextEditor::CopyText(char *buf, int index, int len) const
+{
+	fTextBuffer->CopyText(buf, index, len);
+}
+
+int CTextEditor::CharLen(int index) const
+{
+	return fTextBuffer->CharLen(index);
+}
+
+int CTextEditor::PrevCharLen(int index) const
+{
+	return fTextBuffer->PrevCharLen(index);
+}
+
+void CTextEditor::CharInfo(int offset, int& unicode, int& len) const
+{
+	fTextBuffer->CharInfo(offset, unicode, len);
+}

Added: branches/model-based-editing/Sources/CTextEditor.h
===================================================================
--- branches/model-based-editing/Sources/CTextEditor.h	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/CTextEditor.h	2008-04-12 12:33:24 UTC (rev 515)
@@ -0,0 +1,43 @@
+/*	$Id: $
+	
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#ifndef CTEXTEDITOR_H
+#define CTEXTEDITOR_H
+
+class CTextBuffer;
+class CTextStructure;
+class CTextSelection;
+class CTextSearch;
+
+class CTextEditor {
+public:
+		CTextEditor();
+		~CTextEditor();
+
+		void Insert(const char *bytes, int numBytes, int index);
+		void Delete(int from, int to);
+		void Overwrite(int offset, const char *txt);
+
+		char operator[] (int indx) const;
+		
+		int Size() const;
+		const char* Buffer();	// TODO: wrap auto-locker around this!
+		
+		int CharLen(int offset) const;
+		int PrevCharLen(int offset) const;
+		void CharInfo(int offset, int& unicode, int& len) const;
+		
+		void CopyText(char *buf, int indx, int len) const;
+		
+private:
+		CTextBuffer* fTextBuffer;
+		CTextStructure* fTextStructure;
+		CTextSelection* fTextSelection;
+		CTextSearch* fTextSearch;
+};
+
+#endif // CTEXTEDITOR_H

Modified: branches/model-based-editing/Sources/Jamfile
===================================================================
--- branches/model-based-editing/Sources/Jamfile	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/Jamfile	2008-04-12 12:33:24 UTC (rev 515)
@@ -54,6 +54,7 @@
 	CDocWindow.cpp
 	CFilterChoiceDialog.cpp
 	CFindDialog.cpp
+	CFontStyle.cpp
 	CFtpDialog.cpp
 	CFtpListItem.cpp
 	CFtpStream.cpp
@@ -83,7 +84,11 @@
 	CStdErrBox.cpp
 	CStdErrParser.cpp
 	CUrlOpener.cpp
-	CFontStyle.cpp
+	CTextBuffer.cpp
+	CTextEditor.cpp
+	CTextStructure.cpp
+	CTextSelection.cpp
+	CTextSearch.cpp
 	MTextAddOnImpl.cpp
 	PAbout.cpp
 	PAddOn.cpp
@@ -103,7 +108,6 @@
 	PSplitter.cpp
 	PStatus.cpp
 	PText.cpp
-	PTextBuffer.cpp
 	PToolBar.cpp
 	PTypeAHeadList.cpp
 	Sstdio.cpp

Modified: branches/model-based-editing/Sources/MTextAddOnImpl.cpp
===================================================================
--- branches/model-based-editing/Sources/MTextAddOnImpl.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/MTextAddOnImpl.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -112,7 +112,7 @@
 		action.aOffset = start;
 		action.aText = (char *)malloc(end - start + 1);
 		FailNil(action.aText);
-		fText.TextBuffer().Copy(action.aText, start, end - start);
+		fText.CopyText(action.aText, start, end - start);
 		action.aText[end - start] = 0;
 		fCmd->Actions().push_back(action);
 		

Modified: branches/model-based-editing/Sources/PAbout.cpp
===================================================================
--- branches/model-based-editing/Sources/PAbout.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PAbout.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -46,9 +46,9 @@
 const char
 	kAboutText[] =
 #if __INTEL__
-		"Pe 2.4.1 (x86) Open Source Version\n\n"
+		"Pe devel (x86) Open Source Version\n\n"
 #else
-		"Pe 2.4.1 (PPC) Open Source Version\n\n"
+		"Pe devel (PPC) Open Source Version\n\n"
 #endif
 		"a high performance editor\n"
 		"created by Maarten Hekkelman.\n"

Modified: branches/model-based-editing/Sources/PAddOn.cpp
===================================================================
--- branches/model-based-editing/Sources/PAddOn.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PAddOn.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -29,7 +29,6 @@
 	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
 */
 
-
 #include "PAddOn.h"
 
 #include "HError.h"
@@ -213,7 +212,7 @@
 	action.aOffset = start;
 	action.aText = (char *)malloc(end - start + 1);
 	FailNil(action.aText);
-	fText.TextBuffer().Copy(action.aText, start, end - start);
+	fText.CopyText(action.aText, start, end - start);
 	action.aText[end - start] = 0;
 	fCommand->Actions().push_back(action);
 	

Modified: branches/model-based-editing/Sources/PCmd.cpp
===================================================================
--- branches/model-based-editing/Sources/PCmd.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PCmd.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -42,6 +42,7 @@
 #include "PLongAction.h"
 #include "PApp.h"
 #include "PErrorWindow.h"
+#include "utf-support.h"
 
 PCmd::PCmd(const char *str, PText *txt)
 {
@@ -174,7 +175,7 @@
 	int cnt = fTo - fWhere;
 	fPasted = (char *)malloc(cnt + 1);
 	FailNil(fPasted);
-	fText->TextBuffer().Copy(fPasted, fWhere, cnt);
+	fText->CopyText(fPasted, fWhere, cnt);
 	fPasted[cnt] = 0;
 	
 	Update();
@@ -228,13 +229,13 @@
 	fDeletedIndx = min(fText->Caret(), fText->Anchor());
 	fDeletedLen = abs(fText->Caret() - fText->Anchor());
 		
-	if (fDeletedIndx + fDeletedLen >= fText->TextBuffer().Size())
-		fDeletedLen = max(fText->TextBuffer().Size() - fDeletedIndx, 0);
+	if (fDeletedIndx + fDeletedLen >= fText->Size())
+		fDeletedLen = max(fText->Size() - fDeletedIndx, 0);
 		
 	fDeleted = (char *)malloc(fDeletedLen);
 		
 	if (fDeletedLen)
-		fText->TextBuffer().Copy(fDeleted, fDeletedIndx, fDeletedLen);
+		fText->CopyText(fDeleted, fDeletedIndx, fDeletedLen);
 		
 	fInsertedLen = 0;
 } /* PTypingCmd::Do */
@@ -256,7 +257,7 @@
 	{
 		pt = (char *)malloc(fInsertedLen + 1);
 		FailNil(pt);
-		fText->TextBuffer().Copy(pt, fDeletedIndx, fInsertedLen);
+		fText->CopyText(pt, fDeletedIndx, fInsertedLen);
 	}
 	
 	if (fInsertedLen)
@@ -526,7 +527,7 @@
 
 	fWhat = (char *)malloc(size + 1);
 	FailNil(fWhat);
-	txt->TextBuffer().Copy(fWhat, offset, size);
+	txt->CopyText(fWhat, offset, size);
 	fWhat[size] = 0;
 
 	fWrap = gFindDialog->Wrap();
@@ -737,7 +738,7 @@
 		fAnchor = fCaret = min(fText->Anchor(), fText->Caret());
 		fOldText = (char *)malloc(fOldTextSize);
 		FailNil(fOldText);
-		fText->TextBuffer().Copy(fOldText, fAnchor, fOldTextSize);
+		fText->CopyText(fOldText, fAnchor, fOldTextSize);
 	}
 	else
 		fCaret = fAnchor = fText->Caret();
@@ -874,7 +875,7 @@
 	{
 		t = (char *)malloc(size);
 		FailNil(t);
-		fText->TextBuffer().Copy(t, fAnchor, size);
+		fText->CopyText(t, fAnchor, size);
 		fText->Delete(fAnchor, fCaret);
 	}
 	
@@ -977,7 +978,7 @@
 	for (int i = firstLine; i < lastLine; i++)
 	{
 		if (!fText->SoftStart(i)) {
-			char c = fText->TextBuffer()[fText->LineStart(i)];
+			char c = (*fText)[fText->LineStart(i)];
 			if (c == '\t' || c == ' ')
 			{
 				fFirstChars[hardIndex] = c;
@@ -1123,23 +1124,22 @@
 		
 		if (fFrom == fText->LineStart(line))
 		{
-			fTo += txt->TextBuffer().CharLen(fTo);
-			fTo += txt->TextBuffer().CharLen(fTo);
+			fTo += txt->CharLen(fTo);
+			fTo += txt->CharLen(fTo);
 		}
 		else if (fFrom == fText->Size() || fFrom == fText->LineStart(line + 1) - 1)
 		{
-			fFrom -= txt->TextBuffer().PrevCharLen(fFrom);
-			fFrom -= txt->TextBuffer().PrevCharLen(fFrom);
+			fFrom -= txt->PrevCharLen(fFrom);
+			fFrom -= txt->PrevCharLen(fFrom);
 		}
 		else
 		{
-			fTo += txt->TextBuffer().CharLen(fTo);
-			fFrom -= txt->TextBuffer().PrevCharLen(fFrom);
+			fTo += txt->CharLen(fTo);
+			fFrom -= txt->PrevCharLen(fFrom);
 		}
 	}
 	
-	if (fText->TextBuffer()[fFrom] == '\n' ||
-		fText->TextBuffer()[fTo - 1] == '\n' ||
+	if ((*fText)[fFrom] == '\n' || (*fText)[fTo - 1] == '\n' ||
 		fTo > fText->Size() || fFrom < 0)
 	{
 		THROW((0));
@@ -1285,7 +1285,7 @@
 	
 	b[j] = 0;
 	while (j--)
-		b[j] = fText->TextBuffer()[ix + j];
+		b[j] = (*fText)[ix + j];
 
 	if (strcmp(b, fBefore) == 0)
 	{
@@ -1299,7 +1299,7 @@
 			
 			b[j] = 0;
 			while (j--)
-				b[j] = fText->TextBuffer()[ix + j];
+				b[j] = (*fText)[ix + j];
 	
 			if (strcmp(b, fAfter) == 0)
 				fText->Delete(ix, ix + strlen(fAfter));
@@ -1620,7 +1620,7 @@
 	fSrcLen = fCaret - fAnchor;
 	
 	FailNil(fSaved);
-	txt->TextBuffer().Copy(fSaved, fAnchor, fSrcLen);
+	txt->CopyText(fSaved, fAnchor, fSrcLen);
 	
 	fPrevEncoding = txt->Doc()->Encoding();
 } /* PEncodingCmd::PEncodingCmd */

Modified: branches/model-based-editing/Sources/PCmd.h
===================================================================
--- branches/model-based-editing/Sources/PCmd.h	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PCmd.h	2008-04-12 12:33:24 UTC (rev 515)
@@ -42,7 +42,6 @@
 
 
 class PText;
-class PTextBuffer;
 
 class PCmd {
 public:

Modified: branches/model-based-editing/Sources/PDoc.cpp
===================================================================
--- branches/model-based-editing/Sources/PDoc.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PDoc.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -250,7 +250,7 @@
 	r.right -= B_V_SCROLL_BAR_WIDTH;
 	r.bottom -= B_H_SCROLL_BAR_HEIGHT;
 
-	fText = new PText(r, fTextBuffer, bars, name);
+	fText = new PText(r, bars, name);
 	AddChild(fText);
 	fText->MakeFocus(true);
 

Modified: branches/model-based-editing/Sources/PDoc.h
===================================================================
--- branches/model-based-editing/Sources/PDoc.h	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PDoc.h	2008-04-12 12:33:24 UTC (rev 515)
@@ -41,8 +41,6 @@
 
 #include "CDocWindow.h"
 
-#include "PTextBuffer.h"
-
 class PText;
 class PStatus;
 class HDialog;
@@ -169,7 +167,6 @@
 
 			HButtonBar *fButtonBar;
 			PText *fText;
-			PTextBuffer fTextBuffer;
 			PToolBar *fToolBar;
 			BMenu *fMBar;
 			BMenu *fRecent;

Modified: branches/model-based-editing/Sources/PText.cpp
===================================================================
--- branches/model-based-editing/Sources/PText.cpp	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PText.cpp	2008-04-12 12:33:24 UTC (rev 515)
@@ -66,9 +66,10 @@
 #include "HColorUtils.h"
 #include "ResourcesMenus.h"
 #include "Prefs.h"
+#include "utf-support.h"
 
 #if defined(__BEOS__) && defined(__INTEL__)
-	// [zooey]: BeOS' glib is messing up iscntrl, as it reports all values>127 as
+	// [zooey]: BeOS' glibc is messing up iscntrl, as it reports all values>127 as
 	// being control-chars, too (but they are *not*). We fix that:
 	#undef iscntrl
 	#define iscntrl(c)	((((unsigned char)(c))<128) && __isctype((c), _IScntrl))
@@ -171,10 +172,10 @@
 //	#pragma mark - class PText
 
 
-PText::PText(BRect frame, PTextBuffer& txt, BScrollBar *bars[], const char *ext)
+PText::PText(BRect frame, BScrollBar *bars[], const char *ext)
 	: BView(frame, "text view", B_FOLLOW_ALL_SIDES, B_ASYNCHRONOUS_CONTROLS |
 		B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED | B_FRAME_EVENTS)
-	, fText(txt)
+	, fText(*static_cast<CTextEditor*>(this))
 	, fSplitCursorShown(false)
 	, fFontKind(kNormalFont)
 {
@@ -399,7 +400,7 @@
 			int size = abs(fCaret - fAnchor);
 			s = (char *)malloc(size + 1);
 			FailNil(s);
-			fText.Copy(s, min(fCaret, fAnchor), size);
+			fText.CopyText(s, min(fCaret, fAnchor), size);
 			s[size] = 0;
 		}
 	}
@@ -1127,7 +1128,7 @@
 		l = o2 - o1;
 
 		CAlloca txt(o2 - o1 + 2);
-		fText.Copy(txt, o1, l);
+		fText.CopyText(txt, o1, l);
 		txt[l] = '\n';
 		txt[l + 1] = 0;
 
@@ -2632,7 +2633,7 @@
 		if (! fLineInfo[line].nl)
 		{
 			if (fText[i - 1] == ' ')
-				fText.Replace(i - 1, "\n");
+				fText.Overwrite(i - 1, "\n");
 			else
 			{
 				fText.Insert("\n", 1, i);
@@ -2928,7 +2929,7 @@
 	if (len > 0)
 	{
 		CAlloca txt(len + 1);
-		fText.Copy(txt, offset, len);
+		fText.CopyText(txt, offset, len);
 		txt[len] = 0;
 
 		w = StringWidth(txt, len);
@@ -3039,7 +3040,7 @@
 				int len = fLineInfo[i].start - fLineInfo[i - 1].start;
 
 				CAlloca txt(len + 1);
-				fText.Copy(txt, fLineInfo[i - 1].start, len);
+				fText.CopyText(txt, fLineInfo[i - 1].start, len);
 				txt[len] = 0;
 
 				fLangIntf->ColorLine(txt, len, state, NULL, NULL);
@@ -4643,7 +4644,7 @@
 		s = (char *)malloc(to - from + 1);
 		s[to - from] = 0;
 		FailNil(s);
-		fText.Copy(s, from, to - from);
+		fText.CopyText(s, from, to - from);
 	}
 
 	fExec = new PExec(this, s, fCWD);
@@ -4822,7 +4823,7 @@
 
 	if (l)
 	{
-		fText.Copy(b, s, l);
+		fText.CopyText(b, s, l);
 		b[l] = 0;
 
 		int state = LineState(lineNr);
@@ -6238,7 +6239,7 @@
 			s = (char *)malloc(size);
 			FailNil(s);
 
-			fText.Copy(s, min(fCaret, fAnchor), size);
+			fText.CopyText(s, min(fCaret, fAnchor), size);
 
 			be_clipboard->Lock();
 			if (append && be_clipboard->Data()->HasData("text/plain", B_MIME_DATA))

Modified: branches/model-based-editing/Sources/PText.h
===================================================================
--- branches/model-based-editing/Sources/PText.h	2008-04-12 11:53:47 UTC (rev 514)
+++ branches/model-based-editing/Sources/PText.h	2008-04-12 12:33:24 UTC (rev 515)
@@ -36,10 +36,11 @@
 
 typedef float g_unit_t;
 
+#include <Debug.h>
 #include <Messenger.h>

[... truncated: 62 lines follow ...]


From zooey at mail.berlios.de  Sat Apr 12 14:34:19 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sat, 12 Apr 2008 14:34:19 +0200
Subject: [pe-commits] r516 - branches/model-based-editing/Sources
Message-ID: <200804121234.m3CCYJeX015180@sheep.berlios.de>

Author: zooey
Date: 2008-04-12 14:34:19 +0200 (Sat, 12 Apr 2008)
New Revision: 516
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=516&view=rev

Added:
   branches/model-based-editing/Sources/CTextSearch.cpp
   branches/model-based-editing/Sources/CTextSearch.h
   branches/model-based-editing/Sources/CTextSelection.cpp
   branches/model-based-editing/Sources/CTextSelection.h
   branches/model-based-editing/Sources/CTextStructure.cpp
   branches/model-based-editing/Sources/CTextStructure.h
Log:
* add several files I forgot during last commit


Added: branches/model-based-editing/Sources/CTextSearch.cpp
===================================================================
--- branches/model-based-editing/Sources/CTextSearch.cpp	2008-04-12 12:33:24 UTC (rev 515)
+++ branches/model-based-editing/Sources/CTextSearch.cpp	2008-04-12 12:34:19 UTC (rev 516)
@@ -0,0 +1,21 @@
+/*	$Id: $
+
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#include "pe.h"
+
+#include "CTextSearch.h"
+
+#include "CTextBuffer.h"
+
+CTextSearch::CTextSearch(CTextBuffer* buffer)
+	: fTextBuffer(buffer)
+{
+}
+
+CTextSearch::~CTextSearch()
+{
+}

Added: branches/model-based-editing/Sources/CTextSearch.h
===================================================================
--- branches/model-based-editing/Sources/CTextSearch.h	2008-04-12 12:33:24 UTC (rev 515)
+++ branches/model-based-editing/Sources/CTextSearch.h	2008-04-12 12:34:19 UTC (rev 516)
@@ -0,0 +1,22 @@
+/*	$Id: $
+	
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#ifndef CTEXTSEARCH_H
+#define CTEXTSEARCH_H
+
+class CTextBuffer;
+
+class CTextSearch {
+public:
+		CTextSearch(CTextBuffer* buffer);
+		~CTextSearch();
+
+private:
+		CTextBuffer* fTextBuffer;
+};
+
+#endif // CTEXTSEARCH_H

Added: branches/model-based-editing/Sources/CTextSelection.cpp
===================================================================
--- branches/model-based-editing/Sources/CTextSelection.cpp	2008-04-12 12:33:24 UTC (rev 515)
+++ branches/model-based-editing/Sources/CTextSelection.cpp	2008-04-12 12:34:19 UTC (rev 516)
@@ -0,0 +1,23 @@
+/*	$Id: $
+
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#include "pe.h"
+
+#include "CTextSelection.h"
+
+#include "CTextBuffer.h"
+#include "CTextStructure.h"
+
+CTextSelection::CTextSelection(CTextBuffer* buffer, CTextStructure* structure)
+	: fTextBuffer(buffer)
+	, fTextStructure(structure)
+{
+}
+
+CTextSelection::~CTextSelection()
+{
+}

Added: branches/model-based-editing/Sources/CTextSelection.h
===================================================================
--- branches/model-based-editing/Sources/CTextSelection.h	2008-04-12 12:33:24 UTC (rev 515)
+++ branches/model-based-editing/Sources/CTextSelection.h	2008-04-12 12:34:19 UTC (rev 516)
@@ -0,0 +1,24 @@
+/*	$Id: $
+	
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#ifndef CTEXTSELECTION_H
+#define CTEXTSELECTION_H
+
+class CTextBuffer;
+class CTextStructure;
+
+class CTextSelection {
+public:
+		CTextSelection(CTextBuffer* buffer, CTextStructure* structure);
+		~CTextSelection();
+
+private:
+		CTextBuffer* fTextBuffer;
+		CTextStructure* fTextStructure;
+};
+
+#endif // CTEXTSELECTION_H

Added: branches/model-based-editing/Sources/CTextStructure.cpp
===================================================================
--- branches/model-based-editing/Sources/CTextStructure.cpp	2008-04-12 12:33:24 UTC (rev 515)
+++ branches/model-based-editing/Sources/CTextStructure.cpp	2008-04-12 12:34:19 UTC (rev 516)
@@ -0,0 +1,21 @@
+/*	$Id: $
+
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#include "pe.h"
+
+#include "CTextStructure.h"
+
+#include "CTextBuffer.h"
+
+CTextStructure::CTextStructure(CTextBuffer* buffer)
+	: fTextBuffer(buffer)
+{
+}
+
+CTextStructure::~CTextStructure()
+{
+}

Added: branches/model-based-editing/Sources/CTextStructure.h
===================================================================
--- branches/model-based-editing/Sources/CTextStructure.h	2008-04-12 12:33:24 UTC (rev 515)
+++ branches/model-based-editing/Sources/CTextStructure.h	2008-04-12 12:34:19 UTC (rev 516)
@@ -0,0 +1,22 @@
+/*	$Id: $
+	
+	Copyright 2008 Oliver Tappe <zooey at hirschkaefer.de>
+	
+	Distributed under the MIT License
+*/
+
+#ifndef CTEXTSTRUCTURE_H
+#define CTEXTSTRUCTURE_H
+
+class CTextBuffer;
+
+class CTextStructure {
+public:
+		CTextStructure(CTextBuffer* buffer);
+		~CTextStructure();
+
+private:
+		CTextBuffer* fTextBuffer;
+};
+
+#endif // CTEXTSTRUCTURE_H



From ingo_weinhold at gmx.de  Mon Apr 14 00:13:20 2008
From: ingo_weinhold at gmx.de (Ingo Weinhold)
Date: Mon, 14 Apr 2008 00:13:20 +0200
Subject: [pe-commits] r514 - trunk/Sources
In-Reply-To: <200804121153.m3CBrruP011009@sheep.berlios.de>
References: <200804121153.m3CBrruP011009@sheep.berlios.de>
Message-ID: <20080414001320.2161.9@knochen-vm.1208099803.fake>


On 2008-04-12 at 13:53:53 [+0200], zooey at BerliOS <zooey at mail.berlios.de> 
wrote:
> Author: zooey
> Date: 2008-04-12 13:53:47 +0200 (Sat, 12 Apr 2008)
> New Revision: 514
> ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=514&view=rev
> 
> Modified:
>    trunk/Sources/PText.cpp
> Log:
> * instead of inserting dropped files a the drop position, they now get 
> opened
>   as documents (dragging text fragments between windows works as before)

Yippie! :-)

CU, Ingo


From zooey at mail.berlios.de  Sun Apr 13 16:55:02 2008
From: zooey at mail.berlios.de (zooey at BerliOS)
Date: Sun, 13 Apr 2008 16:55:02 +0200
Subject: [pe-commits] r517 - trunk/Sources
Message-ID: <200804131455.m3DEt28R004417@sheep.berlios.de>

Author: zooey
Date: 2008-04-13 16:55:02 +0200 (Sun, 13 Apr 2008)
New Revision: 517
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=517&view=rev

Modified:
   trunk/Sources/CFilterChoiceDialog.cpp
Log:
* added scroll-wheel support to function popup


Modified: trunk/Sources/CFilterChoiceDialog.cpp
===================================================================
--- trunk/Sources/CFilterChoiceDialog.cpp	2008-04-12 12:34:19 UTC (rev 516)
+++ trunk/Sources/CFilterChoiceDialog.cpp	2008-04-13 14:55:02 UTC (rev 517)
@@ -17,6 +17,8 @@
 #include "HColorUtils.h"
 #include "HDialogViews.h"
 #include "HError.h"
+#include "KeyBindings.h"
+#include "Prefs.h"
 
 // internal messages
 enum {
@@ -525,6 +527,35 @@
 		case MSG_FILTER_MODIFIED:
 			_SetFilter(fFilterStringControl->Text());
 			break;
+		case B_MOUSE_WHEEL_CHANGED:
+		{
+			// the wheel that have changed may *not* be the vertical one,
+			// so we check:
+			float y;
+			if (message->FindFloat("be:wheel_delta_y", &y) == B_OK && y != 0)
+			{
+				float delta 
+					= 20.0 * gPrefs->GetPrefInt(prf_I_ScrollwheelLines, 3);
+				BScrollBar* vScroller = fChoicesList->ScrollBar(B_VERTICAL);
+				float minVal, maxVal;
+				vScroller->GetRange(&minVal, &maxVal);
+				float value = vScroller->Value();
+				if (y < 0) 
+				{
+					value -= delta;
+					value = max(minVal, value);
+				}
+				else 
+				{
+					value += delta;
+					value = min(maxVal, value);
+				}
+				vScroller->SetValue(value);
+			}
+			else
+				HDialog::MessageReceived(message);
+			break;
+		}
 		default:
 			BWindow::MessageReceived(message);
 			break;



From mmu_man at mail.berlios.de  Tue Apr 22 01:17:51 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 22 Apr 2008 01:17:51 +0200
Subject: [pe-commits] r518 - trunk/Extensions
Message-ID: <200804212317.m3LNHpE5007575@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-22 01:17:51 +0200 (Tue, 22 Apr 2008)
New Revision: 518
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=518&view=rev

Added:
   trunk/Extensions/HeaderHeader.cpp
Modified:
   trunk/Extensions/Jamfile
Log:
New HeaderHeader extension that inserts a standard header comment with copyrights from a list of templates.
TODO: Select a people file to use for %AUTHOR*%; add templates.


Added: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-13 14:55:02 UTC (rev 517)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-21 23:17:51 UTC (rev 518)
@@ -0,0 +1,201 @@
+/*
+ * HeaderHeader is an Extension.
+ */
+
+#include "PeAddOn.h"
+#include <ctype.h>
+#include <time.h>
+#include <MenuItem.h>
+#include <PopUpMenu.h>
+
+static const char *sHaikuHeaderTemplate = "/*
+ * Copyright %YEAR%, Haiku.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		%AUTHOR% <%AUTHORMAIL%>
+ */
+";
+
+/*
+static const char *sHaikuAddMeHeaderTemplate = \
+" *	 	%AUTHOR% <%AUTHORMAIL%>
+";
+*/
+
+
+static const char *sHaikuMeHeaderTemplate = "/*
+ * Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.
+ * Distributed under the terms of the MIT License.
+ *		
+ */
+";
+
+/*
+static const char *sHaikuMeAddMeHeaderTemplate = \
+" * Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.
+";
+*/
+
+
+
+//------------------------------------------------------------------------------
+//	#pragma mark - implementation
+
+
+void
+AddTemplateItem(BPopUpMenu *menu, const char *name, const char *tmpl)
+{
+	BMessage *msg;
+	BMenuItem *item;
+	msg = new BMessage('head');
+	msg->AddString("template", tmpl);
+	item = new BMenuItem(name, msg);
+	menu->AddItem(item);
+}
+
+
+BPopUpMenu *
+BuildPopUp()
+{
+	BPopUpMenu *menu = new BPopUpMenu("menu", false);
+	//BMenuItem *item;
+	//BMessage *msg;
+	//BPath path;
+	//status_t err;
+
+	menu->SetFont(be_plain_font);
+
+	AddTemplateItem(menu, B_UTF8_COPYRIGHT" Haiku", 
+		sHaikuHeaderTemplate);
+
+	AddTemplateItem(menu, B_UTF8_COPYRIGHT" Me (Haiku)", 
+		sHaikuMeHeaderTemplate);
+
+/*
+	// TODO: build list from text files
+	err = find_directory(B_COMMON_SETTINGS_DIRECTORY, &path, true);
+	if (err < B_OK)
+		return p;
+	BDirectory
+	p->AddItem();
+
+*/
+
+	//p->AddSeparatorItem();
+	//p->AddItem(new BMenuItem("Open Template Folder", new BMessage('optf')));
+	return menu;
+}
+
+
+status_t
+RunPopUpMenu(BPoint where, BString &header, BString &fileName)
+{
+	status_t err = B_ERROR;
+	BPopUpMenu *menu = BuildPopUp();
+	if (menu == NULL)
+		return B_ERROR;
+	
+	BMenuItem *item = menu->Go(where, false, true);
+	//if (item && item->Message())
+	//	item->Message()->PrintToStream();
+
+	switch ((item && item->Message()) ? item->Message()->what : 0) {
+		case 'head':
+		{
+			if (item->Message()->FindString("template", &header) < B_OK)
+				break;
+			BString tmp;
+			time_t now = time(NULL);
+			struct tm *tim = localtime(&now);
+			// date
+			strftime(tmp.LockBuffer(100), 100, "%F", tim);
+			tmp.UnlockBuffer();
+			header.ReplaceAll("%DATE%", tmp.String());
+			tmp.Truncate(0);
+			// year
+			strftime(tmp.LockBuffer(20), 20, "%Y", tim);
+			tmp.UnlockBuffer();
+			header.ReplaceAll("%YEAR%", tmp.String());
+			tmp.Truncate(0);
+
+			// TODO fetch from query on META:email==**
+			// or specific people file
+			tmp << "Fran?ois Revol";
+			header.ReplaceAll("%AUTHOR%", tmp.String());
+			tmp.Truncate(0);
+			tmp << "revol at free.fr";
+			header.ReplaceAll("%AUTHORMAIL%", tmp.String());
+			tmp.Truncate(0);
+
+			header.ReplaceAll("%FILENAME%", fileName.String());
+			/*
+			tmp << "Haiku";
+			header.ReplaceAll("%PROJECT%", tmp.String());
+			tmp.Truncate(0);
+			*/
+
+			err = B_OK;
+			break;
+		}
+		case 'optf':
+			// TODO
+			break;
+		default:
+			break;
+	}
+	delete menu;
+	return err;
+}
+
+//------------------------------------------------------------------------------
+//	#pragma mark - 
+
+
+#if __INTEL__
+	extern "C" _EXPORT long perform_edit(MTextAddOn *addon);
+#else
+#	pragma export on
+	extern "C"
+		long perform_edit(MTextAddOn *addon);
+#	pragma export reset
+#endif
+
+long perform_edit(MTextAddOn *addon)
+{
+	long result = B_OK;
+	entry_ref headerFile;
+	BPoint where(0,0);
+
+	if (addon->Window() && addon->Window()->Lock()) {
+		uint32 buttons;
+		addon->Window()->ChildAt(0)->GetMouse(&where, &buttons);
+		addon->Window()->ChildAt(0)->ConvertToScreen(&where);
+		addon->Window()->Unlock();
+		where += BPoint(-3,-3);
+	}
+
+	result = addon->GetRef(headerFile);
+	BString fileName;
+	if (result >= B_OK)
+		fileName = headerFile.name;
+
+	BString header;
+	result = RunPopUpMenu(where, header, fileName);
+	printf("result %s\n", strerror(result));
+	if (result < B_OK)
+		return result;
+
+#if 0
+	// Do not change the case if a shift key was pressed
+	if ((modifiers() & B_SHIFT_KEY) == 0)
+		fileName.ToUpper();
+#endif
+
+	addon->Select(0, 0);
+
+	addon->Insert(header.String());
+	
+	return result;
+}
+

Modified: trunk/Extensions/Jamfile
===================================================================
--- trunk/Extensions/Jamfile	2008-04-13 14:55:02 UTC (rev 517)
+++ trunk/Extensions/Jamfile	2008-04-21 23:17:51 UTC (rev 518)
@@ -64,6 +64,13 @@
 # </pe-src>
 
 # <pe-src>
+PeExtension HeaderHeader
+	: HeaderHeader.cpp 
+	: be
+	;
+# </pe-src>
+
+# <pe-src>
 PeExtension ImageToC
 	: ImageToC.cpp 
 	: libhekkel.so <nogrist>pe be translation



From mmu_man at mail.berlios.de  Tue Apr 22 03:06:24 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 22 Apr 2008 03:06:24 +0200
Subject: [pe-commits] r519 - trunk/Extensions
Message-ID: <200804220106.m3M16OE1007216@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-22 03:06:23 +0200 (Tue, 22 Apr 2008)
New Revision: 519
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=519&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
   trunk/Extensions/Jamfile
Log:
- some default licences
- an "open template folder" item


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-21 23:17:51 UTC (rev 518)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-22 01:06:23 UTC (rev 519)
@@ -5,9 +5,12 @@
 #include "PeAddOn.h"
 #include <ctype.h>
 #include <time.h>
+#include <FilePanel.h>
 #include <MenuItem.h>
 #include <PopUpMenu.h>
 
+static const char *sTrackerSig = "application/x-vnd.Be-TRAK";
+
 static const char *sHaikuHeaderTemplate = "/*
  * Copyright %YEAR%, Haiku.
  * Distributed under the terms of the MIT License.
@@ -17,11 +20,12 @@
  */
 ";
 
-/*
+static const char *sHaikuAddMeHeaderMatch = \
+" * Authors:
+";
 static const char *sHaikuAddMeHeaderTemplate = \
 " *	 	%AUTHOR% <%AUTHORMAIL%>
 ";
-*/
 
 
 static const char *sHaikuMeHeaderTemplate = "/*
@@ -37,53 +41,175 @@
 ";
 */
 
+static const char *sIdMeMITCreatedHeaderTemplate = \
+"/*	$Id: %FILENAME% $
 
+	Copyright %YEAR% %AUTHOR%
 
+	Distributed under the MIT License
+
+	Created: %DATE%
+*/
+";
+
+static const char *sIdMeFullMITCreatedHeaderTemplate = \
+"/*	$Id: %FILENAME% $
+	
+	Copyright %YEAR%
+	        %AUTHOR%  All rights reserved.
+	
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions are met:
+	1. Redistributions of source code must retain the above copyright notice,
+	   this list of conditions and the following disclaimer.
+	2. Redistributions in binary form must reproduce the above copyright notice,
+	   this list of conditions and the following disclaimer in the documentation
+	   and/or other materials provided with the distribution.
+	3. All advertising materials mentioning features or use of this software
+	   must display the following acknowledgement:
+	   
+	    This product includes software developed by %AUTHOR%.
+	
+	4. The name of %AUTHOR% may not be used to endorse or
+	   promote products derived from this software without specific prior
+	   written permission.
+	
+	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+
+	Created: %DATE% %TIME%
+*/
+";
+
+static const char *sIdMeFullMITRevisedCreatedHeaderTemplate = \
+"/*	$Id: %FILENAME% $
+	
+	Copyright %YEAR%
+	        %AUTHOR%  All rights reserved.
+	
+	Redistribution and use in source and binary forms, with or without
+	modification, are permitted provided that the following conditions are met:
+	1. Redistributions of source code must retain the above copyright notice,
+	   this list of conditions and the following disclaimer.
+	2. Redistributions in binary form must reproduce the above copyright notice,
+	   this list of conditions and the following disclaimer in the documentation
+	   and/or other materials provided with the distribution.
+	4. The name of %AUTHOR% may not be used to endorse or
+	   promote products derived from this software without specific prior
+	   written permission.
+	
+	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+
+	Created: %DATE% %TIME%
+*/
+";
+
+
 //------------------------------------------------------------------------------
 //	#pragma mark - implementation
 
 
+status_t
+GetSettingsDir(BDirectory &dir, BPath &path)
+{
+	//BPath path;
+	status_t err;
+	// TODO: build list from text files
+	err = find_directory(B_COMMON_SETTINGS_DIRECTORY, &path, true);
+	if (err < B_OK)
+		return err;
+	dir.SetTo(path.Path());
+	if (!dir.Contains("pe"))
+		dir.CreateDirectory("pe", NULL);
+	path.Append("pe");
+	dir.SetTo(path.Path());
+	if (!dir.Contains("HeaderTemplates"))
+		dir.CreateDirectory("HeaderTemplates", NULL);
+	path.Append("HeaderTemplates");
+	dir.SetTo(path.Path());
+	return B_OK;
+}
+
 void
-AddTemplateItem(BPopUpMenu *menu, const char *name, const char *tmpl)
+AddTemplateItem(BPopUpMenu *menu, const char *name, const char *tmpl, const char *match=NULL)
 {
 	BMessage *msg;
 	BMenuItem *item;
 	msg = new BMessage('head');
 	msg->AddString("template", tmpl);
+	if (match)
+		msg->AddString("match", match);
 	item = new BMenuItem(name, msg);
 	menu->AddItem(item);
 }
 
 
 BPopUpMenu *
-BuildPopUp()
+BuildPopUp(BDirectory &dir)
 {
 	BPopUpMenu *menu = new BPopUpMenu("menu", false);
 	//BMenuItem *item;
 	//BMessage *msg;
-	//BPath path;
-	//status_t err;
+	status_t err;
 
-	menu->SetFont(be_plain_font);
+	//menu->SetFont(be_plain_font);
 
-	AddTemplateItem(menu, B_UTF8_COPYRIGHT" Haiku", 
+	AddTemplateItem(menu, B_UTF8_COPYRIGHT " Haiku", 
 		sHaikuHeaderTemplate);
 
-	AddTemplateItem(menu, B_UTF8_COPYRIGHT" Me (Haiku)", 
+/*
+	AddTemplateItem(menu, B_UTF8_COPYRIGHT " Haiku (Add me)", 
+		sHaikuAddMeHeaderTemplate, sHaikuAddMeHeaderMatch);
+*/
+
+	AddTemplateItem(menu, B_UTF8_COPYRIGHT " Me (Haiku)", 
 		sHaikuMeHeaderTemplate);
 
-/*
-	// TODO: build list from text files
-	err = find_directory(B_COMMON_SETTINGS_DIRECTORY, &path, true);
-	if (err < B_OK)
-		return p;
-	BDirectory
-	p->AddItem();
+	AddTemplateItem(menu, "Id + " B_UTF8_COPYRIGHT "Me + MIT + Created", 
+		sIdMeMITCreatedHeaderTemplate);
 
-*/
+	AddTemplateItem(menu, "Id + " B_UTF8_COPYRIGHT "Me + Full MIT + Created", 
+		sIdMeFullMITCreatedHeaderTemplate);
 
-	//p->AddSeparatorItem();
-	//p->AddItem(new BMenuItem("Open Template Folder", new BMessage('optf')));
+	AddTemplateItem(menu, "Id + " B_UTF8_COPYRIGHT "Me + Full MIT Revised + Created", 
+		sIdMeFullMITRevisedCreatedHeaderTemplate);
+
+	if (dir.InitCheck() < B_OK)
+		return menu;
+
+	entry_ref ref;
+	while (dir.GetNextRef(&ref) == B_OK) {
+		BFile file(&ref, B_READ_ONLY);
+		if (file.InitCheck() < B_OK)
+			continue;
+		BString str;
+		if (file.Read(str.LockBuffer(1024), 1024) <= 0)
+			continue;
+		str.UnlockBuffer();
+		
+		AddTemplateItem(menu, ref.name, str.String());
+	}
+
+	menu->AddSeparatorItem();
+	menu->AddItem(new BMenuItem("Open Template Folder", new BMessage('optf')));
+	menu->AddItem(new BMenuItem("Set Author", new BMessage('seta')));
 	return menu;
 }
 
@@ -91,8 +217,12 @@
 status_t
 RunPopUpMenu(BPoint where, BString &header, BString &fileName)
 {
-	status_t err = B_ERROR;
-	BPopUpMenu *menu = BuildPopUp();
+	status_t err;
+	BPath path;
+	BDirectory dir;
+	err = GetSettingsDir(dir, path);
+	err = B_ERROR;
+	BPopUpMenu *menu = BuildPopUp(dir);
 	if (menu == NULL)
 		return B_ERROR;
 	
@@ -113,6 +243,12 @@
 			tmp.UnlockBuffer();
 			header.ReplaceAll("%DATE%", tmp.String());
 			tmp.Truncate(0);
+			
+			strftime(tmp.LockBuffer(100), 100, "%T", tim);
+			tmp.UnlockBuffer();
+			header.ReplaceAll("%TIME%", tmp.String());
+			tmp.Truncate(0);
+
 			// year
 			strftime(tmp.LockBuffer(20), 20, "%Y", tim);
 			tmp.UnlockBuffer();
@@ -128,6 +264,10 @@
 			header.ReplaceAll("%AUTHORMAIL%", tmp.String());
 			tmp.Truncate(0);
 
+			BString fileNameNoExt(fileName);
+			if (fileNameNoExt.FindLast('.') > -1)
+				fileNameNoExt.Truncate(fileNameNoExt.FindLast('.'));
+			header.ReplaceAll("%FILENAMENOEXT%", fileNameNoExt.String());
 			header.ReplaceAll("%FILENAME%", fileName.String());
 			/*
 			tmp << "Haiku";
@@ -139,8 +279,20 @@
 			break;
 		}
 		case 'optf':
+		{
+			const char *args[] = {path.Path(), NULL};
+			err = be_roster->Launch(sTrackerSig, 1, (char **)args);
+			//printf("err %s\n", strerror(err));
+			err = B_OK;
+			break;
+		}
+		case 'seta':
 			// TODO
+			//BFilePanel *panel = new ;
 			break;
+		case 0:
+			err = B_CANCELED;
+			break;
 		default:
 			break;
 	}
@@ -182,7 +334,9 @@
 
 	BString header;
 	result = RunPopUpMenu(where, header, fileName);
-	printf("result %s\n", strerror(result));
+	//printf("result %s\n", strerror(result));
+	if (result == B_CANCELED)
+		return B_OK;
 	if (result < B_OK)
 		return result;
 

Modified: trunk/Extensions/Jamfile
===================================================================
--- trunk/Extensions/Jamfile	2008-04-21 23:17:51 UTC (rev 518)
+++ trunk/Extensions/Jamfile	2008-04-22 01:06:23 UTC (rev 519)
@@ -66,7 +66,7 @@
 # <pe-src>
 PeExtension HeaderHeader
 	: HeaderHeader.cpp 
-	: be
+	: be tracker
 	;
 # </pe-src>
 



From mmu_man at mail.berlios.de  Tue Apr 22 03:26:22 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 22 Apr 2008 03:26:22 +0200
Subject: [pe-commits] r520 - trunk/Extensions
Message-ID: <200804220126.m3M1QM0I007968@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-22 03:26:21 +0200 (Tue, 22 Apr 2008)
New Revision: 520
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=520&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
   trunk/Extensions/WebPaste.cpp
Log:
- BString::LockBuffer is handy but make sure it's zeroed out.
- prepare for language dependant comment chars.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-22 01:06:23 UTC (rev 519)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-22 01:26:21 UTC (rev 520)
@@ -11,13 +11,13 @@
 
 static const char *sTrackerSig = "application/x-vnd.Be-TRAK";
 
-static const char *sHaikuHeaderTemplate = "/*
- * Copyright %YEAR%, Haiku.
- * Distributed under the terms of the MIT License.
- *
- * Authors:
- *		%AUTHOR% <%AUTHORMAIL%>
- */
+static const char *sHaikuHeaderTemplate = "%COMMS%
+%COMMC% Copyright %YEAR%, Haiku.
+%COMMC% Distributed under the terms of the MIT License.
+%COMMC%
+%COMMC% Authors:
+%COMMC%		%AUTHOR% <%AUTHORMAIL%>
+%COMME%
 ";
 
 static const char *sHaikuAddMeHeaderMatch = \
@@ -28,11 +28,11 @@
 ";
 
 
-static const char *sHaikuMeHeaderTemplate = "/*
- * Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.
- * Distributed under the terms of the MIT License.
- *		
- */
+static const char *sHaikuMeHeaderTemplate = "%COMMS%
+%COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.
+%COMMC% Distributed under the terms of the MIT License.
+%COMMC%	
+%COMME%
 ";
 
 /*
@@ -42,83 +42,83 @@
 */
 
 static const char *sIdMeMITCreatedHeaderTemplate = \
-"/*	$Id: %FILENAME% $
-
-	Copyright %YEAR% %AUTHOR%
-
-	Distributed under the MIT License
-
-	Created: %DATE%
-*/
+"%COMMS%	$Id: %FILENAME% $
+%COMML%
+%COMML%	Copyright %YEAR% %AUTHOR%
+%COMML%
+%COMML%	Distributed under the MIT License
+%COMML%
+%COMML%	Created: %DATE%
+%COMME%
 ";
 
 static const char *sIdMeFullMITCreatedHeaderTemplate = \
-"/*	$Id: %FILENAME% $
-	
-	Copyright %YEAR%
-	        %AUTHOR%  All rights reserved.
-	
-	Redistribution and use in source and binary forms, with or without
-	modification, are permitted provided that the following conditions are met:
-	1. Redistributions of source code must retain the above copyright notice,
-	   this list of conditions and the following disclaimer.
-	2. Redistributions in binary form must reproduce the above copyright notice,
-	   this list of conditions and the following disclaimer in the documentation
-	   and/or other materials provided with the distribution.
-	3. All advertising materials mentioning features or use of this software
-	   must display the following acknowledgement:
-	   
-	    This product includes software developed by %AUTHOR%.
-	
-	4. The name of %AUTHOR% may not be used to endorse or
-	   promote products derived from this software without specific prior
-	   written permission.
-	
-	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
-	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
-	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
-
-	Created: %DATE% %TIME%
-*/
+"%COMMS%	$Id: %FILENAME% $
+%COMML%	
+%COMML%	Copyright %YEAR%
+%COMML%	        %AUTHOR%  All rights reserved.
+%COMML%	
+%COMML%	Redistribution and use in source and binary forms, with or without
+%COMML%	modification, are permitted provided that the following conditions are met:
+%COMML%	1. Redistributions of source code must retain the above copyright notice,
+%COMML%	   this list of conditions and the following disclaimer.
+%COMML%	2. Redistributions in binary form must reproduce the above copyright notice,
+%COMML%	   this list of conditions and the following disclaimer in the documentation
+%COMML%	   and/or other materials provided with the distribution.
+%COMML%	3. All advertising materials mentioning features or use of this software
+%COMML%	   must display the following acknowledgement:
+%COMML%	   
+%COMML%	    This product includes software developed by %AUTHOR%.
+%COMML%	
+%COMML%	4. The name of %AUTHOR% may not be used to endorse or
+%COMML%	   promote products derived from this software without specific prior
+%COMML%	   written permission.
+%COMML%	
+%COMML%	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+%COMML%	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+%COMML%	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+%COMML%	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+%COMML%	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+%COMML%	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+%COMML%	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+%COMML%	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+%COMML%	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+%COMML%	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+%COMML%
+%COMML%	Created: %DATE% %TIME%
+%COMME%
 ";
 
 static const char *sIdMeFullMITRevisedCreatedHeaderTemplate = \
-"/*	$Id: %FILENAME% $
-	
-	Copyright %YEAR%
-	        %AUTHOR%  All rights reserved.
-	
-	Redistribution and use in source and binary forms, with or without
-	modification, are permitted provided that the following conditions are met:
-	1. Redistributions of source code must retain the above copyright notice,
-	   this list of conditions and the following disclaimer.
-	2. Redistributions in binary form must reproduce the above copyright notice,
-	   this list of conditions and the following disclaimer in the documentation
-	   and/or other materials provided with the distribution.
-	4. The name of %AUTHOR% may not be used to endorse or
-	   promote products derived from this software without specific prior
-	   written permission.
-	
-	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
-	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
-	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
-
-	Created: %DATE% %TIME%
-*/
+"%COMMS%	$Id: %FILENAME% $
+%COMML%	
+%COMML%	Copyright %YEAR%
+%COMML%	        %AUTHOR%  All rights reserved.
+%COMML%	
+%COMML%	Redistribution and use in source and binary forms, with or without
+%COMML%	modification, are permitted provided that the following conditions are met:
+%COMML%	1. Redistributions of source code must retain the above copyright notice,
+%COMML%	   this list of conditions and the following disclaimer.
+%COMML%	2. Redistributions in binary form must reproduce the above copyright notice,
+%COMML%	   this list of conditions and the following disclaimer in the documentation
+%COMML%	   and/or other materials provided with the distribution.
+%COMML%	4. The name of %AUTHOR% may not be used to endorse or
+%COMML%	   promote products derived from this software without specific prior
+%COMML%	   written permission.
+%COMML%	
+%COMML%	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+%COMML%	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+%COMML%	FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+%COMML%	AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+%COMML%	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+%COMML%	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+%COMML%	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+%COMML%	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+%COMML%	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+%COMML%	ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 	
+%COMML%
+%COMML%	Created: %DATE% %TIME%
+%COMME%
 ";
 
 
@@ -200,7 +200,9 @@
 		if (file.InitCheck() < B_OK)
 			continue;
 		BString str;
-		if (file.Read(str.LockBuffer(1024), 1024) <= 0)
+		char *p = str.LockBuffer(1024);
+		memset(p, 0, 1024);
+		if (file.Read(p, 1024) <= 0)
 			continue;
 		str.UnlockBuffer();
 		
@@ -239,18 +241,25 @@
 			time_t now = time(NULL);
 			struct tm *tim = localtime(&now);
 			// date
-			strftime(tmp.LockBuffer(100), 100, "%F", tim);
+			char *p;
+			p = tmp.LockBuffer(100);
+			memset(p, 0, 100);
+			strftime(p, 100, "%F", tim);
 			tmp.UnlockBuffer();
 			header.ReplaceAll("%DATE%", tmp.String());
 			tmp.Truncate(0);
 			
-			strftime(tmp.LockBuffer(100), 100, "%T", tim);
+			p = tmp.LockBuffer(100);
+			memset(p, 0, 100);
+			strftime(p, 100, "%T", tim);
 			tmp.UnlockBuffer();
 			header.ReplaceAll("%TIME%", tmp.String());
 			tmp.Truncate(0);
 
 			// year
-			strftime(tmp.LockBuffer(20), 20, "%Y", tim);
+			p = tmp.LockBuffer(10);
+			memset(p, 0, 10);
+			strftime(p, 10, "%Y", tim);
 			tmp.UnlockBuffer();
 			header.ReplaceAll("%YEAR%", tmp.String());
 			tmp.Truncate(0);
@@ -275,6 +284,17 @@
 			tmp.Truncate(0);
 			*/
 
+			// TODO: depend on language
+			// comment start
+			header.ReplaceAll("%COMMS%", "/*");
+			// comment cont'd
+			header.ReplaceAll("%COMMC%", " *");
+			// comment cont'd lazy (blank if possible)
+			header.ReplaceAll("%COMML%", "");
+			// comment end
+			header.ReplaceAll("%COMME%", " */");
+
+
 			err = B_OK;
 			break;
 		}

Modified: trunk/Extensions/WebPaste.cpp
===================================================================
--- trunk/Extensions/WebPaste.cpp	2008-04-22 01:06:23 UTC (rev 519)
+++ trunk/Extensions/WebPaste.cpp	2008-04-22 01:26:21 UTC (rev 520)
@@ -80,6 +80,7 @@
 	do {
 		len = Length();
 		char *buf = LockBuffer(len + 4096);
+		memset(buf + len, 0, 4096);
 		buf += len;
 		int got = fread(buf, 1, 4096, fFile);
 		//fprintf(stderr, "got %d\n", got);



From mmu_man at mail.berlios.de  Tue Apr 22 04:03:16 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Tue, 22 Apr 2008 04:03:16 +0200
Subject: [pe-commits] r521 - trunk/Extensions
Message-ID: <200804220203.m3M23GIv009395@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-22 04:03:15 +0200 (Tue, 22 Apr 2008)
New Revision: 521
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=521&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
   trunk/Extensions/Jamfile
Log:
Use comment depending on language.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-22 01:26:21 UTC (rev 520)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-22 02:03:15 UTC (rev 521)
@@ -3,6 +3,9 @@
  */
 
 #include "PeAddOn.h"
+#include "PDoc.h"
+#include "PText.h"
+#include "CLanguageInterface.h"
 #include <ctype.h>
 #include <time.h>
 #include <FilePanel.h>
@@ -148,7 +151,10 @@
 }
 
 void
-AddTemplateItem(BPopUpMenu *menu, const char *name, const char *tmpl, const char *match=NULL)
+AddTemplateItem(BPopUpMenu *menu, 
+	const char *name, 
+	const char *tmpl, 
+	const char *match=NULL)
 {
 	BMessage *msg;
 	BMenuItem *item;
@@ -195,7 +201,8 @@
 		return menu;
 
 	entry_ref ref;
-	while (dir.GetNextRef(&ref) == B_OK) {
+	while (dir.GetNextRef(&ref) == B_OK)
+	{
 		BFile file(&ref, B_READ_ONLY);
 		if (file.InitCheck() < B_OK)
 			continue;
@@ -217,7 +224,8 @@
 
 
 status_t
-RunPopUpMenu(BPoint where, BString &header, BString &fileName)
+RunPopUpMenu(BPoint where, BString &header, BString &fileName, 
+	CLanguageInterface *languageInterface)
 {
 	status_t err;
 	BPath path;
@@ -232,7 +240,8 @@
 	//if (item && item->Message())
 	//	item->Message()->PrintToStream();
 
-	switch ((item && item->Message()) ? item->Message()->what : 0) {
+	switch ((item && item->Message()) ? item->Message()->what : 0)
+	{
 		case 'head':
 		{
 			if (item->Message()->FindString("template", &header) < B_OK)
@@ -284,15 +293,60 @@
 			tmp.Truncate(0);
 			*/
 
-			// TODO: depend on language
+			// better values for C++
+			BString language("C/C++");
+			BString commentLineStart("/*");
+			BString commentLineEnd("");
+			BString commentBlockStart("/*");
+			BString commentBlockCont(" *");
+			BString commentBlockLazy("");
+			BString commentBlockLineEnd("");
+			BString commentBlockEnd(" */");
+			if (languageInterface)
+			{
+				// if not C++
+				if (language != languageInterface->Name())
+				{
+					language = languageInterface->Name();
+					commentLineStart = languageInterface->LineCommentStart();
+					commentLineEnd = languageInterface->LineCommentEnd();
+					// I'd miss a CommentCanSpanLines()
+					// let's assume line end means can span
+					if (commentLineEnd.Length())
+					{
+						commentBlockStart = commentLineStart;
+						commentBlockCont = "";
+						commentBlockLazy = "";
+						commentBlockLineEnd = "";
+						commentBlockEnd = commentLineEnd;
+					}
+					else
+					{
+						commentBlockStart = commentLineStart;
+						commentBlockCont = commentLineStart;
+						commentBlockLazy = commentLineStart;
+						commentBlockLineEnd = commentLineEnd;
+						commentBlockEnd = commentLineStart;
+					}
+					/*
+					printf("LANG:'%s' CS:'%s' CE:'%s'\n", 
+						language.String(), 
+						commentLineStart.String(), 
+						commentLineEnd.String());
+					*/
+				}
+			}
 			// comment start
-			header.ReplaceAll("%COMMS%", "/*");
+			header.ReplaceAll("%COMMS%", commentBlockStart.String());
 			// comment cont'd
-			header.ReplaceAll("%COMMC%", " *");
+			header.ReplaceAll("%COMMC%", commentBlockCont.String());
 			// comment cont'd lazy (blank if possible)
-			header.ReplaceAll("%COMML%", "");
+			header.ReplaceAll("%COMML%", commentBlockLazy.String());
 			// comment end
-			header.ReplaceAll("%COMME%", " */");
+			header.ReplaceAll("%COMME%", commentBlockEnd.String());
+			// comment line end
+			commentBlockLineEnd << "\n";
+			header.ReplaceAll("\n", commentBlockLineEnd.String());
 
 
 			err = B_OK;
@@ -339,7 +393,8 @@
 	entry_ref headerFile;
 	BPoint where(0,0);
 
-	if (addon->Window() && addon->Window()->Lock()) {
+	if (addon->Window() && addon->Window()->Lock())
+	{
 		uint32 buttons;
 		addon->Window()->ChildAt(0)->GetMouse(&where, &buttons);
 		addon->Window()->ChildAt(0)->ConvertToScreen(&where);
@@ -352,8 +407,20 @@
 	if (result >= B_OK)
 		fileName = headerFile.name;
 
+	CLanguageInterface *languageInterface = NULL;
+	if (addon->Window())
+	{
+		PDoc *doc = dynamic_cast<PDoc *>(addon->Window());
+		if (doc && doc->TextView())
+		{
+			int lang = doc->TextView()->Language();
+			if (lang > -1)
+				languageInterface = CLanguageInterface::FindIntf(lang);
+		}
+	}
+
 	BString header;
-	result = RunPopUpMenu(where, header, fileName);
+	result = RunPopUpMenu(where, header, fileName, languageInterface);
 	//printf("result %s\n", strerror(result));
 	if (result == B_CANCELED)
 		return B_OK;

Modified: trunk/Extensions/Jamfile
===================================================================
--- trunk/Extensions/Jamfile	2008-04-22 01:26:21 UTC (rev 520)
+++ trunk/Extensions/Jamfile	2008-04-22 02:03:15 UTC (rev 521)
@@ -66,7 +66,7 @@
 # <pe-src>
 PeExtension HeaderHeader
 	: HeaderHeader.cpp 
-	: be tracker
+	: libhekkel.so <nogrist>pe be tracker $(STDC++LIB)
 	;
 # </pe-src>
 



From mmu_man at mail.berlios.de  Wed Apr 23 01:10:19 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Wed, 23 Apr 2008 01:10:19 +0200
Subject: [pe-commits] r522 - trunk/Extensions
Message-ID: <200804222310.m3MNAJXL031502@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-23 01:10:12 +0200 (Wed, 23 Apr 2008)
New Revision: 522
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=522&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
Log:
Tricky way to use a BFilePanel synchronously to select a people file for author name and email.
Not yet used.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-22 02:03:15 UTC (rev 521)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-22 23:10:12 UTC (rev 522)
@@ -126,6 +126,125 @@
 
 
 //------------------------------------------------------------------------------
+//	#pragma mark - class PanelHandler
+
+class PanelHandler : public BHandler {
+	public:
+		PanelHandler();
+		~PanelHandler();
+	virtual void	MessageReceived(BMessage *message);
+
+	status_t	Wait();
+	BMessage*	Message() const { return fMessage; };
+	private:
+		sem_id fSem;
+		BMessage *fMessage;
+};
+
+
+PanelHandler::PanelHandler()
+{
+	fSem = create_sem(0, "PanelHandlerTrigger");
+	fMessage = NULL;
+}
+
+
+PanelHandler::~PanelHandler()
+{
+	delete_sem(fSem);
+	delete fMessage;
+}
+
+
+void
+PanelHandler::MessageReceived(BMessage *message)
+{
+	delete fMessage;
+	fMessage = new BMessage(*message);
+	release_sem(fSem);
+}
+
+
+status_t
+PanelHandler::Wait()
+{
+	return acquire_sem(fSem);
+}
+
+
+//------------------------------------------------------------------------------
+//	#pragma mark - class MimeRefFilter
+
+class MimeRefFilter : public BRefFilter {
+	public:
+			MimeRefFilter(const char *mime);
+			MimeRefFilter(const char *mimes[]);
+			//MimeRefFilter(BList *mimes);
+	virtual	~MimeRefFilter();
+
+	virtual	bool	Filter(const entry_ref *ref, BNode *node, 
+							struct stat *st, const char *filetype);
+	private:
+		BList	*fMimes;
+};
+
+MimeRefFilter::MimeRefFilter(const char *mime)
+{
+	fMimes = new BList;
+	fMimes->AddItem(new BString(mime));
+}
+
+
+MimeRefFilter::MimeRefFilter(const char *mimes[])
+{
+	int i;
+	fMimes = new BList;
+	for (i = 0; mimes[i]; i++)
+	{
+		fMimes->AddItem(new BString(mimes[i]));
+	}
+}
+
+
+MimeRefFilter::~MimeRefFilter()
+{
+	int i;
+	for (i = fMimes->CountItems() - 1; i > -1; i--)
+	{
+		delete (BString *)fMimes->ItemAt(i);
+	}
+	delete fMimes;
+}
+
+
+bool
+MimeRefFilter::Filter(const entry_ref *ref, BNode *node, 
+					struct stat *st, const char *filetype)
+{
+	int i;
+	// allow folders else it's quite hard to navigate :)
+	if (node->IsDirectory())
+		return true;
+	//BNode target;
+	if (node->IsSymLink())
+	{
+		// init target 
+		// node = &target;
+		// if
+		return true;
+	}
+	
+	for (i = fMimes->CountItems() - 1; i > -1; i--)
+	{
+		BString *mime = (BString *)fMimes->ItemAt(i);
+		if (filetype == *mime)
+			return true;
+	}
+	return false;
+}
+
+
+//------------------------------------------------------------------------------
 //	#pragma mark - implementation
 
 
@@ -361,9 +480,48 @@
 			break;
 		}
 		case 'seta':
-			// TODO
-			//BFilePanel *panel = new ;
+		{
+			MimeRefFilter filter("application/x-person");
+			BPath path;
+			entry_ref people;
+
+			if (find_directory(B_USER_DIRECTORY, &path) == B_OK)
+			{
+				path.Append("people");
+				get_ref_for_path(path.Path(), &people);
+			}
+
+			BFilePanel panel(B_OPEN_PANEL,
+							NULL, 
+							&people,
+							B_FILE_NODE,
+							false,
+							NULL,
+							&filter);
+			// trick to synchronously use BFilePanel
+			PanelHandler *handler = new PanelHandler;
+			if (panel.Window()->Lock())
+			{
+				panel.Window()->AddHandler(handler);
+				panel.Window()->Unlock();
+			}
+			panel.SetTarget(BMessenger(handler));
+			panel.Show();
+			if (handler->Wait() < B_OK)
+				break;
+			if (!handler->Message())
+				break;
+			if (handler->Message()->what == B_CANCEL)
+				break;
+			entry_ref ref;
+			//panel.Message()->PrintToStream();
+			if (panel.GetNextSelectedRef(&ref) == B_OK)
+			{
+				printf("ref:%s\n", ref.name);
+				// TODO
+			}
 			break;
+		}
 		case 0:
 			err = B_CANCELED;
 			break;



From mmu_man at mail.berlios.de  Wed Apr 23 01:52:04 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Wed, 23 Apr 2008 01:52:04 +0200
Subject: [pe-commits] r523 - trunk/Extensions
Message-ID: <200804222352.m3MNq4e8000217@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-23 01:52:04 +0200 (Wed, 23 Apr 2008)
New Revision: 523
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=523&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
Log:
Use the selected People file for author name and email.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-22 23:10:12 UTC (rev 522)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-22 23:52:04 UTC (rev 523)
@@ -392,15 +392,43 @@
 			header.ReplaceAll("%YEAR%", tmp.String());
 			tmp.Truncate(0);
 
-			// TODO fetch from query on META:email==**
-			// or specific people file
-			tmp << "Fran?ois Revol";
+			// fetch from query on META:email==** ?
+			p = tmp.LockBuffer(B_PATH_NAME_LENGTH);
+			memset(p, 0, B_PATH_NAME_LENGTH);
+			err = dir.ReadAttr("pe:author_people", B_STRING_TYPE, 0LL, p, 
+				B_PATH_NAME_LENGTH);
+			tmp.UnlockBuffer();
+			//printf("ppl:%s\n", tmp.String());
+			BNode people;
+			if (err > 0)
+				people.SetTo(tmp.String());
+			tmp.Truncate(0);
+			
+			BString attr;
+
+			p = attr.LockBuffer(256);
+			memset(p, 0, 256);
+			err = people.ReadAttr("META:name", B_ANY_TYPE, 0LL, p, 256);
+			//printf("ReadAttr: %d, %s\n", err, attr.String());
+			attr.UnlockBuffer();
+
+			tmp << attr;
 			header.ReplaceAll("%AUTHOR%", tmp.String());
 			tmp.Truncate(0);
-			tmp << "revol at free.fr";
+			
+			attr.Truncate(0);
+			p = attr.LockBuffer(256);
+			memset(p, 0, 256);
+			err = people.ReadAttr("META:email", B_ANY_TYPE, 0LL, p, 256);
+			//printf("ReadAttr: %d, %s\n", err, attr.String());
+			attr.UnlockBuffer();
+			
+			tmp << attr;
 			header.ReplaceAll("%AUTHORMAIL%", tmp.String());
 			tmp.Truncate(0);
 
+			attr.Truncate(0);
+
 			BString fileNameNoExt(fileName);
 			if (fileNameNoExt.FindLast('.') > -1)
 				fileNameNoExt.Truncate(fileNameNoExt.FindLast('.'));
@@ -517,8 +545,10 @@
 			//panel.Message()->PrintToStream();
 			if (panel.GetNextSelectedRef(&ref) == B_OK)
 			{
-				printf("ref:%s\n", ref.name);
-				// TODO
+				//printf("ref:%s\n", ref.name);
+				path.SetTo(&ref);
+				dir.WriteAttr("pe:author_people", B_STRING_TYPE, 0LL, 
+					path.Path(), strlen(path.Path()));
 			}
 			break;
 		}



From mmu_man at mail.berlios.de  Wed Apr 23 02:39:35 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Wed, 23 Apr 2008 02:39:35 +0200
Subject: [pe-commits] r524 - trunk/Extensions
Message-ID: <200804230039.m3N0dZOw007258@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-23 02:39:34 +0200 (Wed, 23 Apr 2008)
New Revision: 524
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=524&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
Log:
- use a table for people attributes
- add about info and use Pe to display it.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-22 23:52:04 UTC (rev 523)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-23 00:39:34 UTC (rev 524)
@@ -14,6 +14,35 @@
 
 static const char *sTrackerSig = "application/x-vnd.Be-TRAK";
 
+static const char *sAboutText = "HeaderHeader Extension for Pe
+
+This extension prepends a chooseable licence header the current file, 
+using the appropriate comment characters for the language used, 
+and informations from a selected People file as author.
+
+First select your own People file from \"Set Author"B_UTF8_ELLIPSIS"\", 
+then just select the header you want to use.
+You can also add your own templates in the settings folder. 
+Use the \"Open Template Folder"B_UTF8_ELLIPSIS"\" menu, 
+create text files there which contain the licence or informations you want. 
+
+Keywords from the list below will be replaced by the corresponding value:
+%COMMS%		Start of comment block string
+%COMMC%		Comment block continuation string
+%COMML%		Comment block continuation string (blank if possible)
+%COMME%		End of comment block string
+%FILENAME%		Filename
+%FILENAMENOEXT%	Filename without extension
+%YEAR%		Current year
+%DATE%		Current date (YYYY-mm-dd)
+%TIME%		Current time (HH:MM:SS)
+(from the people file)
+%AUTHOR%		Your name
+%AUTHORMAIL%	Your email
+%COMPANY%		Company name
+%AUTHORURL%		Your url
+";
+
 static const char *sHaikuHeaderTemplate = "%COMMS%
 %COMMC% Copyright %YEAR%, Haiku.
 %COMMC% Distributed under the terms of the MIT License.
@@ -336,8 +365,12 @@
 	}
 
 	menu->AddSeparatorItem();
-	menu->AddItem(new BMenuItem("Open Template Folder", new BMessage('optf')));
-	menu->AddItem(new BMenuItem("Set Author", new BMessage('seta')));
+	menu->AddItem(new BMenuItem("Open Template Folder"B_UTF8_ELLIPSIS, 
+		new BMessage('optf')));
+	menu->AddItem(new BMenuItem("Set Author"B_UTF8_ELLIPSIS, 
+		new BMessage('seta')));
+	menu->AddItem(new BMenuItem("About"B_UTF8_ELLIPSIS, 
+		new BMessage(B_ABOUT_REQUESTED)));
 	return menu;
 }
 
@@ -406,28 +439,32 @@
 			
 			BString attr;
 
-			p = attr.LockBuffer(256);
-			memset(p, 0, 256);
-			err = people.ReadAttr("META:name", B_ANY_TYPE, 0LL, p, 256);
-			//printf("ReadAttr: %d, %s\n", err, attr.String());
-			attr.UnlockBuffer();
+			static struct {
+				const char *tmplName;
+				const char *attrName;
+			} attrMap[] = {
+				{ "%AUTHOR%", "META:name" },
+				{ "%AUTHORMAIL%", "META:email" },
+				{ "%COMPANY%", "META:company" },
+				{ "%AUTHORURL%", "META:url" },
+				{ NULL, NULL }
+			};
+			int i;
 
-			tmp << attr;
-			header.ReplaceAll("%AUTHOR%", tmp.String());
-			tmp.Truncate(0);
-			
-			attr.Truncate(0);
-			p = attr.LockBuffer(256);
-			memset(p, 0, 256);
-			err = people.ReadAttr("META:email", B_ANY_TYPE, 0LL, p, 256);
-			//printf("ReadAttr: %d, %s\n", err, attr.String());
-			attr.UnlockBuffer();
-			
-			tmp << attr;
-			header.ReplaceAll("%AUTHORMAIL%", tmp.String());
-			tmp.Truncate(0);
+			for (i = 0; attrMap[i].tmplName; i++)
+			{
+				p = attr.LockBuffer(256);
+				memset(p, 0, 256);
+				err = people.ReadAttr(attrMap[i].attrName, B_ANY_TYPE, 
+					0LL, p, 256);
+				//printf("ReadAttr: %d, %s\n", err, attr.String());
+				attr.UnlockBuffer();
 
-			attr.Truncate(0);
+				tmp << attr;
+				header.ReplaceAll(attrMap[i].tmplName, tmp.String());
+				tmp.Truncate(0);
+				attr.Truncate(0);
+			}
 
 			BString fileNameNoExt(fileName);
 			if (fileNameNoExt.FindLast('.') > -1)
@@ -504,7 +541,7 @@
 			const char *args[] = {path.Path(), NULL};
 			err = be_roster->Launch(sTrackerSig, 1, (char **)args);
 			//printf("err %s\n", strerror(err));
-			err = B_OK;
+			err = B_CANCELED;
 			break;
 		}
 		case 'seta':
@@ -550,8 +587,29 @@
 				dir.WriteAttr("pe:author_people", B_STRING_TYPE, 0LL, 
 					path.Path(), strlen(path.Path()));
 			}
+			err = B_CANCELED;
 			break;
 		}
+		case B_ABOUT_REQUESTED:
+		{
+			BString tmpPath("/tmp/Pe-HeaderHeader-About-");
+			tmpPath << system_time() << "-" << getpid() << ".txt";
+			entry_ref ref;
+			get_ref_for_path(tmpPath.String(), &ref);
+			{
+				BFile f(&ref, B_CREATE_FILE | B_WRITE_ONLY);
+				err = f.InitCheck();
+				if (err < 0)
+					break;
+				f.Write(sAboutText, strlen(sAboutText));
+				f.SetPermissions(0444);
+			}
+			BMessage msg(B_REFS_RECEIVED);
+			msg.AddRef("refs", &ref);
+			err = be_app_messenger.SendMessage(&msg);
+			err = B_CANCELED;
+			break;
+		}
 		case 0:
 			err = B_CANCELED;
 			break;



From superstippi at gmx.de  Wed Apr 23 07:35:36 2008
From: superstippi at gmx.de (Stephan Assmus)
Date: Wed, 23 Apr 2008 07:35:36 +0200
Subject: [pe-commits] r522 - trunk/Extensions
In-Reply-To: <200804222310.m3MNAJXL031502@sheep.berlios.de>
References: <200804222310.m3MNAJXL031502@sheep.berlios.de>
Message-ID: <20080423073536.1044.1@stippis2.1208927915.fake>


mmu_man at BerliOS wrote:
> +            BFilePanel panel(B_OPEN_PANEL,
> +                            NULL, 
> +                            &people,
> +                            B_FILE_NODE,
> +                            false,
> +                            NULL,
> +                            &filter);
> +            // trick to synchronously use BFilePanel
> +            PanelHandler *handler = new PanelHandler;
> +            if (panel.Window()->Lock())
> +            {
> +                panel.Window()->AddHandler(handler);
> +                panel.Window()->Unlock();
> +            }
> +            panel.SetTarget(BMessenger(handler));
> +            panel.Show();
> +            if (handler->Wait() < B_OK)
> +                break;
> +            if (!handler->Message())
> +                break;
> +            if (handler->Message()->what == B_CANCEL)
> +                break;
> +            entry_ref ref;
> +            //panel.Message()->PrintToStream();
> +            if (panel.GetNextSelectedRef(&ref) == B_OK)
> +            {
> +                printf("ref:%s\n", ref.name);
> +                // TODO
> +            }
>              break;

I am not sure, but I think you have to delete the handler, no? Or are any 
handlers that remain in the handler list deleted by BLooper? In Haiku, they 
are removed, so they don't have a parent anymore, but not deleted.

Best regards,
-Stephan


From revol at free.fr  Wed Apr 23 11:35:33 2008
From: revol at free.fr (=?windows-1252?q?Fran=E7ois?= Revol)
Date: Wed, 23 Apr 2008 11:35:33 +0200 CEST
Subject: [pe-commits] r522 - trunk/Extensions
In-Reply-To: <20080423073536.1044.1@stippis2.1208927915.fake>
Message-ID: <881246966-BeMail@laptop>

> I am not sure, but I think you have to delete the handler, no? Or are 
> any 
> handlers that remain in the handler list deleted by BLooper? In 
> Haiku, they 
> are removed, so they don't have a parent anymore, but not deleted.

Oh right
"BHandlers that have been added to the BLooper are not deleted, but 
BMessageFilter objects added as common filters are."

I likely mixed up with BView...

Fran?ois.



From mmu_man at mail.berlios.de  Wed Apr 23 11:45:02 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Wed, 23 Apr 2008 11:45:02 +0200
Subject: [pe-commits] r525 - trunk/Extensions
Message-ID: <200804230945.m3N9j2aK027182@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-23 11:45:01 +0200 (Wed, 23 Apr 2008)
New Revision: 525
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=525&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
Log:
Delete handler after deleting the panel. Thx stippi.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-23 00:39:34 UTC (rev 524)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-23 09:45:01 UTC (rev 525)
@@ -556,22 +556,18 @@
 				get_ref_for_path(path.Path(), &people);
 			}
 
-			BFilePanel panel(B_OPEN_PANEL,
-							NULL, 
-							&people,
-							B_FILE_NODE,
-							false,
-							NULL,
-							&filter);
+			BFilePanel *panel;
+			panel = new BFilePanel(B_OPEN_PANEL, NULL, &people,
+				B_FILE_NODE, false, NULL, &filter);
 			// trick to synchronously use BFilePanel
 			PanelHandler *handler = new PanelHandler;
-			if (panel.Window()->Lock())
+			if (panel->Window()->Lock())
 			{
-				panel.Window()->AddHandler(handler);
-				panel.Window()->Unlock();
+				panel->Window()->AddHandler(handler);
+				panel->Window()->Unlock();
 			}
-			panel.SetTarget(BMessenger(handler));
-			panel.Show();
+			panel->SetTarget(BMessenger(handler));
+			panel->Show();
 			if (handler->Wait() < B_OK)
 				break;
 			if (!handler->Message())
@@ -579,14 +575,16 @@
 			if (handler->Message()->what == B_CANCEL)
 				break;
 			entry_ref ref;
-			//panel.Message()->PrintToStream();
-			if (panel.GetNextSelectedRef(&ref) == B_OK)
+			//panel->Message()->PrintToStream();
+			if (panel->GetNextSelectedRef(&ref) == B_OK)
 			{
 				//printf("ref:%s\n", ref.name);
 				path.SetTo(&ref);
 				dir.WriteAttr("pe:author_people", B_STRING_TYPE, 0LL, 
 					path.Path(), strlen(path.Path()));
 			}
+			delete panel;
+			delete handler;
 			err = B_CANCELED;
 			break;
 		}



From mmu_man at mail.berlios.de  Sat Apr 26 22:01:40 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Sat, 26 Apr 2008 22:01:40 +0200
Subject: [pe-commits] r526 - trunk/Extensions
Message-ID: <200804262001.m3QK1eE9014939@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-26 22:01:40 +0200 (Sat, 26 Apr 2008)
New Revision: 526
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=526&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
Log:
Remove extra line.


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-23 09:45:01 UTC (rev 525)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-26 20:01:40 UTC (rev 526)
@@ -63,7 +63,6 @@
 static const char *sHaikuMeHeaderTemplate = "%COMMS%
 %COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>.
 %COMMC% Distributed under the terms of the MIT License.
-%COMMC%	
 %COMME%
 ";
 



From mmu_man at mail.berlios.de  Sat Apr 26 22:05:36 2008
From: mmu_man at mail.berlios.de (mmu_man at BerliOS)
Date: Sat, 26 Apr 2008 22:05:36 +0200
Subject: [pe-commits] r527 - trunk/Extensions
Message-ID: <200804262005.m3QK5aND015454@sheep.berlios.de>

Author: mmu_man
Date: 2008-04-26 22:05:35 +0200 (Sat, 26 Apr 2008)
New Revision: 527
ViewCVS: http://svn.berlios.de/viewcvs/pe-editor?rev=527&view=rev

Modified:
   trunk/Extensions/HeaderHeader.cpp
Log:
Alternate (c) Me with "All Rights Reserved".


Modified: trunk/Extensions/HeaderHeader.cpp
===================================================================
--- trunk/Extensions/HeaderHeader.cpp	2008-04-26 20:01:40 UTC (rev 526)
+++ trunk/Extensions/HeaderHeader.cpp	2008-04-26 20:05:35 UTC (rev 527)
@@ -72,6 +72,12 @@
 ";
 */
 
+static const char *sHaikuMeRightsHeaderTemplate = "%COMMS%
+%COMMC% Copyright %YEAR%, %AUTHOR%, <%AUTHORMAIL%>. All rights reserved.
+%COMMC% Distributed under the terms of the MIT License.
+%COMME%
+";
+
 static const char *sIdMeMITCreatedHeaderTemplate = \
 "%COMMS%	$Id: %FILENAME% $
 %COMML%
@@ -335,6 +341,9 @@
 	AddTemplateItem(menu, B_UTF8_COPYRIGHT " Me (Haiku)", 
 		sHaikuMeHeaderTemplate);
 
+	AddTemplateItem(menu, B_UTF8_COPYRIGHT " Me (Haiku) + Rights Reserved", 
+		sHaikuMeRightsHeaderTemplate);
+
 	AddTemplateItem(menu, "Id + " B_UTF8_COPYRIGHT "Me + MIT + Created", 
 		sIdMeMITCreatedHeaderTemplate);
 



